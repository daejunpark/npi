
const {:existential true} b0000 : bool;
const {:existential true} b0001 : bool;
const {:existential true} b0002 : bool;
const {:existential true} b0003 : bool;
const {:existential true} b0004 : bool;
const {:existential true} b0005 : bool;
const {:existential true} b0006 : bool;
const {:existential true} b0007 : bool;
const {:existential true} b0008 : bool;
const {:existential true} b0009 : bool;
const {:existential true} b0010 : bool;
const {:existential true} b0011 : bool;
const {:existential true} b0012 : bool;
const {:existential true} b0013 : bool;
const {:existential true} b0014 : bool;
const {:existential true} b0015 : bool;
const {:existential true} b0016 : bool;
const {:existential true} b0017 : bool;
const {:existential true} b0018 : bool;
const {:existential true} b0019 : bool;
const {:existential true} b0020 : bool;
const {:existential true} b0021 : bool;
const {:existential true} b0022 : bool;
const {:existential true} b0023 : bool;
const {:existential true} b0024 : bool;
const {:existential true} b0025 : bool;
const {:existential true} b0026 : bool;
const {:existential true} b0027 : bool;
const {:existential true} b0028 : bool;
const {:existential true} b0029 : bool;
const {:existential true} b0030 : bool;
const {:existential true} b0031 : bool;
const {:existential true} b0032 : bool;
const {:existential true} b0033 : bool;
const {:existential true} b0034 : bool;
const {:existential true} b0035 : bool;
const {:existential true} b0036 : bool;
const {:existential true} b0037 : bool;
const {:existential true} b0038 : bool;
const {:existential true} b0039 : bool;
const {:existential true} b0040 : bool;
const {:existential true} b0041 : bool;
const {:existential true} b0042 : bool;
const {:existential true} b0043 : bool;
const {:existential true} b0044 : bool;
const {:existential true} b0045 : bool;
const {:existential true} b0046 : bool;
const {:existential true} b0047 : bool;
const {:existential true} b0048 : bool;
const {:existential true} b0049 : bool;
const {:existential true} b0050 : bool;
const {:existential true} b0051 : bool;
const {:existential true} b0052 : bool;
const {:existential true} b0053 : bool;
const {:existential true} b0054 : bool;
const {:existential true} b0055 : bool;
const {:existential true} b0056 : bool;
const {:existential true} b0057 : bool;
const {:existential true} b0058 : bool;
const {:existential true} b0059 : bool;
const {:existential true} b0060 : bool;
const {:existential true} b0061 : bool;
const {:existential true} b0062 : bool;
const {:existential true} b0063 : bool;
const {:existential true} b0064 : bool;
const {:existential true} b0065 : bool;
const {:existential true} b0066 : bool;
const {:existential true} b0067 : bool;
const {:existential true} b0068 : bool;
const {:existential true} b0069 : bool;
const {:existential true} b0070 : bool;
const {:existential true} b0071 : bool;
const {:existential true} b0072 : bool;
const {:existential true} b0073 : bool;
const {:existential true} b0074 : bool;
const {:existential true} b0075 : bool;
const {:existential true} b0076 : bool;
const {:existential true} b0077 : bool;
const {:existential true} b0078 : bool;
const {:existential true} b0079 : bool;

axiom $arch_ptr_size == 8;

axiom $arch_spec_ptr_start == $max.u8;

const unique ^$##thread_id: $ctype;

axiom $def_math_type(^$##thread_id);

type $##thread_id;

const unique ^$##club: $ctype;

axiom $def_math_type(^$##club);

type $##club;

const unique ^b_node: $ctype;

axiom $is_span_sequential(^b_node);

axiom $def_struct_type(^b_node, 24, false, false);

axiom (forall #s1: $state, #s2: $state, #p: $ptr :: { $inv2(#s1, #s2, #p, ^b_node) } $inv2(#s1, #s2, #p, ^b_node) == $set_eq($owns(#s2, #p), $set_empty()));

axiom (forall #s1: $state, #s2: $state, #p: $ptr :: { $inv2_without_lemmas(#s1, #s2, #p, ^b_node) } $inv2_without_lemmas(#s1, #s2, #p, ^b_node) == $set_eq($owns(#s2, #p), $set_empty()));

axiom (forall p: $ptr, q: $ptr, s: $state :: { $in(q, $composite_extent(s, p, ^b_node)) } $in(q, $composite_extent(s, p, ^b_node)) == (q == p));

const unique b_node.left: $field;

axiom $def_phys_field(^b_node, b_node.left, $ptr_to(^b_node), false, 0);

const unique b_node.right: $field;

axiom $def_phys_field(^b_node, b_node.right, $ptr_to(^b_node), false, 8);

const unique b_node.key: $field;

axiom $def_phys_field(^b_node, b_node.key, ^^i4, false, 16);

const unique b_node.prio: $field;

axiom $def_phys_field(^b_node, b_node.prio, ^^i4, false, 20);

function F#glob_reach() : $oset;

const unique cf#glob_reach: $pure_function;

axiom $function_arg_type(cf#glob_reach, 0, ^$#oset);

procedure glob_reach() returns ($result: $oset);
  free ensures $result == F#glob_reach();
  free ensures $call_transition(old($s), $s);



const unique ^$#_purecall_handler#1: $ctype;

axiom $def_fnptr_type(^$#_purecall_handler#1);

type $#_purecall_handler#1;

const unique ^$#_invalid_parameter_handler#2: $ctype;

axiom $def_fnptr_type(^$#_invalid_parameter_handler#2);

type $#_invalid_parameter_handler#2;

const unique ^$#treap_delete_rec.c..36261#3: $ctype;

axiom $def_fnptr_type(^$#treap_delete_rec.c..36261#3);

type $#treap_delete_rec.c..36261#3;

const unique ^$#_PtFuncCompare#4: $ctype;

axiom $def_fnptr_type(^$#_PtFuncCompare#4);

type $#_PtFuncCompare#4;

const unique ^$#_PtFuncCompare#5: $ctype;

axiom $def_fnptr_type(^$#_PtFuncCompare#5);

type $#_PtFuncCompare#5;

const unique ^$#_PtFuncCompare#6: $ctype;

axiom $def_fnptr_type(^$#_PtFuncCompare#6);

type $#_PtFuncCompare#6;

const unique ^$#_PtFuncCompare#7: $ctype;

axiom $def_fnptr_type(^$#_PtFuncCompare#7);

type $#_PtFuncCompare#7;

const unique ^$#_onexit_t#8: $ctype;

axiom $def_fnptr_type(^$#_onexit_t#8);

type $#_onexit_t#8;

function F##int_max(SP#x: int, SP#y: int) : int;

const unique cf##int_max: $pure_function;

axiom (forall SP#x: int, SP#y: int :: { F##int_max(SP#x, SP#y) } $in_range_i4(F##int_max(SP#x, SP#y)));

axiom $function_arg_type(cf##int_max, 0, ^^i4);

axiom $function_arg_type(cf##int_max, 1, ^^i4);

axiom $function_arg_type(cf##int_max, 2, ^^i4);

procedure #int_max(SP#x: int, SP#y: int) returns ($result: int);
  free ensures $in_range_i4($result);
  free ensures $result == F##int_max(SP#x, SP#y);
  free ensures $call_transition(old($s), $s);



function F##int_min(SP#x: int, SP#y: int) : int;

const unique cf##int_min: $pure_function;

axiom (forall SP#x: int, SP#y: int :: { F##int_min(SP#x, SP#y) } $in_range_i4(F##int_min(SP#x, SP#y)));

axiom $function_arg_type(cf##int_min, 0, ^^i4);

axiom $function_arg_type(cf##int_min, 1, ^^i4);

axiom $function_arg_type(cf##int_min, 2, ^^i4);

procedure #int_min(SP#x: int, SP#y: int) returns ($result: int);
  free ensures $in_range_i4($result);
  free ensures $result == F##int_min(SP#x, SP#y);
  free ensures $call_transition(old($s), $s);



function F#treap(#s: $state, SP#root: $ptr) : bool;

const unique cf#treap: $pure_function;

axiom (forall #s: $state, SP#root: $ptr :: { F#treap(#s, SP#root) } 1 < $decreases_level ==> $is_null($phys_ptr_cast(SP#root, ^b_node)) ==> F#treap(#s, SP#root));

axiom $function_arg_type(cf#treap, 0, ^^bool);

axiom $function_arg_type(cf#treap, 1, $ptr_to(^b_node));

procedure treap(SP#root: $ptr) returns ($result: bool);
  ensures $is_null($phys_ptr_cast(SP#root, ^b_node)) ==> $result;
  free ensures $result == F#treap($s, SP#root);
  free ensures $call_transition(old($s), $s);



function F#treap_reach(#s: $state, SP#root: $ptr) : $oset;

const unique cf#treap_reach: $pure_function;

axiom (forall #s: $state, SP#root: $ptr :: { F#treap_reach(#s, SP#root) } 1 < $decreases_level ==> ($non_null($phys_ptr_cast(SP#root, ^b_node)) ==> $oset_in($phys_ptr_cast(SP#root, ^b_node), F#treap_reach(#s, SP#root))) && ($is_null($phys_ptr_cast(SP#root, ^b_node)) ==> F#treap_reach(#s, SP#root) == $oset_empty()));

axiom $function_arg_type(cf#treap_reach, 0, ^$#oset);

axiom $function_arg_type(cf#treap_reach, 1, $ptr_to(^b_node));

procedure treap_reach(SP#root: $ptr) returns ($result: $oset);
  ensures $non_null($phys_ptr_cast(SP#root, ^b_node)) ==> $oset_in($phys_ptr_cast(SP#root, ^b_node), $result);
  ensures $is_null($phys_ptr_cast(SP#root, ^b_node)) ==> $result == $oset_empty();
  free ensures $result == F#treap_reach($s, SP#root);
  free ensures $call_transition(old($s), $s);



function F#treap_keys(#s: $state, SP#root: $ptr) : $intset;

const unique cf#treap_keys: $pure_function;

axiom (forall #s: $state, SP#root: $ptr :: { F#treap_keys(#s, SP#root) } 1 < $decreases_level ==> ($non_null($phys_ptr_cast(SP#root, ^b_node)) ==> $intset_in($rd_inv(#s, b_node.key, $phys_ptr_cast(SP#root, ^b_node)), F#treap_keys(#s, SP#root))) && ($is_null($phys_ptr_cast(SP#root, ^b_node)) ==> F#treap_keys(#s, SP#root) == $intset_empty()));

axiom $function_arg_type(cf#treap_keys, 0, ^$#intset);

axiom $function_arg_type(cf#treap_keys, 1, $ptr_to(^b_node));

procedure treap_keys(SP#root: $ptr) returns ($result: $intset);
  ensures $non_null($phys_ptr_cast(SP#root, ^b_node)) ==> $intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(SP#root, ^b_node)), $result);
  ensures $is_null($phys_ptr_cast(SP#root, ^b_node)) ==> $result == $intset_empty();
  free ensures $result == F#treap_keys($s, SP#root);
  free ensures $call_transition(old($s), $s);



function F#treap_prios(#s: $state, SP#root: $ptr) : $intset;

const unique cf#treap_prios: $pure_function;

axiom (forall #s: $state, SP#root: $ptr :: { F#treap_prios(#s, SP#root) } 1 < $decreases_level ==> ($non_null($phys_ptr_cast(SP#root, ^b_node)) ==> $intset_in($rd_inv(#s, b_node.prio, $phys_ptr_cast(SP#root, ^b_node)), F#treap_prios(#s, SP#root))) && ($is_null($phys_ptr_cast(SP#root, ^b_node)) ==> F#treap_prios(#s, SP#root) == $intset_empty()));

axiom $function_arg_type(cf#treap_prios, 0, ^$#intset);

axiom $function_arg_type(cf#treap_prios, 1, $ptr_to(^b_node));

procedure treap_prios(SP#root: $ptr) returns ($result: $intset);
  ensures $non_null($phys_ptr_cast(SP#root, ^b_node)) ==> $intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(SP#root, ^b_node)), $result);
  ensures $is_null($phys_ptr_cast(SP#root, ^b_node)) ==> $result == $intset_empty();
  free ensures $result == F#treap_prios($s, SP#root);
  free ensures $call_transition(old($s), $s);



function F#treap_min_key(#s: $state, SP#root: $ptr) : int;

const unique cf#treap_min_key: $pure_function;

axiom (forall #s: $state, SP#root: $ptr :: { F#treap_min_key(#s, SP#root) } 1 < $decreases_level ==> $in_range_i4(F#treap_min_key(#s, SP#root)) && ($non_null($phys_ptr_cast(SP#root, ^b_node)) && $is_null($rd_phys_ptr(#s, b_node.left, $phys_ptr_cast(SP#root, ^b_node), ^b_node)) && $is_null($rd_phys_ptr(#s, b_node.right, $phys_ptr_cast(SP#root, ^b_node), ^b_node)) ==> F#treap_min_key(#s, SP#root) == $rd_inv(#s, b_node.key, $phys_ptr_cast(SP#root, ^b_node))));

axiom $function_arg_type(cf#treap_min_key, 0, ^^i4);

axiom $function_arg_type(cf#treap_min_key, 1, $ptr_to(^b_node));

procedure treap_min_key(SP#root: $ptr) returns ($result: int);
  free ensures $in_range_i4($result);
  ensures $non_null($phys_ptr_cast(SP#root, ^b_node)) && $is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SP#root, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SP#root, ^b_node), ^b_node)) ==> $result == $rd_inv($s, b_node.key, $phys_ptr_cast(SP#root, ^b_node));
  free ensures $result == F#treap_min_key($s, SP#root);
  free ensures $call_transition(old($s), $s);



function F#treap_max_key(#s: $state, SP#root: $ptr) : int;

const unique cf#treap_max_key: $pure_function;

axiom (forall #s: $state, SP#root: $ptr :: { F#treap_max_key(#s, SP#root) } 1 < $decreases_level ==> $in_range_i4(F#treap_max_key(#s, SP#root)) && ($non_null($phys_ptr_cast(SP#root, ^b_node)) && $is_null($rd_phys_ptr(#s, b_node.left, $phys_ptr_cast(SP#root, ^b_node), ^b_node)) && $is_null($rd_phys_ptr(#s, b_node.right, $phys_ptr_cast(SP#root, ^b_node), ^b_node)) ==> F#treap_max_key(#s, SP#root) == $rd_inv(#s, b_node.key, $phys_ptr_cast(SP#root, ^b_node))));

axiom $function_arg_type(cf#treap_max_key, 0, ^^i4);

axiom $function_arg_type(cf#treap_max_key, 1, $ptr_to(^b_node));

procedure treap_max_key(SP#root: $ptr) returns ($result: int);
  free ensures $in_range_i4($result);
  ensures $non_null($phys_ptr_cast(SP#root, ^b_node)) && $is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SP#root, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SP#root, ^b_node), ^b_node)) ==> $result == $rd_inv($s, b_node.key, $phys_ptr_cast(SP#root, ^b_node));
  free ensures $result == F#treap_max_key($s, SP#root);
  free ensures $call_transition(old($s), $s);



function F#treap_max_prio(#s: $state, SP#root: $ptr) : int;

const unique cf#treap_max_prio: $pure_function;

axiom (forall #s: $state, SP#root: $ptr :: { F#treap_max_prio(#s, SP#root) } 1 < $decreases_level ==> $in_range_i4(F#treap_max_prio(#s, SP#root)) && ($non_null($phys_ptr_cast(SP#root, ^b_node)) && $is_null($rd_phys_ptr(#s, b_node.left, $phys_ptr_cast(SP#root, ^b_node), ^b_node)) && $is_null($rd_phys_ptr(#s, b_node.right, $phys_ptr_cast(SP#root, ^b_node), ^b_node)) ==> F#treap_max_prio(#s, SP#root) == $rd_inv(#s, b_node.prio, $phys_ptr_cast(SP#root, ^b_node))));

axiom $function_arg_type(cf#treap_max_prio, 0, ^^i4);

axiom $function_arg_type(cf#treap_max_prio, 1, $ptr_to(^b_node));

procedure treap_max_prio(SP#root: $ptr) returns ($result: int);
  free ensures $in_range_i4($result);
  ensures $non_null($phys_ptr_cast(SP#root, ^b_node)) && $is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SP#root, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SP#root, ^b_node), ^b_node)) ==> $result == $rd_inv($s, b_node.prio, $phys_ptr_cast(SP#root, ^b_node));
  free ensures $result == F#treap_max_prio($s, SP#root);
  free ensures $call_transition(old($s), $s);



procedure treap_remove_root(P#x: $ptr) returns ($result: $ptr);
  requires F#treap($s, $phys_ptr_cast(P#x, ^b_node));
  requires $non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) <= F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node));
  modifies $s, $cev_pc;
  ensures F#treap($s, $phys_ptr_cast($result, ^b_node));
  ensures F#treap_keys($s, $phys_ptr_cast($result, ^b_node)) == $intset_union(F#treap_keys(old($s), $rd_phys_ptr(old($s), b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys(old($s), $rd_phys_ptr(old($s), b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)));
  ensures $intset_subset(F#treap_prios($s, $phys_ptr_cast($result, ^b_node)), F#treap_prios(old($s), $phys_ptr_cast(P#x, ^b_node)));
  ensures F#treap_min_key($s, $phys_ptr_cast($result, ^b_node)) >= F#treap_min_key(old($s), $phys_ptr_cast(P#x, ^b_node));
  ensures F#treap_max_key($s, $phys_ptr_cast($result, ^b_node)) <= F#treap_max_key(old($s), $phys_ptr_cast(P#x, ^b_node));
  ensures F#treap_max_prio($s, $phys_ptr_cast($result, ^b_node)) < F#treap_max_prio(old($s), $phys_ptr_cast(P#x, ^b_node));
  free ensures $writes_nothing(old($s), $s);
  free ensures $call_transition(old($s), $s);



procedure treap_delete_rec(P#x: $ptr, P#k: int) returns ($result: $ptr);
  requires F#treap($s, $phys_ptr_cast(P#x, ^b_node));
  requires $intset_in(P#k, F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)));
  modifies $s, $cev_pc;
  ensures F#treap($s, $phys_ptr_cast($result, ^b_node));
  ensures F#treap_keys($s, $phys_ptr_cast($result, ^b_node)) == $intset_diff(F#treap_keys(old($s), $phys_ptr_cast(P#x, ^b_node)), $intset_singleton(P#k));
  ensures $intset_subset(F#treap_prios($s, $phys_ptr_cast($result, ^b_node)), F#treap_prios(old($s), $phys_ptr_cast(P#x, ^b_node)));
ensures b0000 ==> (F#treap($s,$phys_ptr_cast(P#x,^b_node)));
ensures b0001 ==> (F#treap($s,$phys_ptr_cast($result,^b_node)));
ensures b0002 ==> ((F#treap_reach($s,$phys_ptr_cast(P#x,^b_node)) == F#treap_reach($s,$phys_ptr_cast($result,^b_node))));
ensures b0003 ==> ((F#treap_reach($s,$phys_ptr_cast($result,^b_node)) == F#treap_reach($s,$phys_ptr_cast(P#x,^b_node))));
ensures b0004 ==> ((F#treap_reach($s,$phys_ptr_cast(P#x,^b_node)) == F#treap_reach(old($s),$phys_ptr_cast(P#x,^b_node))));
ensures b0005 ==> ((F#treap_reach($s,$phys_ptr_cast($result,^b_node)) == F#treap_reach(old($s),$phys_ptr_cast($result,^b_node))));
ensures b0006 ==> ($non_null($phys_ptr_cast(P#x,^b_node)));
ensures b0007 ==> ($non_null($phys_ptr_cast($result,^b_node)));
ensures b0008 ==> ($is_null($phys_ptr_cast(P#x,^b_node)));
ensures b0009 ==> ($is_null($phys_ptr_cast($result,^b_node)));
ensures b0010 ==> (($phys_ptr_cast(P#x,^b_node) == $phys_ptr_cast($result,^b_node)));
ensures b0011 ==> (($phys_ptr_cast($result,^b_node) == $phys_ptr_cast(P#x,^b_node)));
ensures b0012 ==> (($non_null($phys_ptr_cast(P#x,^b_node)) ==> $non_null($rd_phys_ptr($s,b_node.left,$phys_ptr_cast(P#x,^b_node),^b_node))));
ensures b0013 ==> (($non_null($phys_ptr_cast($result,^b_node)) ==> $non_null($rd_phys_ptr($s,b_node.left,$phys_ptr_cast($result,^b_node),^b_node))));
ensures b0014 ==> (($non_null($phys_ptr_cast(P#x,^b_node)) ==> $is_null($rd_phys_ptr($s,b_node.left,$phys_ptr_cast(P#x,^b_node),^b_node))));
ensures b0015 ==> (($non_null($phys_ptr_cast($result,^b_node)) ==> $is_null($rd_phys_ptr($s,b_node.left,$phys_ptr_cast($result,^b_node),^b_node))));
ensures b0016 ==> (($non_null($phys_ptr_cast(P#x,^b_node)) ==> ($rd_phys_ptr($s,b_node.left,$phys_ptr_cast(P#x,^b_node),^b_node) == $phys_ptr_cast($result,^b_node))));
ensures b0017 ==> (($non_null($phys_ptr_cast($result,^b_node)) ==> ($rd_phys_ptr($s,b_node.left,$phys_ptr_cast($result,^b_node),^b_node) == $phys_ptr_cast(P#x,^b_node))));
ensures b0018 ==> (($non_null($phys_ptr_cast(P#x,^b_node)) ==> $non_null($rd_phys_ptr($s,b_node.right,$phys_ptr_cast(P#x,^b_node),^b_node))));
ensures b0019 ==> (($non_null($phys_ptr_cast($result,^b_node)) ==> $non_null($rd_phys_ptr($s,b_node.right,$phys_ptr_cast($result,^b_node),^b_node))));
ensures b0020 ==> (($non_null($phys_ptr_cast(P#x,^b_node)) ==> $is_null($rd_phys_ptr($s,b_node.right,$phys_ptr_cast(P#x,^b_node),^b_node))));
ensures b0021 ==> (($non_null($phys_ptr_cast($result,^b_node)) ==> $is_null($rd_phys_ptr($s,b_node.right,$phys_ptr_cast($result,^b_node),^b_node))));
ensures b0022 ==> (($non_null($phys_ptr_cast(P#x,^b_node)) ==> ($rd_phys_ptr($s,b_node.right,$phys_ptr_cast(P#x,^b_node),^b_node) == $phys_ptr_cast($result,^b_node))));
ensures b0023 ==> (($non_null($phys_ptr_cast($result,^b_node)) ==> ($rd_phys_ptr($s,b_node.right,$phys_ptr_cast($result,^b_node),^b_node) == $phys_ptr_cast(P#x,^b_node))));
ensures b0024 ==> ((F#treap_keys($s,$phys_ptr_cast(P#x,^b_node)) == F#treap_keys($s,$phys_ptr_cast($result,^b_node))));
ensures b0025 ==> ((F#treap_keys($s,$phys_ptr_cast($result,^b_node)) == F#treap_keys($s,$phys_ptr_cast(P#x,^b_node))));
ensures b0026 ==> ((F#treap_keys($s,$phys_ptr_cast(P#x,^b_node)) == F#treap_keys(old($s),$phys_ptr_cast(P#x,^b_node))));
ensures b0027 ==> ((F#treap_keys($s,$phys_ptr_cast($result,^b_node)) == F#treap_keys(old($s),$phys_ptr_cast($result,^b_node))));
ensures b0028 ==> ((F#treap_keys($s,$phys_ptr_cast(P#x,^b_node)) == $intset_union(F#treap_keys(old($s),$phys_ptr_cast(P#x,^b_node)),$intset_singleton(P#k))));
ensures b0029 ==> ((F#treap_keys($s,$phys_ptr_cast($result,^b_node)) == $intset_union(F#treap_keys(old($s),$phys_ptr_cast($result,^b_node)),$intset_singleton(P#k))));
ensures b0030 ==> ((F#treap_keys($s,$phys_ptr_cast(P#x,^b_node)) == $intset_union(F#treap_keys(old($s),$phys_ptr_cast($result,^b_node)),$intset_singleton(P#k))));
ensures b0031 ==> ((F#treap_keys($s,$phys_ptr_cast($result,^b_node)) == $intset_union(F#treap_keys(old($s),$phys_ptr_cast(P#x,^b_node)),$intset_singleton(P#k))));
ensures b0032 ==> ((F#treap_keys(old($s),$phys_ptr_cast(P#x,^b_node)) == $intset_union(F#treap_keys($s,$phys_ptr_cast(P#x,^b_node)),$intset_singleton(P#k))));
ensures b0033 ==> ((F#treap_keys(old($s),$phys_ptr_cast($result,^b_node)) == $intset_union(F#treap_keys($s,$phys_ptr_cast($result,^b_node)),$intset_singleton(P#k))));
ensures b0034 ==> ((F#treap_keys(old($s),$phys_ptr_cast(P#x,^b_node)) == $intset_union(F#treap_keys($s,$phys_ptr_cast($result,^b_node)),$intset_singleton(P#k))));
ensures b0035 ==> ((F#treap_keys(old($s),$phys_ptr_cast($result,^b_node)) == $intset_union(F#treap_keys($s,$phys_ptr_cast(P#x,^b_node)),$intset_singleton(P#k))));
ensures b0036 ==> ((P#k < 2147483647));
ensures b0037 ==> ((P#k < 2147483647));
ensures b0038 ==> ((P#k < 4294967295));
ensures b0039 ==> ((P#k < 4294967295));
ensures b0040 ==> ((P#k >= 0));
ensures b0041 ==> ((P#k >= 0));
ensures b0042 ==> (($rd_inv($s,b_node.key,$phys_ptr_cast(P#x,^b_node)) < P#k));
ensures b0043 ==> (($rd_inv($s,b_node.key,$phys_ptr_cast($result,^b_node)) < P#k));
ensures b0044 ==> (($rd_inv($s,b_node.key,$phys_ptr_cast(P#x,^b_node)) <= $rd_inv($s,b_node.key,$phys_ptr_cast($result,^b_node))));
ensures b0045 ==> (($rd_inv($s,b_node.key,$phys_ptr_cast($result,^b_node)) <= $rd_inv($s,b_node.key,$phys_ptr_cast(P#x,^b_node))));
ensures b0046 ==> (($rd_inv($s,b_node.key,$phys_ptr_cast(P#x,^b_node)) == $rd_inv($s,b_node.key,$phys_ptr_cast($result,^b_node))));
ensures b0047 ==> (($rd_inv($s,b_node.key,$phys_ptr_cast($result,^b_node)) == $rd_inv($s,b_node.key,$phys_ptr_cast(P#x,^b_node))));
ensures b0048 ==> (($non_null($phys_ptr_cast(P#x,^b_node)) ==> (F#treap_min_key($s,$phys_ptr_cast($result,^b_node)) == $int_min(F#treap_min_key(old($s),$phys_ptr_cast(P#x,^b_node)),P#k))));
ensures b0049 ==> (($non_null($phys_ptr_cast($result,^b_node)) ==> (F#treap_min_key($s,$phys_ptr_cast(P#x,^b_node)) == $int_min(F#treap_min_key(old($s),$phys_ptr_cast($result,^b_node)),P#k))));
ensures b0050 ==> (($non_null($phys_ptr_cast(P#x,^b_node)) ==> (F#treap_max_key($s,$phys_ptr_cast($result,^b_node)) == $int_max(F#treap_max_key(old($s),$phys_ptr_cast(P#x,^b_node)),P#k))));
ensures b0051 ==> (($non_null($phys_ptr_cast($result,^b_node)) ==> (F#treap_max_key($s,$phys_ptr_cast(P#x,^b_node)) == $int_max(F#treap_max_key(old($s),$phys_ptr_cast($result,^b_node)),P#k))));
ensures b0052 ==> (($is_null($phys_ptr_cast(P#x,^b_node)) ==> (F#treap_min_key($s,$phys_ptr_cast($result,^b_node)) == P#k)));
ensures b0053 ==> (($is_null($phys_ptr_cast($result,^b_node)) ==> (F#treap_min_key($s,$phys_ptr_cast(P#x,^b_node)) == P#k)));
ensures b0054 ==> (($is_null($phys_ptr_cast(P#x,^b_node)) ==> (F#treap_max_key($s,$phys_ptr_cast($result,^b_node)) == P#k)));
ensures b0055 ==> (($is_null($phys_ptr_cast($result,^b_node)) ==> (F#treap_max_key($s,$phys_ptr_cast(P#x,^b_node)) == P#k)));
ensures b0056 ==> ((F#treap_min_key($s,$phys_ptr_cast(P#x,^b_node)) == F#treap_min_key(old($s),$phys_ptr_cast(P#x,^b_node))));
ensures b0057 ==> ((F#treap_min_key($s,$phys_ptr_cast($result,^b_node)) == F#treap_min_key(old($s),$phys_ptr_cast($result,^b_node))));
ensures b0058 ==> ((F#treap_max_key($s,$phys_ptr_cast(P#x,^b_node)) == F#treap_max_key(old($s),$phys_ptr_cast(P#x,^b_node))));
ensures b0059 ==> ((F#treap_max_key($s,$phys_ptr_cast($result,^b_node)) == F#treap_max_key(old($s),$phys_ptr_cast($result,^b_node))));
ensures b0060 ==> ((($non_null($phys_ptr_cast(P#x,^b_node)) && $non_null($phys_ptr_cast($result,^b_node))) ==> (F#treap_min_key($s,$phys_ptr_cast($result,^b_node)) <= F#treap_min_key(old($s),$phys_ptr_cast(P#x,^b_node)))));
ensures b0061 ==> ((($non_null($phys_ptr_cast($result,^b_node)) && $non_null($phys_ptr_cast(P#x,^b_node))) ==> (F#treap_min_key($s,$phys_ptr_cast(P#x,^b_node)) <= F#treap_min_key(old($s),$phys_ptr_cast($result,^b_node)))));
ensures b0062 ==> ((($non_null($phys_ptr_cast(P#x,^b_node)) && $non_null($phys_ptr_cast($result,^b_node))) ==> (F#treap_max_key($s,$phys_ptr_cast($result,^b_node)) <= F#treap_max_key(old($s),$phys_ptr_cast(P#x,^b_node)))));
ensures b0063 ==> ((($non_null($phys_ptr_cast($result,^b_node)) && $non_null($phys_ptr_cast(P#x,^b_node))) ==> (F#treap_max_key($s,$phys_ptr_cast(P#x,^b_node)) <= F#treap_max_key(old($s),$phys_ptr_cast($result,^b_node)))));
ensures b0064 ==> ((($non_null($phys_ptr_cast(P#x,^b_node)) && $non_null($phys_ptr_cast($result,^b_node))) ==> (F#treap_min_key(old($s),$phys_ptr_cast($result,^b_node)) <= F#treap_min_key($s,$phys_ptr_cast(P#x,^b_node)))));
ensures b0065 ==> ((($non_null($phys_ptr_cast($result,^b_node)) && $non_null($phys_ptr_cast(P#x,^b_node))) ==> (F#treap_min_key(old($s),$phys_ptr_cast(P#x,^b_node)) <= F#treap_min_key($s,$phys_ptr_cast($result,^b_node)))));
ensures b0066 ==> ((($non_null($phys_ptr_cast(P#x,^b_node)) && $non_null($phys_ptr_cast($result,^b_node))) ==> (F#treap_max_key(old($s),$phys_ptr_cast($result,^b_node)) <= F#treap_max_key($s,$phys_ptr_cast(P#x,^b_node)))));
ensures b0067 ==> ((($non_null($phys_ptr_cast($result,^b_node)) && $non_null($phys_ptr_cast(P#x,^b_node))) ==> (F#treap_max_key(old($s),$phys_ptr_cast(P#x,^b_node)) <= F#treap_max_key($s,$phys_ptr_cast($result,^b_node)))));
ensures b0068 ==> ((F#treap_prios($s,$phys_ptr_cast(P#x,^b_node)) == F#treap_prios(old($s),$phys_ptr_cast(P#x,^b_node))));
ensures b0069 ==> ((F#treap_prios($s,$phys_ptr_cast($result,^b_node)) == F#treap_prios(old($s),$phys_ptr_cast($result,^b_node))));
ensures b0070 ==> ((F#treap_max_prio($s,$phys_ptr_cast(P#x,^b_node)) == F#treap_max_prio(old($s),$phys_ptr_cast(P#x,^b_node))));
ensures b0071 ==> ((F#treap_max_prio($s,$phys_ptr_cast($result,^b_node)) == F#treap_max_prio(old($s),$phys_ptr_cast($result,^b_node))));
ensures b0072 ==> (($non_null($phys_ptr_cast(P#x,^b_node)) ==> (F#treap_max_prio($s,$phys_ptr_cast($result,^b_node)) == $int_max(F#treap_max_prio(old($s),$phys_ptr_cast(P#x,^b_node)),P#k))));
ensures b0073 ==> (($non_null($phys_ptr_cast($result,^b_node)) ==> (F#treap_max_prio($s,$phys_ptr_cast(P#x,^b_node)) == $int_max(F#treap_max_prio(old($s),$phys_ptr_cast($result,^b_node)),P#k))));
ensures b0074 ==> (($is_null($phys_ptr_cast(P#x,^b_node)) ==> (F#treap_max_prio($s,$phys_ptr_cast($result,^b_node)) == P#k)));
ensures b0075 ==> (($is_null($phys_ptr_cast($result,^b_node)) ==> (F#treap_max_prio($s,$phys_ptr_cast(P#x,^b_node)) == P#k)));
ensures b0076 ==> ((($non_null($phys_ptr_cast(P#x,^b_node)) && $non_null($phys_ptr_cast($result,^b_node))) ==> (F#treap_max_prio($s,$phys_ptr_cast($result,^b_node)) <= F#treap_max_prio(old($s),$phys_ptr_cast(P#x,^b_node)))));
ensures b0077 ==> ((($non_null($phys_ptr_cast($result,^b_node)) && $non_null($phys_ptr_cast(P#x,^b_node))) ==> (F#treap_max_prio($s,$phys_ptr_cast(P#x,^b_node)) <= F#treap_max_prio(old($s),$phys_ptr_cast($result,^b_node)))));
ensures b0078 ==> ((($non_null($phys_ptr_cast(P#x,^b_node)) && $non_null($phys_ptr_cast($result,^b_node))) ==> (F#treap_max_prio(old($s),$phys_ptr_cast($result,^b_node)) <= F#treap_max_prio($s,$phys_ptr_cast(P#x,^b_node)))));
ensures b0079 ==> ((($non_null($phys_ptr_cast($result,^b_node)) && $non_null($phys_ptr_cast(P#x,^b_node))) ==> (F#treap_max_prio(old($s),$phys_ptr_cast(P#x,^b_node)) <= F#treap_max_prio($s,$phys_ptr_cast($result,^b_node)))));

  free ensures $writes_nothing(old($s), $s);
  free ensures $call_transition(old($s), $s);

// INV:PTR: P#x, $result
// INV:INT: P#k
// INV:LST: treap


implementation treap_delete_rec(P#x: $ptr, P#k: int) returns ($result: $ptr)
{
  var stmtexpr6#20: $state;
  var _dryad_S3#10: $state;
  var stmtexpr5#19: $state;
  var _dryad_S2#9: $state;
  var stmtexpr4#18: $oset;
  var res_treap_reach#3: $oset;
  var stmtexpr3#17: $state;
  var _dryad_S1#8: $state;
  var stmtexpr2#16: $state;
  var _dryad_S0#7: $state;
  var stmtexpr1#15: $ptr;
  var x1#6: $ptr;
  var stmtexpr0#14: $ptr;
  var x0#5: $ptr;
  var xl#4: $ptr;
  var xr#3: $ptr;
  var r#2: $ptr;
  var stmtexpr6#13: $state;
  var SL#_dryad_S3: $state;
  var stmtexpr5#12: $state;
  var SL#_dryad_S2: $state;
  var stmtexpr4#11: $oset;
  var res_treap_reach#2: $oset;
  var stmtexpr3#10: $state;
  var _dryad_S1#1: $state;
  var stmtexpr2#9: $state;
  var _dryad_S0#0: $state;
  var stmtexpr1#8: $ptr;
  var SL#x1: $ptr;
  var stmtexpr0#7: $ptr;
  var SL#x0: $ptr;
  var L#xl: $ptr;
  var L#xr: $ptr;
  var L#l: $ptr;
  var stmtexpr2#6: $oset;
  var res_treap_reach#1: $oset;
  var stmtexpr1#5: $state;
  var SL#_dryad_S1: $state;
  var stmtexpr0#4: $state;
  var SL#_dryad_S0: $state;
  var L#r: $ptr;
  var stmtexpr1#22: $oset;
  var stmtexpr0#21: $oset;
  var SL#_dryad_G1: $oset;
  var SL#_dryad_G0: $oset;
  var #wrTime$3^23.3: int;
  var #stackframe: int;

  anon5:
    assume $function_entry($s);
    assume $full_stop_ext(#tok$3^23.3, $s);
    assume $can_use_all_frame_axioms($s);
    assume #wrTime$3^23.3 == $current_timestamp($s);
    assume $def_writes($s, #wrTime$3^23.3, (lambda #p: $ptr :: false));
    // assume true
    // assume @in_range_i4(k); 
    assume $in_range_i4(P#k);
    // assume @decreases_level_is(2147483647); 
    assume 2147483647 == $decreases_level;
    //  --- Dryad annotated function --- 
    // _math \oset _dryad_G0; 
    // _math \oset _dryad_G1; 
    // _dryad_G0 := treap_reach(x); 
    call SL#_dryad_G0 := treap_reach($phys_ptr_cast(P#x, ^b_node));
    assume $full_stop_ext(#tok$4^0.0, $s);
    // _math \oset stmtexpr0#21; 
    // stmtexpr0#21 := _dryad_G0; 
    stmtexpr0#21 := SL#_dryad_G0;
    // _dryad_G1 := _dryad_G0; 
    SL#_dryad_G1 := SL#_dryad_G0;
    // _math \oset stmtexpr1#22; 
    // stmtexpr1#22 := _dryad_G1; 
    stmtexpr1#22 := SL#_dryad_G1;
    // assume ==>(@_vcc_ptr_neq_null(x), ==(treap(x), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x->left))), treap(*((x->right)))), unchecked!(@_vcc_oset_in(x, @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->key)), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->prio)), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))), @_vcc_oset_disjoint(treap_reach(*((x->left))), treap_reach(*((x->right))))), @_vcc_intset_disjoint(treap_keys(*((x->left))), treap_keys(*((x->right))))), @_vcc_intset_disjoint(treap_prios(*((x->left))), treap_prios(*((x->right))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_key(*((x->left))), *((x->key))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(*((x->key)), treap_min_key(*((x->right)))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_prio(*((x->left))), *((x->prio))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(treap_max_prio(*((x->right))), *((x->prio))))))); 
    assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap($s, $phys_ptr_cast(P#x, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(P#x, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))));
    // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_reach(x), @_vcc_oset_union(@_vcc_oset_singleton(x), @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))); 
    assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(P#x, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(P#x, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
    // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_keys(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->key))), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))); 
    assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
    // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), @\int_max(treap_max_key(*((x->left))), treap_max_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->right)))))))); 
    assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
    // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), @\int_max(treap_max_prio(*((x->left))), treap_max_prio(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->right)))))))); 
    assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
    // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), @\int_min(treap_min_key(*((x->left))), treap_min_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->right)))))))); 
    assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
    // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_prios(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->prio))), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))); 
    assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
    // assume ==>(@_vcc_ptr_neq_null(x), &&(@_vcc_mutable(@state, x), @writes_check(x))); 
    assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> $mutable($s, $phys_ptr_cast(P#x, ^b_node)) && $top_writable($s, #wrTime$3^23.3, $phys_ptr_cast(P#x, ^b_node));
    // assert @reads_check_normal((x->key)); 
    assert $thread_local($s, $phys_ptr_cast(P#x, ^b_node));
    assume true;
    // if (==(*((x->key)), k)) ...
    if ($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) == P#k)
    {
      anon1:
        // assume ==>(@_vcc_ptr_neq_null(x), ==(treap(x), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x->left))), treap(*((x->right)))), unchecked!(@_vcc_oset_in(x, @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->key)), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->prio)), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))), @_vcc_oset_disjoint(treap_reach(*((x->left))), treap_reach(*((x->right))))), @_vcc_intset_disjoint(treap_keys(*((x->left))), treap_keys(*((x->right))))), @_vcc_intset_disjoint(treap_prios(*((x->left))), treap_prios(*((x->right))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_key(*((x->left))), *((x->key))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(*((x->key)), treap_min_key(*((x->right)))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_prio(*((x->left))), *((x->prio))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(treap_max_prio(*((x->right))), *((x->prio))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap($s, $phys_ptr_cast(P#x, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(P#x, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_reach(x), @_vcc_oset_union(@_vcc_oset_singleton(x), @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(P#x, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(P#x, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_keys(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->key))), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), @\int_max(treap_max_key(*((x->left))), treap_max_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->right)))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), @\int_max(treap_max_prio(*((x->left))), treap_max_prio(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->right)))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), @\int_min(treap_min_key(*((x->left))), treap_min_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->right)))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_prios(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->prio))), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // struct b_node* r; 
        // _math \state _dryad_S0; 
        // _dryad_S0 := @_vcc_current_state(@state); 
        SL#_dryad_S0 := $current_state($s);
        // _math \state stmtexpr0#4; 
        // stmtexpr0#4 := _dryad_S0; 
        stmtexpr0#4 := SL#_dryad_S0;
        // non-pure function
        // r := treap_remove_root(x); 
        call L#r := treap_remove_root($phys_ptr_cast(P#x, ^b_node));
        assume $full_stop_ext(#tok$3^41.17, $s);
        // _math \state _dryad_S1; 
        // _dryad_S1 := @_vcc_current_state(@state); 
        SL#_dryad_S1 := $current_state($s);
        // _math \state stmtexpr1#5; 
        // stmtexpr1#5 := _dryad_S1; 
        stmtexpr1#5 := SL#_dryad_S1;
        // assume @_vcc_oset_disjoint(treap_reach(r), @_vcc_oset_diff(_dryad_G1, old(_dryad_S0, treap_reach(x)))); 
        assume $oset_disjoint(F#treap_reach($s, $phys_ptr_cast(L#r, ^b_node)), $oset_diff(SL#_dryad_G1, F#treap_reach(SL#_dryad_S0, $phys_ptr_cast(P#x, ^b_node))));
        // _math \oset res_treap_reach#1; 
        // res_treap_reach#1 := treap_reach(r); 
        call res_treap_reach#1 := treap_reach($phys_ptr_cast(L#r, ^b_node));
        assume $full_stop_ext(#tok$4^0.0, $s);
        // _dryad_G1 := @_vcc_oset_union(res_treap_reach#1, @_vcc_oset_diff(_dryad_G1, pure(old(_dryad_S0, treap_reach(x))))); 
        SL#_dryad_G1 := $oset_union(res_treap_reach#1, $oset_diff(SL#_dryad_G1, F#treap_reach(SL#_dryad_S0, $phys_ptr_cast(P#x, ^b_node))));
        // _math \oset stmtexpr2#6; 
        // stmtexpr2#6 := _dryad_G1; 
        stmtexpr2#6 := SL#_dryad_G1;
        // assume ==(glob_reach(), _dryad_G1); 
        assume F#glob_reach() == SL#_dryad_G1;
        // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0, treap_reach(x)), old(_dryad_S0, treap_reach(x))), ==(old(_dryad_S0, treap(x)), old(_dryad_S1, treap(x)))); 
        assume $oset_disjoint(F#treap_reach(SL#_dryad_S0, $phys_ptr_cast(P#x, ^b_node)), F#treap_reach(SL#_dryad_S0, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap(SL#_dryad_S0, $phys_ptr_cast(P#x, ^b_node)) == F#treap(SL#_dryad_S1, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0, treap_reach(x)), old(_dryad_S0, treap_reach(x))), ==(old(_dryad_S0, treap_reach(x)), old(_dryad_S1, treap_reach(x)))); 
        assume $oset_disjoint(F#treap_reach(SL#_dryad_S0, $phys_ptr_cast(P#x, ^b_node)), F#treap_reach(SL#_dryad_S0, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_reach(SL#_dryad_S0, $phys_ptr_cast(P#x, ^b_node)) == F#treap_reach(SL#_dryad_S1, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0, treap_reach(x)), old(_dryad_S0, treap_reach(x))), ==(old(_dryad_S0, treap_keys(x)), old(_dryad_S1, treap_keys(x)))); 
        assume $oset_disjoint(F#treap_reach(SL#_dryad_S0, $phys_ptr_cast(P#x, ^b_node)), F#treap_reach(SL#_dryad_S0, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_keys(SL#_dryad_S0, $phys_ptr_cast(P#x, ^b_node)) == F#treap_keys(SL#_dryad_S1, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0, treap_reach(x)), old(_dryad_S0, treap_reach(x))), ==(old(_dryad_S0, treap_max_key(x)), old(_dryad_S1, treap_max_key(x)))); 
        assume $oset_disjoint(F#treap_reach(SL#_dryad_S0, $phys_ptr_cast(P#x, ^b_node)), F#treap_reach(SL#_dryad_S0, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_max_key(SL#_dryad_S0, $phys_ptr_cast(P#x, ^b_node)) == F#treap_max_key(SL#_dryad_S1, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0, treap_reach(x)), old(_dryad_S0, treap_reach(x))), ==(old(_dryad_S0, treap_max_prio(x)), old(_dryad_S1, treap_max_prio(x)))); 
        assume $oset_disjoint(F#treap_reach(SL#_dryad_S0, $phys_ptr_cast(P#x, ^b_node)), F#treap_reach(SL#_dryad_S0, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_max_prio(SL#_dryad_S0, $phys_ptr_cast(P#x, ^b_node)) == F#treap_max_prio(SL#_dryad_S1, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0, treap_reach(x)), old(_dryad_S0, treap_reach(x))), ==(old(_dryad_S0, treap_min_key(x)), old(_dryad_S1, treap_min_key(x)))); 
        assume $oset_disjoint(F#treap_reach(SL#_dryad_S0, $phys_ptr_cast(P#x, ^b_node)), F#treap_reach(SL#_dryad_S0, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_min_key(SL#_dryad_S0, $phys_ptr_cast(P#x, ^b_node)) == F#treap_min_key(SL#_dryad_S1, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0, treap_reach(x)), old(_dryad_S0, treap_reach(x))), ==(old(_dryad_S0, treap_prios(x)), old(_dryad_S1, treap_prios(x)))); 
        assume $oset_disjoint(F#treap_reach(SL#_dryad_S0, $phys_ptr_cast(P#x, ^b_node)), F#treap_reach(SL#_dryad_S0, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_prios(SL#_dryad_S0, $phys_ptr_cast(P#x, ^b_node)) == F#treap_prios(SL#_dryad_S1, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(@_vcc_ptr_neq_null(r), ==(treap(r), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((r->left))), treap(*((r->right)))), unchecked!(@_vcc_oset_in(r, @_vcc_oset_union(treap_reach(*((r->left))), treap_reach(*((r->right))))))), unchecked!(@_vcc_intset_in(*((r->key)), @_vcc_intset_union(treap_keys(*((r->left))), treap_keys(*((r->right))))))), unchecked!(@_vcc_intset_in(*((r->prio)), @_vcc_intset_union(treap_prios(*((r->left))), treap_prios(*((r->right))))))), @_vcc_oset_disjoint(treap_reach(*((r->left))), treap_reach(*((r->right))))), @_vcc_intset_disjoint(treap_keys(*((r->left))), treap_keys(*((r->right))))), @_vcc_intset_disjoint(treap_prios(*((r->left))), treap_prios(*((r->right))))), ==>(@_vcc_ptr_neq_null(*((r->left))), <(treap_max_key(*((r->left))), *((r->key))))), ==>(@_vcc_ptr_neq_null(*((r->right))), <(*((r->key)), treap_min_key(*((r->right)))))), ==>(@_vcc_ptr_neq_null(*((r->left))), <(treap_max_prio(*((r->left))), *((r->prio))))), ==>(@_vcc_ptr_neq_null(*((r->right))), <(treap_max_prio(*((r->right))), *((r->prio))))))); 
        assume $non_null($phys_ptr_cast(L#r, ^b_node)) ==> F#treap($s, $phys_ptr_cast(L#r, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#r, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#r, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(L#r, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#r, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#r, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(L#r, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#r, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#r, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(L#r, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#r, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#r, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#r, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#r, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#r, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#r, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#r, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#r, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#r, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#r, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(L#r, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#r, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#r, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#r, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#r, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#r, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#r, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#r, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#r, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#r, ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(r), ==(treap_reach(r), @_vcc_oset_union(@_vcc_oset_singleton(r), @_vcc_oset_union(treap_reach(*((r->left))), treap_reach(*((r->right))))))); 
        assume $non_null($phys_ptr_cast(L#r, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(L#r, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(L#r, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#r, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#r, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(r), ==(treap_keys(r), @_vcc_intset_union(@_vcc_intset_singleton(*((r->key))), @_vcc_intset_union(treap_keys(*((r->left))), treap_keys(*((r->right))))))); 
        assume $non_null($phys_ptr_cast(L#r, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(L#r, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(L#r, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#r, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#r, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(r), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((r->left))), @_vcc_ptr_neq_null(*((r->right)))), ==(treap_max_key(r), @\int_max(*((r->key)), @\int_max(treap_max_key(*((r->left))), treap_max_key(*((r->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((r->left))), @_vcc_ptr_eq_null(*((r->right)))), ==(treap_max_key(r), @\int_max(*((r->key)), treap_max_key(*((r->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((r->left))), @_vcc_ptr_neq_null(*((r->right)))), ==(treap_max_key(r), @\int_max(*((r->key)), treap_max_key(*((r->right)))))))); 
        assume $non_null($phys_ptr_cast(L#r, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#r, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#r, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#r, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#r, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#r, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#r, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#r, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#r, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#r, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#r, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#r, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#r, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#r, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#r, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#r, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#r, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(r), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((r->left))), @_vcc_ptr_neq_null(*((r->right)))), ==(treap_max_prio(r), @\int_max(*((r->prio)), @\int_max(treap_max_prio(*((r->left))), treap_max_prio(*((r->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((r->left))), @_vcc_ptr_eq_null(*((r->right)))), ==(treap_max_prio(r), @\int_max(*((r->prio)), treap_max_prio(*((r->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((r->left))), @_vcc_ptr_neq_null(*((r->right)))), ==(treap_max_prio(r), @\int_max(*((r->prio)), treap_max_prio(*((r->right)))))))); 
        assume $non_null($phys_ptr_cast(L#r, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#r, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#r, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#r, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#r, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#r, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#r, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#r, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#r, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#r, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#r, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#r, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#r, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#r, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#r, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#r, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#r, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(r), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((r->left))), @_vcc_ptr_neq_null(*((r->right)))), ==(treap_min_key(r), @\int_min(*((r->key)), @\int_min(treap_min_key(*((r->left))), treap_min_key(*((r->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((r->left))), @_vcc_ptr_eq_null(*((r->right)))), ==(treap_min_key(r), @\int_min(*((r->key)), treap_min_key(*((r->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((r->left))), @_vcc_ptr_neq_null(*((r->right)))), ==(treap_min_key(r), @\int_min(*((r->key)), treap_min_key(*((r->right)))))))); 
        assume $non_null($phys_ptr_cast(L#r, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#r, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#r, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#r, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#r, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#r, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#r, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#r, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#r, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#r, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#r, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#r, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#r, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#r, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#r, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#r, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#r, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(r), ==(treap_prios(r), @_vcc_intset_union(@_vcc_intset_singleton(*((r->prio))), @_vcc_intset_union(treap_prios(*((r->left))), treap_prios(*((r->right))))))); 
        assume $non_null($phys_ptr_cast(L#r, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(L#r, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(L#r, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#r, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#r, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), ==(treap(x), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x->left))), treap(*((x->right)))), unchecked!(@_vcc_oset_in(x, @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->key)), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->prio)), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))), @_vcc_oset_disjoint(treap_reach(*((x->left))), treap_reach(*((x->right))))), @_vcc_intset_disjoint(treap_keys(*((x->left))), treap_keys(*((x->right))))), @_vcc_intset_disjoint(treap_prios(*((x->left))), treap_prios(*((x->right))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_key(*((x->left))), *((x->key))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(*((x->key)), treap_min_key(*((x->right)))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_prio(*((x->left))), *((x->prio))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(treap_max_prio(*((x->right))), *((x->prio))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap($s, $phys_ptr_cast(P#x, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(P#x, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_reach(x), @_vcc_oset_union(@_vcc_oset_singleton(x), @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(P#x, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(P#x, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_keys(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->key))), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), @\int_max(treap_max_key(*((x->left))), treap_max_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->right)))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), @\int_max(treap_max_prio(*((x->left))), treap_max_prio(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->right)))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), @\int_min(treap_min_key(*((x->left))), treap_min_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->right)))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_prios(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->prio))), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(!(@_vcc_oset_in(x, old(_dryad_S0, treap_reach(x)))), @_vcc_ptr_eq_pure(*((x->left)), old(_dryad_S0, *((x->left))))); 
        assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(SL#_dryad_S0, $phys_ptr_cast(P#x, ^b_node))) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node) == $rd_phys_ptr(SL#_dryad_S0, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node);
        // assume ==>(!(@_vcc_oset_in(x, old(_dryad_S0, treap_reach(x)))), @_vcc_ptr_eq_pure(*((x->right)), old(_dryad_S0, *((x->right))))); 
        assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(SL#_dryad_S0, $phys_ptr_cast(P#x, ^b_node))) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node) == $rd_phys_ptr(SL#_dryad_S0, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node);
        // assume ==>(!(@_vcc_oset_in(x, old(_dryad_S0, treap_reach(x)))), ==(*((x->key)), old(_dryad_S0, *((x->key))))); 
        assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(SL#_dryad_S0, $phys_ptr_cast(P#x, ^b_node))) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) == $rd_inv(SL#_dryad_S0, b_node.key, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(!(@_vcc_oset_in(x, old(_dryad_S0, treap_reach(x)))), ==(*((x->prio)), old(_dryad_S0, *((x->prio))))); 
        assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(SL#_dryad_S0, $phys_ptr_cast(P#x, ^b_node))) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)) == $rd_inv(SL#_dryad_S0, b_node.prio, $phys_ptr_cast(P#x, ^b_node));
        // return r; 
        $result := $phys_ptr_cast(L#r, ^b_node);
        assume true;
        assert $position_marker();
        goto #exit;
    }
    else
    {
      anon4:
        // assert @reads_check_normal((x->key)); 
        assert $thread_local($s, $phys_ptr_cast(P#x, ^b_node));
        assume true;
        // if (<(k, *((x->key)))) ...
        if (P#k < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)))
        {
          anon2:
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap(x), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x->left))), treap(*((x->right)))), unchecked!(@_vcc_oset_in(x, @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->key)), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->prio)), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))), @_vcc_oset_disjoint(treap_reach(*((x->left))), treap_reach(*((x->right))))), @_vcc_intset_disjoint(treap_keys(*((x->left))), treap_keys(*((x->right))))), @_vcc_intset_disjoint(treap_prios(*((x->left))), treap_prios(*((x->right))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_key(*((x->left))), *((x->key))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(*((x->key)), treap_min_key(*((x->right)))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_prio(*((x->left))), *((x->prio))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(treap_max_prio(*((x->right))), *((x->prio))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap($s, $phys_ptr_cast(P#x, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(P#x, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_reach(x), @_vcc_oset_union(@_vcc_oset_singleton(x), @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(P#x, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(P#x, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_keys(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->key))), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), @\int_max(treap_max_key(*((x->left))), treap_max_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), @\int_max(treap_max_prio(*((x->left))), treap_max_prio(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), @\int_min(treap_min_key(*((x->left))), treap_min_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_prios(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->prio))), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // struct b_node* l; 
            // struct b_node* xr; 
            // struct b_node* xl; 
            // struct b_node* x0; 
            // x0 := x; 
            SL#x0 := $phys_ptr_cast(P#x, ^b_node);
            // struct b_node* stmtexpr0#7; 
            // stmtexpr0#7 := x0; 
            stmtexpr0#7 := $phys_ptr_cast(SL#x0, ^b_node);
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap(x), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x->left))), treap(*((x->right)))), unchecked!(@_vcc_oset_in(x, @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->key)), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->prio)), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))), @_vcc_oset_disjoint(treap_reach(*((x->left))), treap_reach(*((x->right))))), @_vcc_intset_disjoint(treap_keys(*((x->left))), treap_keys(*((x->right))))), @_vcc_intset_disjoint(treap_prios(*((x->left))), treap_prios(*((x->right))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_key(*((x->left))), *((x->key))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(*((x->key)), treap_min_key(*((x->right)))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_prio(*((x->left))), *((x->prio))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(treap_max_prio(*((x->right))), *((x->prio))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap($s, $phys_ptr_cast(P#x, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(P#x, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_reach(x), @_vcc_oset_union(@_vcc_oset_singleton(x), @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(P#x, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(P#x, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_keys(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->key))), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), @\int_max(treap_max_key(*((x->left))), treap_max_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), @\int_max(treap_max_prio(*((x->left))), treap_max_prio(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), @\int_min(treap_min_key(*((x->left))), treap_min_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_prios(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->prio))), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assert @reads_check_normal((x->left)); 
            assert $thread_local($s, $phys_ptr_cast(P#x, ^b_node));
            // xl := *((x->left)); 
            L#xl := $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node);
            // assume ==>(@_vcc_ptr_neq_null(xl), ==(treap(xl), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((xl->left))), treap(*((xl->right)))), unchecked!(@_vcc_oset_in(xl, @_vcc_oset_union(treap_reach(*((xl->left))), treap_reach(*((xl->right))))))), unchecked!(@_vcc_intset_in(*((xl->key)), @_vcc_intset_union(treap_keys(*((xl->left))), treap_keys(*((xl->right))))))), unchecked!(@_vcc_intset_in(*((xl->prio)), @_vcc_intset_union(treap_prios(*((xl->left))), treap_prios(*((xl->right))))))), @_vcc_oset_disjoint(treap_reach(*((xl->left))), treap_reach(*((xl->right))))), @_vcc_intset_disjoint(treap_keys(*((xl->left))), treap_keys(*((xl->right))))), @_vcc_intset_disjoint(treap_prios(*((xl->left))), treap_prios(*((xl->right))))), ==>(@_vcc_ptr_neq_null(*((xl->left))), <(treap_max_key(*((xl->left))), *((xl->key))))), ==>(@_vcc_ptr_neq_null(*((xl->right))), <(*((xl->key)), treap_min_key(*((xl->right)))))), ==>(@_vcc_ptr_neq_null(*((xl->left))), <(treap_max_prio(*((xl->left))), *((xl->prio))))), ==>(@_vcc_ptr_neq_null(*((xl->right))), <(treap_max_prio(*((xl->right))), *((xl->prio))))))); 
            assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> F#treap($s, $phys_ptr_cast(L#xl, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(L#xl, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl), ==(treap_reach(xl), @_vcc_oset_union(@_vcc_oset_singleton(xl), @_vcc_oset_union(treap_reach(*((xl->left))), treap_reach(*((xl->right))))))); 
            assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(L#xl, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(L#xl, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl), ==(treap_keys(xl), @_vcc_intset_union(@_vcc_intset_singleton(*((xl->key))), @_vcc_intset_union(treap_keys(*((xl->left))), treap_keys(*((xl->right))))))); 
            assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(L#xl, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_max_key(xl), @\int_max(*((xl->key)), @\int_max(treap_max_key(*((xl->left))), treap_max_key(*((xl->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_eq_null(*((xl->right)))), ==(treap_max_key(xl), @\int_max(*((xl->key)), treap_max_key(*((xl->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_max_key(xl), @\int_max(*((xl->key)), treap_max_key(*((xl->right)))))))); 
            assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_max_prio(xl), @\int_max(*((xl->prio)), @\int_max(treap_max_prio(*((xl->left))), treap_max_prio(*((xl->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_eq_null(*((xl->right)))), ==(treap_max_prio(xl), @\int_max(*((xl->prio)), treap_max_prio(*((xl->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_max_prio(xl), @\int_max(*((xl->prio)), treap_max_prio(*((xl->right)))))))); 
            assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_min_key(xl), @\int_min(*((xl->key)), @\int_min(treap_min_key(*((xl->left))), treap_min_key(*((xl->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_eq_null(*((xl->right)))), ==(treap_min_key(xl), @\int_min(*((xl->key)), treap_min_key(*((xl->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_min_key(xl), @\int_min(*((xl->key)), treap_min_key(*((xl->right)))))))); 
            assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl), ==(treap_prios(xl), @_vcc_intset_union(@_vcc_intset_singleton(*((xl->prio))), @_vcc_intset_union(treap_prios(*((xl->left))), treap_prios(*((xl->right))))))); 
            assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(L#xl, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap(x), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x->left))), treap(*((x->right)))), unchecked!(@_vcc_oset_in(x, @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->key)), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->prio)), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))), @_vcc_oset_disjoint(treap_reach(*((x->left))), treap_reach(*((x->right))))), @_vcc_intset_disjoint(treap_keys(*((x->left))), treap_keys(*((x->right))))), @_vcc_intset_disjoint(treap_prios(*((x->left))), treap_prios(*((x->right))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_key(*((x->left))), *((x->key))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(*((x->key)), treap_min_key(*((x->right)))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_prio(*((x->left))), *((x->prio))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(treap_max_prio(*((x->right))), *((x->prio))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap($s, $phys_ptr_cast(P#x, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(P#x, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_reach(x), @_vcc_oset_union(@_vcc_oset_singleton(x), @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(P#x, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(P#x, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_keys(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->key))), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), @\int_max(treap_max_key(*((x->left))), treap_max_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), @\int_max(treap_max_prio(*((x->left))), treap_max_prio(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), @\int_min(treap_min_key(*((x->left))), treap_min_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_prios(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->prio))), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // struct b_node* x1; 
            // x1 := x; 
            SL#x1 := $phys_ptr_cast(P#x, ^b_node);
            // struct b_node* stmtexpr1#8; 
            // stmtexpr1#8 := x1; 
            stmtexpr1#8 := $phys_ptr_cast(SL#x1, ^b_node);
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap(x), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x->left))), treap(*((x->right)))), unchecked!(@_vcc_oset_in(x, @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->key)), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->prio)), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))), @_vcc_oset_disjoint(treap_reach(*((x->left))), treap_reach(*((x->right))))), @_vcc_intset_disjoint(treap_keys(*((x->left))), treap_keys(*((x->right))))), @_vcc_intset_disjoint(treap_prios(*((x->left))), treap_prios(*((x->right))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_key(*((x->left))), *((x->key))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(*((x->key)), treap_min_key(*((x->right)))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_prio(*((x->left))), *((x->prio))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(treap_max_prio(*((x->right))), *((x->prio))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap($s, $phys_ptr_cast(P#x, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(P#x, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_reach(x), @_vcc_oset_union(@_vcc_oset_singleton(x), @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(P#x, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(P#x, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_keys(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->key))), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), @\int_max(treap_max_key(*((x->left))), treap_max_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), @\int_max(treap_max_prio(*((x->left))), treap_max_prio(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), @\int_min(treap_min_key(*((x->left))), treap_min_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_prios(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->prio))), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assert @reads_check_normal((x->right)); 
            assert $thread_local($s, $phys_ptr_cast(P#x, ^b_node));
            // xr := *((x->right)); 
            L#xr := $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node);
            // assume ==>(@_vcc_ptr_neq_null(xr), ==(treap(xr), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((xr->left))), treap(*((xr->right)))), unchecked!(@_vcc_oset_in(xr, @_vcc_oset_union(treap_reach(*((xr->left))), treap_reach(*((xr->right))))))), unchecked!(@_vcc_intset_in(*((xr->key)), @_vcc_intset_union(treap_keys(*((xr->left))), treap_keys(*((xr->right))))))), unchecked!(@_vcc_intset_in(*((xr->prio)), @_vcc_intset_union(treap_prios(*((xr->left))), treap_prios(*((xr->right))))))), @_vcc_oset_disjoint(treap_reach(*((xr->left))), treap_reach(*((xr->right))))), @_vcc_intset_disjoint(treap_keys(*((xr->left))), treap_keys(*((xr->right))))), @_vcc_intset_disjoint(treap_prios(*((xr->left))), treap_prios(*((xr->right))))), ==>(@_vcc_ptr_neq_null(*((xr->left))), <(treap_max_key(*((xr->left))), *((xr->key))))), ==>(@_vcc_ptr_neq_null(*((xr->right))), <(*((xr->key)), treap_min_key(*((xr->right)))))), ==>(@_vcc_ptr_neq_null(*((xr->left))), <(treap_max_prio(*((xr->left))), *((xr->prio))))), ==>(@_vcc_ptr_neq_null(*((xr->right))), <(treap_max_prio(*((xr->right))), *((xr->prio))))))); 
            assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> F#treap($s, $phys_ptr_cast(L#xr, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(L#xr, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr), ==(treap_reach(xr), @_vcc_oset_union(@_vcc_oset_singleton(xr), @_vcc_oset_union(treap_reach(*((xr->left))), treap_reach(*((xr->right))))))); 
            assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(L#xr, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(L#xr, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr), ==(treap_keys(xr), @_vcc_intset_union(@_vcc_intset_singleton(*((xr->key))), @_vcc_intset_union(treap_keys(*((xr->left))), treap_keys(*((xr->right))))))); 
            assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(L#xr, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_max_key(xr), @\int_max(*((xr->key)), @\int_max(treap_max_key(*((xr->left))), treap_max_key(*((xr->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_eq_null(*((xr->right)))), ==(treap_max_key(xr), @\int_max(*((xr->key)), treap_max_key(*((xr->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_max_key(xr), @\int_max(*((xr->key)), treap_max_key(*((xr->right)))))))); 
            assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_max_prio(xr), @\int_max(*((xr->prio)), @\int_max(treap_max_prio(*((xr->left))), treap_max_prio(*((xr->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_eq_null(*((xr->right)))), ==(treap_max_prio(xr), @\int_max(*((xr->prio)), treap_max_prio(*((xr->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_max_prio(xr), @\int_max(*((xr->prio)), treap_max_prio(*((xr->right)))))))); 
            assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_min_key(xr), @\int_min(*((xr->key)), @\int_min(treap_min_key(*((xr->left))), treap_min_key(*((xr->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_eq_null(*((xr->right)))), ==(treap_min_key(xr), @\int_min(*((xr->key)), treap_min_key(*((xr->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_min_key(xr), @\int_min(*((xr->key)), treap_min_key(*((xr->right)))))))); 
            assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr), ==(treap_prios(xr), @_vcc_intset_union(@_vcc_intset_singleton(*((xr->prio))), @_vcc_intset_union(treap_prios(*((xr->left))), treap_prios(*((xr->right))))))); 
            assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(L#xr, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap(x), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x->left))), treap(*((x->right)))), unchecked!(@_vcc_oset_in(x, @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->key)), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->prio)), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))), @_vcc_oset_disjoint(treap_reach(*((x->left))), treap_reach(*((x->right))))), @_vcc_intset_disjoint(treap_keys(*((x->left))), treap_keys(*((x->right))))), @_vcc_intset_disjoint(treap_prios(*((x->left))), treap_prios(*((x->right))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_key(*((x->left))), *((x->key))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(*((x->key)), treap_min_key(*((x->right)))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_prio(*((x->left))), *((x->prio))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(treap_max_prio(*((x->right))), *((x->prio))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap($s, $phys_ptr_cast(P#x, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(P#x, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_reach(x), @_vcc_oset_union(@_vcc_oset_singleton(x), @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(P#x, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(P#x, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_keys(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->key))), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), @\int_max(treap_max_key(*((x->left))), treap_max_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), @\int_max(treap_max_prio(*((x->left))), treap_max_prio(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), @\int_min(treap_min_key(*((x->left))), treap_min_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_prios(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->prio))), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // _math \state _dryad_S0#0; 
            // _dryad_S0#0 := @_vcc_current_state(@state); 
            _dryad_S0#0 := $current_state($s);
            // _math \state stmtexpr2#9; 
            // stmtexpr2#9 := _dryad_S0#0; 
            stmtexpr2#9 := _dryad_S0#0;
            // non-pure function
            // l := treap_delete_rec(xl, k); 
            call L#l := treap_delete_rec($phys_ptr_cast(L#xl, ^b_node), P#k);
            assume $full_stop_ext(#tok$3^47.17, $s);
            // _math \state _dryad_S1#1; 
            // _dryad_S1#1 := @_vcc_current_state(@state); 
            _dryad_S1#1 := $current_state($s);
            // _math \state stmtexpr3#10; 
            // stmtexpr3#10 := _dryad_S1#1; 
            stmtexpr3#10 := _dryad_S1#1;
            // assume @_vcc_oset_disjoint(treap_reach(l), @_vcc_oset_diff(_dryad_G1, old(_dryad_S0#0, treap_reach(xl)))); 
            assume $oset_disjoint(F#treap_reach($s, $phys_ptr_cast(L#l, ^b_node)), $oset_diff(SL#_dryad_G1, F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))));
            // _math \oset res_treap_reach#2; 
            // res_treap_reach#2 := treap_reach(l); 
            call res_treap_reach#2 := treap_reach($phys_ptr_cast(L#l, ^b_node));
            assume $full_stop_ext(#tok$4^0.0, $s);
            // _dryad_G1 := @_vcc_oset_union(res_treap_reach#2, @_vcc_oset_diff(_dryad_G1, pure(old(_dryad_S0#0, treap_reach(xl))))); 
            SL#_dryad_G1 := $oset_union(res_treap_reach#2, $oset_diff(SL#_dryad_G1, F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))));
            // _math \oset stmtexpr4#11; 
            // stmtexpr4#11 := _dryad_G1; 
            stmtexpr4#11 := SL#_dryad_G1;
            // assume ==(glob_reach(), _dryad_G1); 
            assume F#glob_reach() == SL#_dryad_G1;
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(x1))), ==(old(_dryad_S0#0, treap(x1)), old(_dryad_S1#1, treap(x1)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(SL#x1, ^b_node))) ==> F#treap(_dryad_S0#0, $phys_ptr_cast(SL#x1, ^b_node)) == F#treap(_dryad_S1#1, $phys_ptr_cast(SL#x1, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(x1))), ==(old(_dryad_S0#0, treap_reach(x1)), old(_dryad_S1#1, treap_reach(x1)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(SL#x1, ^b_node))) ==> F#treap_reach(_dryad_S0#0, $phys_ptr_cast(SL#x1, ^b_node)) == F#treap_reach(_dryad_S1#1, $phys_ptr_cast(SL#x1, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(x1))), ==(old(_dryad_S0#0, treap_keys(x1)), old(_dryad_S1#1, treap_keys(x1)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(SL#x1, ^b_node))) ==> F#treap_keys(_dryad_S0#0, $phys_ptr_cast(SL#x1, ^b_node)) == F#treap_keys(_dryad_S1#1, $phys_ptr_cast(SL#x1, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(x1))), ==(old(_dryad_S0#0, treap_max_key(x1)), old(_dryad_S1#1, treap_max_key(x1)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(SL#x1, ^b_node))) ==> F#treap_max_key(_dryad_S0#0, $phys_ptr_cast(SL#x1, ^b_node)) == F#treap_max_key(_dryad_S1#1, $phys_ptr_cast(SL#x1, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(x1))), ==(old(_dryad_S0#0, treap_max_prio(x1)), old(_dryad_S1#1, treap_max_prio(x1)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(SL#x1, ^b_node))) ==> F#treap_max_prio(_dryad_S0#0, $phys_ptr_cast(SL#x1, ^b_node)) == F#treap_max_prio(_dryad_S1#1, $phys_ptr_cast(SL#x1, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(x1))), ==(old(_dryad_S0#0, treap_min_key(x1)), old(_dryad_S1#1, treap_min_key(x1)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(SL#x1, ^b_node))) ==> F#treap_min_key(_dryad_S0#0, $phys_ptr_cast(SL#x1, ^b_node)) == F#treap_min_key(_dryad_S1#1, $phys_ptr_cast(SL#x1, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(x1))), ==(old(_dryad_S0#0, treap_prios(x1)), old(_dryad_S1#1, treap_prios(x1)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(SL#x1, ^b_node))) ==> F#treap_prios(_dryad_S0#0, $phys_ptr_cast(SL#x1, ^b_node)) == F#treap_prios(_dryad_S1#1, $phys_ptr_cast(SL#x1, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(x0))), ==(old(_dryad_S0#0, treap(x0)), old(_dryad_S1#1, treap(x0)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(SL#x0, ^b_node))) ==> F#treap(_dryad_S0#0, $phys_ptr_cast(SL#x0, ^b_node)) == F#treap(_dryad_S1#1, $phys_ptr_cast(SL#x0, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(x0))), ==(old(_dryad_S0#0, treap_reach(x0)), old(_dryad_S1#1, treap_reach(x0)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(SL#x0, ^b_node))) ==> F#treap_reach(_dryad_S0#0, $phys_ptr_cast(SL#x0, ^b_node)) == F#treap_reach(_dryad_S1#1, $phys_ptr_cast(SL#x0, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(x0))), ==(old(_dryad_S0#0, treap_keys(x0)), old(_dryad_S1#1, treap_keys(x0)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(SL#x0, ^b_node))) ==> F#treap_keys(_dryad_S0#0, $phys_ptr_cast(SL#x0, ^b_node)) == F#treap_keys(_dryad_S1#1, $phys_ptr_cast(SL#x0, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(x0))), ==(old(_dryad_S0#0, treap_max_key(x0)), old(_dryad_S1#1, treap_max_key(x0)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(SL#x0, ^b_node))) ==> F#treap_max_key(_dryad_S0#0, $phys_ptr_cast(SL#x0, ^b_node)) == F#treap_max_key(_dryad_S1#1, $phys_ptr_cast(SL#x0, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(x0))), ==(old(_dryad_S0#0, treap_max_prio(x0)), old(_dryad_S1#1, treap_max_prio(x0)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(SL#x0, ^b_node))) ==> F#treap_max_prio(_dryad_S0#0, $phys_ptr_cast(SL#x0, ^b_node)) == F#treap_max_prio(_dryad_S1#1, $phys_ptr_cast(SL#x0, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(x0))), ==(old(_dryad_S0#0, treap_min_key(x0)), old(_dryad_S1#1, treap_min_key(x0)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(SL#x0, ^b_node))) ==> F#treap_min_key(_dryad_S0#0, $phys_ptr_cast(SL#x0, ^b_node)) == F#treap_min_key(_dryad_S1#1, $phys_ptr_cast(SL#x0, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(x0))), ==(old(_dryad_S0#0, treap_prios(x0)), old(_dryad_S1#1, treap_prios(x0)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(SL#x0, ^b_node))) ==> F#treap_prios(_dryad_S0#0, $phys_ptr_cast(SL#x0, ^b_node)) == F#treap_prios(_dryad_S1#1, $phys_ptr_cast(SL#x0, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(xl))), ==(old(_dryad_S0#0, treap(xl)), old(_dryad_S1#1, treap(xl)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> F#treap(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)) == F#treap(_dryad_S1#1, $phys_ptr_cast(L#xl, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(xl))), ==(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S1#1, treap_reach(xl)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)) == F#treap_reach(_dryad_S1#1, $phys_ptr_cast(L#xl, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(xl))), ==(old(_dryad_S0#0, treap_keys(xl)), old(_dryad_S1#1, treap_keys(xl)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> F#treap_keys(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)) == F#treap_keys(_dryad_S1#1, $phys_ptr_cast(L#xl, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(xl))), ==(old(_dryad_S0#0, treap_max_key(xl)), old(_dryad_S1#1, treap_max_key(xl)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> F#treap_max_key(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)) == F#treap_max_key(_dryad_S1#1, $phys_ptr_cast(L#xl, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(xl))), ==(old(_dryad_S0#0, treap_max_prio(xl)), old(_dryad_S1#1, treap_max_prio(xl)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> F#treap_max_prio(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)) == F#treap_max_prio(_dryad_S1#1, $phys_ptr_cast(L#xl, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(xl))), ==(old(_dryad_S0#0, treap_min_key(xl)), old(_dryad_S1#1, treap_min_key(xl)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> F#treap_min_key(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)) == F#treap_min_key(_dryad_S1#1, $phys_ptr_cast(L#xl, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(xl))), ==(old(_dryad_S0#0, treap_prios(xl)), old(_dryad_S1#1, treap_prios(xl)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> F#treap_prios(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)) == F#treap_prios(_dryad_S1#1, $phys_ptr_cast(L#xl, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(xr))), ==(old(_dryad_S0#0, treap(xr)), old(_dryad_S1#1, treap(xr)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xr, ^b_node))) ==> F#treap(_dryad_S0#0, $phys_ptr_cast(L#xr, ^b_node)) == F#treap(_dryad_S1#1, $phys_ptr_cast(L#xr, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(xr))), ==(old(_dryad_S0#0, treap_reach(xr)), old(_dryad_S1#1, treap_reach(xr)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xr, ^b_node))) ==> F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xr, ^b_node)) == F#treap_reach(_dryad_S1#1, $phys_ptr_cast(L#xr, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(xr))), ==(old(_dryad_S0#0, treap_keys(xr)), old(_dryad_S1#1, treap_keys(xr)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xr, ^b_node))) ==> F#treap_keys(_dryad_S0#0, $phys_ptr_cast(L#xr, ^b_node)) == F#treap_keys(_dryad_S1#1, $phys_ptr_cast(L#xr, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(xr))), ==(old(_dryad_S0#0, treap_max_key(xr)), old(_dryad_S1#1, treap_max_key(xr)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xr, ^b_node))) ==> F#treap_max_key(_dryad_S0#0, $phys_ptr_cast(L#xr, ^b_node)) == F#treap_max_key(_dryad_S1#1, $phys_ptr_cast(L#xr, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(xr))), ==(old(_dryad_S0#0, treap_max_prio(xr)), old(_dryad_S1#1, treap_max_prio(xr)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xr, ^b_node))) ==> F#treap_max_prio(_dryad_S0#0, $phys_ptr_cast(L#xr, ^b_node)) == F#treap_max_prio(_dryad_S1#1, $phys_ptr_cast(L#xr, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(xr))), ==(old(_dryad_S0#0, treap_min_key(xr)), old(_dryad_S1#1, treap_min_key(xr)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xr, ^b_node))) ==> F#treap_min_key(_dryad_S0#0, $phys_ptr_cast(L#xr, ^b_node)) == F#treap_min_key(_dryad_S1#1, $phys_ptr_cast(L#xr, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(xr))), ==(old(_dryad_S0#0, treap_prios(xr)), old(_dryad_S1#1, treap_prios(xr)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xr, ^b_node))) ==> F#treap_prios(_dryad_S0#0, $phys_ptr_cast(L#xr, ^b_node)) == F#treap_prios(_dryad_S1#1, $phys_ptr_cast(L#xr, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(x))), ==(old(_dryad_S0#0, treap(x)), old(_dryad_S1#1, treap(x)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap(_dryad_S0#0, $phys_ptr_cast(P#x, ^b_node)) == F#treap(_dryad_S1#1, $phys_ptr_cast(P#x, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(x))), ==(old(_dryad_S0#0, treap_reach(x)), old(_dryad_S1#1, treap_reach(x)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_reach(_dryad_S0#0, $phys_ptr_cast(P#x, ^b_node)) == F#treap_reach(_dryad_S1#1, $phys_ptr_cast(P#x, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(x))), ==(old(_dryad_S0#0, treap_keys(x)), old(_dryad_S1#1, treap_keys(x)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_keys(_dryad_S0#0, $phys_ptr_cast(P#x, ^b_node)) == F#treap_keys(_dryad_S1#1, $phys_ptr_cast(P#x, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(x))), ==(old(_dryad_S0#0, treap_max_key(x)), old(_dryad_S1#1, treap_max_key(x)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_max_key(_dryad_S0#0, $phys_ptr_cast(P#x, ^b_node)) == F#treap_max_key(_dryad_S1#1, $phys_ptr_cast(P#x, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(x))), ==(old(_dryad_S0#0, treap_max_prio(x)), old(_dryad_S1#1, treap_max_prio(x)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_max_prio(_dryad_S0#0, $phys_ptr_cast(P#x, ^b_node)) == F#treap_max_prio(_dryad_S1#1, $phys_ptr_cast(P#x, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(x))), ==(old(_dryad_S0#0, treap_min_key(x)), old(_dryad_S1#1, treap_min_key(x)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_min_key(_dryad_S0#0, $phys_ptr_cast(P#x, ^b_node)) == F#treap_min_key(_dryad_S1#1, $phys_ptr_cast(P#x, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(x))), ==(old(_dryad_S0#0, treap_prios(x)), old(_dryad_S1#1, treap_prios(x)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_prios(_dryad_S0#0, $phys_ptr_cast(P#x, ^b_node)) == F#treap_prios(_dryad_S1#1, $phys_ptr_cast(P#x, ^b_node));
            // assume ==>(@_vcc_ptr_neq_null(x1), ==(treap(x1), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x1->left))), treap(*((x1->right)))), unchecked!(@_vcc_oset_in(x1, @_vcc_oset_union(treap_reach(*((x1->left))), treap_reach(*((x1->right))))))), unchecked!(@_vcc_intset_in(*((x1->key)), @_vcc_intset_union(treap_keys(*((x1->left))), treap_keys(*((x1->right))))))), unchecked!(@_vcc_intset_in(*((x1->prio)), @_vcc_intset_union(treap_prios(*((x1->left))), treap_prios(*((x1->right))))))), @_vcc_oset_disjoint(treap_reach(*((x1->left))), treap_reach(*((x1->right))))), @_vcc_intset_disjoint(treap_keys(*((x1->left))), treap_keys(*((x1->right))))), @_vcc_intset_disjoint(treap_prios(*((x1->left))), treap_prios(*((x1->right))))), ==>(@_vcc_ptr_neq_null(*((x1->left))), <(treap_max_key(*((x1->left))), *((x1->key))))), ==>(@_vcc_ptr_neq_null(*((x1->right))), <(*((x1->key)), treap_min_key(*((x1->right)))))), ==>(@_vcc_ptr_neq_null(*((x1->left))), <(treap_max_prio(*((x1->left))), *((x1->prio))))), ==>(@_vcc_ptr_neq_null(*((x1->right))), <(treap_max_prio(*((x1->right))), *((x1->prio))))))); 
            assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> F#treap($s, $phys_ptr_cast(SL#x1, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(SL#x1, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x1), ==(treap_reach(x1), @_vcc_oset_union(@_vcc_oset_singleton(x1), @_vcc_oset_union(treap_reach(*((x1->left))), treap_reach(*((x1->right))))))); 
            assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(SL#x1, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(SL#x1, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x1), ==(treap_keys(x1), @_vcc_intset_union(@_vcc_intset_singleton(*((x1->key))), @_vcc_intset_union(treap_keys(*((x1->left))), treap_keys(*((x1->right))))))); 
            assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(SL#x1, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x1), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x1->left))), @_vcc_ptr_neq_null(*((x1->right)))), ==(treap_max_key(x1), @\int_max(*((x1->key)), @\int_max(treap_max_key(*((x1->left))), treap_max_key(*((x1->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x1->left))), @_vcc_ptr_eq_null(*((x1->right)))), ==(treap_max_key(x1), @\int_max(*((x1->key)), treap_max_key(*((x1->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x1->left))), @_vcc_ptr_neq_null(*((x1->right)))), ==(treap_max_key(x1), @\int_max(*((x1->key)), treap_max_key(*((x1->right)))))))); 
            assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x1), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x1->left))), @_vcc_ptr_neq_null(*((x1->right)))), ==(treap_max_prio(x1), @\int_max(*((x1->prio)), @\int_max(treap_max_prio(*((x1->left))), treap_max_prio(*((x1->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x1->left))), @_vcc_ptr_eq_null(*((x1->right)))), ==(treap_max_prio(x1), @\int_max(*((x1->prio)), treap_max_prio(*((x1->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x1->left))), @_vcc_ptr_neq_null(*((x1->right)))), ==(treap_max_prio(x1), @\int_max(*((x1->prio)), treap_max_prio(*((x1->right)))))))); 
            assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x1), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x1->left))), @_vcc_ptr_neq_null(*((x1->right)))), ==(treap_min_key(x1), @\int_min(*((x1->key)), @\int_min(treap_min_key(*((x1->left))), treap_min_key(*((x1->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x1->left))), @_vcc_ptr_eq_null(*((x1->right)))), ==(treap_min_key(x1), @\int_min(*((x1->key)), treap_min_key(*((x1->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x1->left))), @_vcc_ptr_neq_null(*((x1->right)))), ==(treap_min_key(x1), @\int_min(*((x1->key)), treap_min_key(*((x1->right)))))))); 
            assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x1), ==(treap_prios(x1), @_vcc_intset_union(@_vcc_intset_singleton(*((x1->prio))), @_vcc_intset_union(treap_prios(*((x1->left))), treap_prios(*((x1->right))))))); 
            assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(SL#x1, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x0), ==(treap(x0), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x0->left))), treap(*((x0->right)))), unchecked!(@_vcc_oset_in(x0, @_vcc_oset_union(treap_reach(*((x0->left))), treap_reach(*((x0->right))))))), unchecked!(@_vcc_intset_in(*((x0->key)), @_vcc_intset_union(treap_keys(*((x0->left))), treap_keys(*((x0->right))))))), unchecked!(@_vcc_intset_in(*((x0->prio)), @_vcc_intset_union(treap_prios(*((x0->left))), treap_prios(*((x0->right))))))), @_vcc_oset_disjoint(treap_reach(*((x0->left))), treap_reach(*((x0->right))))), @_vcc_intset_disjoint(treap_keys(*((x0->left))), treap_keys(*((x0->right))))), @_vcc_intset_disjoint(treap_prios(*((x0->left))), treap_prios(*((x0->right))))), ==>(@_vcc_ptr_neq_null(*((x0->left))), <(treap_max_key(*((x0->left))), *((x0->key))))), ==>(@_vcc_ptr_neq_null(*((x0->right))), <(*((x0->key)), treap_min_key(*((x0->right)))))), ==>(@_vcc_ptr_neq_null(*((x0->left))), <(treap_max_prio(*((x0->left))), *((x0->prio))))), ==>(@_vcc_ptr_neq_null(*((x0->right))), <(treap_max_prio(*((x0->right))), *((x0->prio))))))); 
            assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> F#treap($s, $phys_ptr_cast(SL#x0, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(SL#x0, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x0), ==(treap_reach(x0), @_vcc_oset_union(@_vcc_oset_singleton(x0), @_vcc_oset_union(treap_reach(*((x0->left))), treap_reach(*((x0->right))))))); 
            assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(SL#x0, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(SL#x0, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x0), ==(treap_keys(x0), @_vcc_intset_union(@_vcc_intset_singleton(*((x0->key))), @_vcc_intset_union(treap_keys(*((x0->left))), treap_keys(*((x0->right))))))); 
            assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(SL#x0, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x0), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x0->left))), @_vcc_ptr_neq_null(*((x0->right)))), ==(treap_max_key(x0), @\int_max(*((x0->key)), @\int_max(treap_max_key(*((x0->left))), treap_max_key(*((x0->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x0->left))), @_vcc_ptr_eq_null(*((x0->right)))), ==(treap_max_key(x0), @\int_max(*((x0->key)), treap_max_key(*((x0->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x0->left))), @_vcc_ptr_neq_null(*((x0->right)))), ==(treap_max_key(x0), @\int_max(*((x0->key)), treap_max_key(*((x0->right)))))))); 
            assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x0), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x0->left))), @_vcc_ptr_neq_null(*((x0->right)))), ==(treap_max_prio(x0), @\int_max(*((x0->prio)), @\int_max(treap_max_prio(*((x0->left))), treap_max_prio(*((x0->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x0->left))), @_vcc_ptr_eq_null(*((x0->right)))), ==(treap_max_prio(x0), @\int_max(*((x0->prio)), treap_max_prio(*((x0->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x0->left))), @_vcc_ptr_neq_null(*((x0->right)))), ==(treap_max_prio(x0), @\int_max(*((x0->prio)), treap_max_prio(*((x0->right)))))))); 
            assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x0), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x0->left))), @_vcc_ptr_neq_null(*((x0->right)))), ==(treap_min_key(x0), @\int_min(*((x0->key)), @\int_min(treap_min_key(*((x0->left))), treap_min_key(*((x0->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x0->left))), @_vcc_ptr_eq_null(*((x0->right)))), ==(treap_min_key(x0), @\int_min(*((x0->key)), treap_min_key(*((x0->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x0->left))), @_vcc_ptr_neq_null(*((x0->right)))), ==(treap_min_key(x0), @\int_min(*((x0->key)), treap_min_key(*((x0->right)))))))); 
            assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x0), ==(treap_prios(x0), @_vcc_intset_union(@_vcc_intset_singleton(*((x0->prio))), @_vcc_intset_union(treap_prios(*((x0->left))), treap_prios(*((x0->right))))))); 
            assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(SL#x0, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl), ==(treap(xl), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((xl->left))), treap(*((xl->right)))), unchecked!(@_vcc_oset_in(xl, @_vcc_oset_union(treap_reach(*((xl->left))), treap_reach(*((xl->right))))))), unchecked!(@_vcc_intset_in(*((xl->key)), @_vcc_intset_union(treap_keys(*((xl->left))), treap_keys(*((xl->right))))))), unchecked!(@_vcc_intset_in(*((xl->prio)), @_vcc_intset_union(treap_prios(*((xl->left))), treap_prios(*((xl->right))))))), @_vcc_oset_disjoint(treap_reach(*((xl->left))), treap_reach(*((xl->right))))), @_vcc_intset_disjoint(treap_keys(*((xl->left))), treap_keys(*((xl->right))))), @_vcc_intset_disjoint(treap_prios(*((xl->left))), treap_prios(*((xl->right))))), ==>(@_vcc_ptr_neq_null(*((xl->left))), <(treap_max_key(*((xl->left))), *((xl->key))))), ==>(@_vcc_ptr_neq_null(*((xl->right))), <(*((xl->key)), treap_min_key(*((xl->right)))))), ==>(@_vcc_ptr_neq_null(*((xl->left))), <(treap_max_prio(*((xl->left))), *((xl->prio))))), ==>(@_vcc_ptr_neq_null(*((xl->right))), <(treap_max_prio(*((xl->right))), *((xl->prio))))))); 
            assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> F#treap($s, $phys_ptr_cast(L#xl, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(L#xl, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl), ==(treap_reach(xl), @_vcc_oset_union(@_vcc_oset_singleton(xl), @_vcc_oset_union(treap_reach(*((xl->left))), treap_reach(*((xl->right))))))); 
            assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(L#xl, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(L#xl, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl), ==(treap_keys(xl), @_vcc_intset_union(@_vcc_intset_singleton(*((xl->key))), @_vcc_intset_union(treap_keys(*((xl->left))), treap_keys(*((xl->right))))))); 
            assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(L#xl, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_max_key(xl), @\int_max(*((xl->key)), @\int_max(treap_max_key(*((xl->left))), treap_max_key(*((xl->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_eq_null(*((xl->right)))), ==(treap_max_key(xl), @\int_max(*((xl->key)), treap_max_key(*((xl->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_max_key(xl), @\int_max(*((xl->key)), treap_max_key(*((xl->right)))))))); 
            assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_max_prio(xl), @\int_max(*((xl->prio)), @\int_max(treap_max_prio(*((xl->left))), treap_max_prio(*((xl->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_eq_null(*((xl->right)))), ==(treap_max_prio(xl), @\int_max(*((xl->prio)), treap_max_prio(*((xl->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_max_prio(xl), @\int_max(*((xl->prio)), treap_max_prio(*((xl->right)))))))); 
            assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_min_key(xl), @\int_min(*((xl->key)), @\int_min(treap_min_key(*((xl->left))), treap_min_key(*((xl->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_eq_null(*((xl->right)))), ==(treap_min_key(xl), @\int_min(*((xl->key)), treap_min_key(*((xl->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_min_key(xl), @\int_min(*((xl->key)), treap_min_key(*((xl->right)))))))); 
            assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl), ==(treap_prios(xl), @_vcc_intset_union(@_vcc_intset_singleton(*((xl->prio))), @_vcc_intset_union(treap_prios(*((xl->left))), treap_prios(*((xl->right))))))); 
            assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(L#xl, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr), ==(treap(xr), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((xr->left))), treap(*((xr->right)))), unchecked!(@_vcc_oset_in(xr, @_vcc_oset_union(treap_reach(*((xr->left))), treap_reach(*((xr->right))))))), unchecked!(@_vcc_intset_in(*((xr->key)), @_vcc_intset_union(treap_keys(*((xr->left))), treap_keys(*((xr->right))))))), unchecked!(@_vcc_intset_in(*((xr->prio)), @_vcc_intset_union(treap_prios(*((xr->left))), treap_prios(*((xr->right))))))), @_vcc_oset_disjoint(treap_reach(*((xr->left))), treap_reach(*((xr->right))))), @_vcc_intset_disjoint(treap_keys(*((xr->left))), treap_keys(*((xr->right))))), @_vcc_intset_disjoint(treap_prios(*((xr->left))), treap_prios(*((xr->right))))), ==>(@_vcc_ptr_neq_null(*((xr->left))), <(treap_max_key(*((xr->left))), *((xr->key))))), ==>(@_vcc_ptr_neq_null(*((xr->right))), <(*((xr->key)), treap_min_key(*((xr->right)))))), ==>(@_vcc_ptr_neq_null(*((xr->left))), <(treap_max_prio(*((xr->left))), *((xr->prio))))), ==>(@_vcc_ptr_neq_null(*((xr->right))), <(treap_max_prio(*((xr->right))), *((xr->prio))))))); 
            assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> F#treap($s, $phys_ptr_cast(L#xr, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(L#xr, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr), ==(treap_reach(xr), @_vcc_oset_union(@_vcc_oset_singleton(xr), @_vcc_oset_union(treap_reach(*((xr->left))), treap_reach(*((xr->right))))))); 
            assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(L#xr, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(L#xr, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr), ==(treap_keys(xr), @_vcc_intset_union(@_vcc_intset_singleton(*((xr->key))), @_vcc_intset_union(treap_keys(*((xr->left))), treap_keys(*((xr->right))))))); 
            assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(L#xr, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_max_key(xr), @\int_max(*((xr->key)), @\int_max(treap_max_key(*((xr->left))), treap_max_key(*((xr->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_eq_null(*((xr->right)))), ==(treap_max_key(xr), @\int_max(*((xr->key)), treap_max_key(*((xr->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_max_key(xr), @\int_max(*((xr->key)), treap_max_key(*((xr->right)))))))); 
            assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_max_prio(xr), @\int_max(*((xr->prio)), @\int_max(treap_max_prio(*((xr->left))), treap_max_prio(*((xr->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_eq_null(*((xr->right)))), ==(treap_max_prio(xr), @\int_max(*((xr->prio)), treap_max_prio(*((xr->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_max_prio(xr), @\int_max(*((xr->prio)), treap_max_prio(*((xr->right)))))))); 
            assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_min_key(xr), @\int_min(*((xr->key)), @\int_min(treap_min_key(*((xr->left))), treap_min_key(*((xr->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_eq_null(*((xr->right)))), ==(treap_min_key(xr), @\int_min(*((xr->key)), treap_min_key(*((xr->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_min_key(xr), @\int_min(*((xr->key)), treap_min_key(*((xr->right)))))))); 
            assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr), ==(treap_prios(xr), @_vcc_intset_union(@_vcc_intset_singleton(*((xr->prio))), @_vcc_intset_union(treap_prios(*((xr->left))), treap_prios(*((xr->right))))))); 
            assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(L#xr, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(l), ==(treap(l), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((l->left))), treap(*((l->right)))), unchecked!(@_vcc_oset_in(l, @_vcc_oset_union(treap_reach(*((l->left))), treap_reach(*((l->right))))))), unchecked!(@_vcc_intset_in(*((l->key)), @_vcc_intset_union(treap_keys(*((l->left))), treap_keys(*((l->right))))))), unchecked!(@_vcc_intset_in(*((l->prio)), @_vcc_intset_union(treap_prios(*((l->left))), treap_prios(*((l->right))))))), @_vcc_oset_disjoint(treap_reach(*((l->left))), treap_reach(*((l->right))))), @_vcc_intset_disjoint(treap_keys(*((l->left))), treap_keys(*((l->right))))), @_vcc_intset_disjoint(treap_prios(*((l->left))), treap_prios(*((l->right))))), ==>(@_vcc_ptr_neq_null(*((l->left))), <(treap_max_key(*((l->left))), *((l->key))))), ==>(@_vcc_ptr_neq_null(*((l->right))), <(*((l->key)), treap_min_key(*((l->right)))))), ==>(@_vcc_ptr_neq_null(*((l->left))), <(treap_max_prio(*((l->left))), *((l->prio))))), ==>(@_vcc_ptr_neq_null(*((l->right))), <(treap_max_prio(*((l->right))), *((l->prio))))))); 
            assume $non_null($phys_ptr_cast(L#l, ^b_node)) ==> F#treap($s, $phys_ptr_cast(L#l, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(L#l, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(L#l, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(L#l, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(L#l, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#l, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#l, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#l, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(l), ==(treap_reach(l), @_vcc_oset_union(@_vcc_oset_singleton(l), @_vcc_oset_union(treap_reach(*((l->left))), treap_reach(*((l->right))))))); 
            assume $non_null($phys_ptr_cast(L#l, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(L#l, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(L#l, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(l), ==(treap_keys(l), @_vcc_intset_union(@_vcc_intset_singleton(*((l->key))), @_vcc_intset_union(treap_keys(*((l->left))), treap_keys(*((l->right))))))); 
            assume $non_null($phys_ptr_cast(L#l, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(L#l, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(L#l, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(l), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((l->left))), @_vcc_ptr_neq_null(*((l->right)))), ==(treap_max_key(l), @\int_max(*((l->key)), @\int_max(treap_max_key(*((l->left))), treap_max_key(*((l->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((l->left))), @_vcc_ptr_eq_null(*((l->right)))), ==(treap_max_key(l), @\int_max(*((l->key)), treap_max_key(*((l->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((l->left))), @_vcc_ptr_neq_null(*((l->right)))), ==(treap_max_key(l), @\int_max(*((l->key)), treap_max_key(*((l->right)))))))); 
            assume $non_null($phys_ptr_cast(L#l, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#l, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#l, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#l, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#l, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#l, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#l, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(l), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((l->left))), @_vcc_ptr_neq_null(*((l->right)))), ==(treap_max_prio(l), @\int_max(*((l->prio)), @\int_max(treap_max_prio(*((l->left))), treap_max_prio(*((l->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((l->left))), @_vcc_ptr_eq_null(*((l->right)))), ==(treap_max_prio(l), @\int_max(*((l->prio)), treap_max_prio(*((l->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((l->left))), @_vcc_ptr_neq_null(*((l->right)))), ==(treap_max_prio(l), @\int_max(*((l->prio)), treap_max_prio(*((l->right)))))))); 
            assume $non_null($phys_ptr_cast(L#l, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#l, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#l, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#l, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#l, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#l, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#l, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(l), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((l->left))), @_vcc_ptr_neq_null(*((l->right)))), ==(treap_min_key(l), @\int_min(*((l->key)), @\int_min(treap_min_key(*((l->left))), treap_min_key(*((l->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((l->left))), @_vcc_ptr_eq_null(*((l->right)))), ==(treap_min_key(l), @\int_min(*((l->key)), treap_min_key(*((l->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((l->left))), @_vcc_ptr_neq_null(*((l->right)))), ==(treap_min_key(l), @\int_min(*((l->key)), treap_min_key(*((l->right)))))))); 
            assume $non_null($phys_ptr_cast(L#l, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#l, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#l, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#l, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#l, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#l, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#l, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(l), ==(treap_prios(l), @_vcc_intset_union(@_vcc_intset_singleton(*((l->prio))), @_vcc_intset_union(treap_prios(*((l->left))), treap_prios(*((l->right))))))); 
            assume $non_null($phys_ptr_cast(L#l, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(L#l, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(L#l, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap(x), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x->left))), treap(*((x->right)))), unchecked!(@_vcc_oset_in(x, @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->key)), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->prio)), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))), @_vcc_oset_disjoint(treap_reach(*((x->left))), treap_reach(*((x->right))))), @_vcc_intset_disjoint(treap_keys(*((x->left))), treap_keys(*((x->right))))), @_vcc_intset_disjoint(treap_prios(*((x->left))), treap_prios(*((x->right))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_key(*((x->left))), *((x->key))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(*((x->key)), treap_min_key(*((x->right)))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_prio(*((x->left))), *((x->prio))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(treap_max_prio(*((x->right))), *((x->prio))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap($s, $phys_ptr_cast(P#x, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(P#x, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_reach(x), @_vcc_oset_union(@_vcc_oset_singleton(x), @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(P#x, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(P#x, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_keys(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->key))), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), @\int_max(treap_max_key(*((x->left))), treap_max_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), @\int_max(treap_max_prio(*((x->left))), treap_max_prio(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), @\int_min(treap_min_key(*((x->left))), treap_min_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_prios(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->prio))), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(!(@_vcc_oset_in(x1, old(_dryad_S0#0, treap_reach(xl)))), @_vcc_ptr_eq_pure(*((x1->left)), old(_dryad_S0#0, *((x1->left))))); 
            assume !$oset_in($phys_ptr_cast(SL#x1, ^b_node), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S0#0, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_oset_in(x1, old(_dryad_S0#0, treap_reach(xl)))), @_vcc_ptr_eq_pure(*((x1->right)), old(_dryad_S0#0, *((x1->right))))); 
            assume !$oset_in($phys_ptr_cast(SL#x1, ^b_node), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S0#0, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_oset_in(x1, old(_dryad_S0#0, treap_reach(xl)))), ==(*((x1->key)), old(_dryad_S0#0, *((x1->key))))); 
            assume !$oset_in($phys_ptr_cast(SL#x1, ^b_node), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)) == $rd_inv(_dryad_S0#0, b_node.key, $phys_ptr_cast(SL#x1, ^b_node));
            // assume ==>(!(@_vcc_oset_in(x1, old(_dryad_S0#0, treap_reach(xl)))), ==(*((x1->prio)), old(_dryad_S0#0, *((x1->prio))))); 
            assume !$oset_in($phys_ptr_cast(SL#x1, ^b_node), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node)) == $rd_inv(_dryad_S0#0, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node));
            // assume ==>(!(@_vcc_oset_in(x0, old(_dryad_S0#0, treap_reach(xl)))), @_vcc_ptr_eq_pure(*((x0->left)), old(_dryad_S0#0, *((x0->left))))); 
            assume !$oset_in($phys_ptr_cast(SL#x0, ^b_node), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S0#0, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_oset_in(x0, old(_dryad_S0#0, treap_reach(xl)))), @_vcc_ptr_eq_pure(*((x0->right)), old(_dryad_S0#0, *((x0->right))))); 
            assume !$oset_in($phys_ptr_cast(SL#x0, ^b_node), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S0#0, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_oset_in(x0, old(_dryad_S0#0, treap_reach(xl)))), ==(*((x0->key)), old(_dryad_S0#0, *((x0->key))))); 
            assume !$oset_in($phys_ptr_cast(SL#x0, ^b_node), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)) == $rd_inv(_dryad_S0#0, b_node.key, $phys_ptr_cast(SL#x0, ^b_node));
            // assume ==>(!(@_vcc_oset_in(x0, old(_dryad_S0#0, treap_reach(xl)))), ==(*((x0->prio)), old(_dryad_S0#0, *((x0->prio))))); 
            assume !$oset_in($phys_ptr_cast(SL#x0, ^b_node), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node)) == $rd_inv(_dryad_S0#0, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node));
            // assume ==>(!(@_vcc_oset_in(xl, old(_dryad_S0#0, treap_reach(xl)))), @_vcc_ptr_eq_pure(*((xl->left)), old(_dryad_S0#0, *((xl->left))))); 
            assume !$oset_in($phys_ptr_cast(L#xl, ^b_node), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S0#0, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_oset_in(xl, old(_dryad_S0#0, treap_reach(xl)))), @_vcc_ptr_eq_pure(*((xl->right)), old(_dryad_S0#0, *((xl->right))))); 
            assume !$oset_in($phys_ptr_cast(L#xl, ^b_node), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S0#0, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_oset_in(xl, old(_dryad_S0#0, treap_reach(xl)))), ==(*((xl->key)), old(_dryad_S0#0, *((xl->key))))); 
            assume !$oset_in($phys_ptr_cast(L#xl, ^b_node), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)) == $rd_inv(_dryad_S0#0, b_node.key, $phys_ptr_cast(L#xl, ^b_node));
            // assume ==>(!(@_vcc_oset_in(xl, old(_dryad_S0#0, treap_reach(xl)))), ==(*((xl->prio)), old(_dryad_S0#0, *((xl->prio))))); 
            assume !$oset_in($phys_ptr_cast(L#xl, ^b_node), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node)) == $rd_inv(_dryad_S0#0, b_node.prio, $phys_ptr_cast(L#xl, ^b_node));
            // assume ==>(!(@_vcc_oset_in(xr, old(_dryad_S0#0, treap_reach(xl)))), @_vcc_ptr_eq_pure(*((xr->left)), old(_dryad_S0#0, *((xr->left))))); 
            assume !$oset_in($phys_ptr_cast(L#xr, ^b_node), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S0#0, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_oset_in(xr, old(_dryad_S0#0, treap_reach(xl)))), @_vcc_ptr_eq_pure(*((xr->right)), old(_dryad_S0#0, *((xr->right))))); 
            assume !$oset_in($phys_ptr_cast(L#xr, ^b_node), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S0#0, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_oset_in(xr, old(_dryad_S0#0, treap_reach(xl)))), ==(*((xr->key)), old(_dryad_S0#0, *((xr->key))))); 
            assume !$oset_in($phys_ptr_cast(L#xr, ^b_node), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)) == $rd_inv(_dryad_S0#0, b_node.key, $phys_ptr_cast(L#xr, ^b_node));
            // assume ==>(!(@_vcc_oset_in(xr, old(_dryad_S0#0, treap_reach(xl)))), ==(*((xr->prio)), old(_dryad_S0#0, *((xr->prio))))); 
            assume !$oset_in($phys_ptr_cast(L#xr, ^b_node), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node)) == $rd_inv(_dryad_S0#0, b_node.prio, $phys_ptr_cast(L#xr, ^b_node));
            // assume ==>(!(@_vcc_oset_in(x, old(_dryad_S0#0, treap_reach(xl)))), @_vcc_ptr_eq_pure(*((x->left)), old(_dryad_S0#0, *((x->left))))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S0#0, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_oset_in(x, old(_dryad_S0#0, treap_reach(xl)))), @_vcc_ptr_eq_pure(*((x->right)), old(_dryad_S0#0, *((x->right))))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S0#0, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_oset_in(x, old(_dryad_S0#0, treap_reach(xl)))), ==(*((x->key)), old(_dryad_S0#0, *((x->key))))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) == $rd_inv(_dryad_S0#0, b_node.key, $phys_ptr_cast(P#x, ^b_node));
            // assume ==>(!(@_vcc_oset_in(x, old(_dryad_S0#0, treap_reach(xl)))), ==(*((x->prio)), old(_dryad_S0#0, *((x->prio))))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)) == $rd_inv(_dryad_S0#0, b_node.prio, $phys_ptr_cast(P#x, ^b_node));
            // _math \state _dryad_S2; 
            // _dryad_S2 := @_vcc_current_state(@state); 
            SL#_dryad_S2 := $current_state($s);
            // _math \state stmtexpr5#12; 
            // stmtexpr5#12 := _dryad_S2; 
            stmtexpr5#12 := SL#_dryad_S2;
            // assert @prim_writes_check((x->left)); 
            assert $writable_prim($s, #wrTime$3^23.3, $dot($phys_ptr_cast(P#x, ^b_node), b_node.left));
            // *(x->left) := l; 
            call $write_int(b_node.left, $phys_ptr_cast(P#x, ^b_node), $ptr_to_int($phys_ptr_cast(L#l, ^b_node)));
            assume $full_stop_ext(#tok$3^49.5, $s);
            // _math \state _dryad_S3; 
            // _dryad_S3 := @_vcc_current_state(@state); 
            SL#_dryad_S3 := $current_state($s);
            // _math \state stmtexpr6#13; 
            // stmtexpr6#13 := _dryad_S3; 
            stmtexpr6#13 := SL#_dryad_S3;
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2, treap_reach(*((x->right)))))), ==(old(_dryad_S2, treap(*((x->right)))), old(_dryad_S3, treap(*((x->right)))))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(SL#_dryad_S2, $rd_phys_ptr(SL#_dryad_S2, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) ==> F#treap(SL#_dryad_S2, $rd_phys_ptr(SL#_dryad_S2, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) == F#treap(SL#_dryad_S3, $rd_phys_ptr(SL#_dryad_S3, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2, treap_reach(*((x->right)))))), ==(old(_dryad_S2, treap_reach(*((x->right)))), old(_dryad_S3, treap_reach(*((x->right)))))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(SL#_dryad_S2, $rd_phys_ptr(SL#_dryad_S2, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) ==> F#treap_reach(SL#_dryad_S2, $rd_phys_ptr(SL#_dryad_S2, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) == F#treap_reach(SL#_dryad_S3, $rd_phys_ptr(SL#_dryad_S3, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2, treap_reach(*((x->right)))))), ==(old(_dryad_S2, treap_keys(*((x->right)))), old(_dryad_S3, treap_keys(*((x->right)))))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(SL#_dryad_S2, $rd_phys_ptr(SL#_dryad_S2, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) ==> F#treap_keys(SL#_dryad_S2, $rd_phys_ptr(SL#_dryad_S2, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) == F#treap_keys(SL#_dryad_S3, $rd_phys_ptr(SL#_dryad_S3, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2, treap_reach(*((x->right)))))), ==(old(_dryad_S2, treap_max_key(*((x->right)))), old(_dryad_S3, treap_max_key(*((x->right)))))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(SL#_dryad_S2, $rd_phys_ptr(SL#_dryad_S2, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) ==> F#treap_max_key(SL#_dryad_S2, $rd_phys_ptr(SL#_dryad_S2, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) == F#treap_max_key(SL#_dryad_S3, $rd_phys_ptr(SL#_dryad_S3, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2, treap_reach(*((x->right)))))), ==(old(_dryad_S2, treap_max_prio(*((x->right)))), old(_dryad_S3, treap_max_prio(*((x->right)))))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(SL#_dryad_S2, $rd_phys_ptr(SL#_dryad_S2, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) ==> F#treap_max_prio(SL#_dryad_S2, $rd_phys_ptr(SL#_dryad_S2, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) == F#treap_max_prio(SL#_dryad_S3, $rd_phys_ptr(SL#_dryad_S3, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2, treap_reach(*((x->right)))))), ==(old(_dryad_S2, treap_min_key(*((x->right)))), old(_dryad_S3, treap_min_key(*((x->right)))))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(SL#_dryad_S2, $rd_phys_ptr(SL#_dryad_S2, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) ==> F#treap_min_key(SL#_dryad_S2, $rd_phys_ptr(SL#_dryad_S2, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) == F#treap_min_key(SL#_dryad_S3, $rd_phys_ptr(SL#_dryad_S3, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2, treap_reach(*((x->right)))))), ==(old(_dryad_S2, treap_prios(*((x->right)))), old(_dryad_S3, treap_prios(*((x->right)))))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(SL#_dryad_S2, $rd_phys_ptr(SL#_dryad_S2, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) ==> F#treap_prios(SL#_dryad_S2, $rd_phys_ptr(SL#_dryad_S2, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) == F#treap_prios(SL#_dryad_S3, $rd_phys_ptr(SL#_dryad_S3, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2, treap_reach(x1)))), ==(old(_dryad_S2, treap(x1)), old(_dryad_S3, treap(x1)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(SL#_dryad_S2, $phys_ptr_cast(SL#x1, ^b_node))) ==> F#treap(SL#_dryad_S2, $phys_ptr_cast(SL#x1, ^b_node)) == F#treap(SL#_dryad_S3, $phys_ptr_cast(SL#x1, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2, treap_reach(x1)))), ==(old(_dryad_S2, treap_reach(x1)), old(_dryad_S3, treap_reach(x1)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(SL#_dryad_S2, $phys_ptr_cast(SL#x1, ^b_node))) ==> F#treap_reach(SL#_dryad_S2, $phys_ptr_cast(SL#x1, ^b_node)) == F#treap_reach(SL#_dryad_S3, $phys_ptr_cast(SL#x1, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2, treap_reach(x1)))), ==(old(_dryad_S2, treap_keys(x1)), old(_dryad_S3, treap_keys(x1)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(SL#_dryad_S2, $phys_ptr_cast(SL#x1, ^b_node))) ==> F#treap_keys(SL#_dryad_S2, $phys_ptr_cast(SL#x1, ^b_node)) == F#treap_keys(SL#_dryad_S3, $phys_ptr_cast(SL#x1, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2, treap_reach(x1)))), ==(old(_dryad_S2, treap_max_key(x1)), old(_dryad_S3, treap_max_key(x1)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(SL#_dryad_S2, $phys_ptr_cast(SL#x1, ^b_node))) ==> F#treap_max_key(SL#_dryad_S2, $phys_ptr_cast(SL#x1, ^b_node)) == F#treap_max_key(SL#_dryad_S3, $phys_ptr_cast(SL#x1, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2, treap_reach(x1)))), ==(old(_dryad_S2, treap_max_prio(x1)), old(_dryad_S3, treap_max_prio(x1)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(SL#_dryad_S2, $phys_ptr_cast(SL#x1, ^b_node))) ==> F#treap_max_prio(SL#_dryad_S2, $phys_ptr_cast(SL#x1, ^b_node)) == F#treap_max_prio(SL#_dryad_S3, $phys_ptr_cast(SL#x1, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2, treap_reach(x1)))), ==(old(_dryad_S2, treap_min_key(x1)), old(_dryad_S3, treap_min_key(x1)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(SL#_dryad_S2, $phys_ptr_cast(SL#x1, ^b_node))) ==> F#treap_min_key(SL#_dryad_S2, $phys_ptr_cast(SL#x1, ^b_node)) == F#treap_min_key(SL#_dryad_S3, $phys_ptr_cast(SL#x1, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2, treap_reach(x1)))), ==(old(_dryad_S2, treap_prios(x1)), old(_dryad_S3, treap_prios(x1)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(SL#_dryad_S2, $phys_ptr_cast(SL#x1, ^b_node))) ==> F#treap_prios(SL#_dryad_S2, $phys_ptr_cast(SL#x1, ^b_node)) == F#treap_prios(SL#_dryad_S3, $phys_ptr_cast(SL#x1, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2, treap_reach(x0)))), ==(old(_dryad_S2, treap(x0)), old(_dryad_S3, treap(x0)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(SL#_dryad_S2, $phys_ptr_cast(SL#x0, ^b_node))) ==> F#treap(SL#_dryad_S2, $phys_ptr_cast(SL#x0, ^b_node)) == F#treap(SL#_dryad_S3, $phys_ptr_cast(SL#x0, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2, treap_reach(x0)))), ==(old(_dryad_S2, treap_reach(x0)), old(_dryad_S3, treap_reach(x0)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(SL#_dryad_S2, $phys_ptr_cast(SL#x0, ^b_node))) ==> F#treap_reach(SL#_dryad_S2, $phys_ptr_cast(SL#x0, ^b_node)) == F#treap_reach(SL#_dryad_S3, $phys_ptr_cast(SL#x0, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2, treap_reach(x0)))), ==(old(_dryad_S2, treap_keys(x0)), old(_dryad_S3, treap_keys(x0)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(SL#_dryad_S2, $phys_ptr_cast(SL#x0, ^b_node))) ==> F#treap_keys(SL#_dryad_S2, $phys_ptr_cast(SL#x0, ^b_node)) == F#treap_keys(SL#_dryad_S3, $phys_ptr_cast(SL#x0, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2, treap_reach(x0)))), ==(old(_dryad_S2, treap_max_key(x0)), old(_dryad_S3, treap_max_key(x0)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(SL#_dryad_S2, $phys_ptr_cast(SL#x0, ^b_node))) ==> F#treap_max_key(SL#_dryad_S2, $phys_ptr_cast(SL#x0, ^b_node)) == F#treap_max_key(SL#_dryad_S3, $phys_ptr_cast(SL#x0, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2, treap_reach(x0)))), ==(old(_dryad_S2, treap_max_prio(x0)), old(_dryad_S3, treap_max_prio(x0)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(SL#_dryad_S2, $phys_ptr_cast(SL#x0, ^b_node))) ==> F#treap_max_prio(SL#_dryad_S2, $phys_ptr_cast(SL#x0, ^b_node)) == F#treap_max_prio(SL#_dryad_S3, $phys_ptr_cast(SL#x0, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2, treap_reach(x0)))), ==(old(_dryad_S2, treap_min_key(x0)), old(_dryad_S3, treap_min_key(x0)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(SL#_dryad_S2, $phys_ptr_cast(SL#x0, ^b_node))) ==> F#treap_min_key(SL#_dryad_S2, $phys_ptr_cast(SL#x0, ^b_node)) == F#treap_min_key(SL#_dryad_S3, $phys_ptr_cast(SL#x0, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2, treap_reach(x0)))), ==(old(_dryad_S2, treap_prios(x0)), old(_dryad_S3, treap_prios(x0)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(SL#_dryad_S2, $phys_ptr_cast(SL#x0, ^b_node))) ==> F#treap_prios(SL#_dryad_S2, $phys_ptr_cast(SL#x0, ^b_node)) == F#treap_prios(SL#_dryad_S3, $phys_ptr_cast(SL#x0, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2, treap_reach(xl)))), ==(old(_dryad_S2, treap(xl)), old(_dryad_S3, treap(xl)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(SL#_dryad_S2, $phys_ptr_cast(L#xl, ^b_node))) ==> F#treap(SL#_dryad_S2, $phys_ptr_cast(L#xl, ^b_node)) == F#treap(SL#_dryad_S3, $phys_ptr_cast(L#xl, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2, treap_reach(xl)))), ==(old(_dryad_S2, treap_reach(xl)), old(_dryad_S3, treap_reach(xl)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(SL#_dryad_S2, $phys_ptr_cast(L#xl, ^b_node))) ==> F#treap_reach(SL#_dryad_S2, $phys_ptr_cast(L#xl, ^b_node)) == F#treap_reach(SL#_dryad_S3, $phys_ptr_cast(L#xl, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2, treap_reach(xl)))), ==(old(_dryad_S2, treap_keys(xl)), old(_dryad_S3, treap_keys(xl)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(SL#_dryad_S2, $phys_ptr_cast(L#xl, ^b_node))) ==> F#treap_keys(SL#_dryad_S2, $phys_ptr_cast(L#xl, ^b_node)) == F#treap_keys(SL#_dryad_S3, $phys_ptr_cast(L#xl, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2, treap_reach(xl)))), ==(old(_dryad_S2, treap_max_key(xl)), old(_dryad_S3, treap_max_key(xl)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(SL#_dryad_S2, $phys_ptr_cast(L#xl, ^b_node))) ==> F#treap_max_key(SL#_dryad_S2, $phys_ptr_cast(L#xl, ^b_node)) == F#treap_max_key(SL#_dryad_S3, $phys_ptr_cast(L#xl, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2, treap_reach(xl)))), ==(old(_dryad_S2, treap_max_prio(xl)), old(_dryad_S3, treap_max_prio(xl)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(SL#_dryad_S2, $phys_ptr_cast(L#xl, ^b_node))) ==> F#treap_max_prio(SL#_dryad_S2, $phys_ptr_cast(L#xl, ^b_node)) == F#treap_max_prio(SL#_dryad_S3, $phys_ptr_cast(L#xl, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2, treap_reach(xl)))), ==(old(_dryad_S2, treap_min_key(xl)), old(_dryad_S3, treap_min_key(xl)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(SL#_dryad_S2, $phys_ptr_cast(L#xl, ^b_node))) ==> F#treap_min_key(SL#_dryad_S2, $phys_ptr_cast(L#xl, ^b_node)) == F#treap_min_key(SL#_dryad_S3, $phys_ptr_cast(L#xl, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2, treap_reach(xl)))), ==(old(_dryad_S2, treap_prios(xl)), old(_dryad_S3, treap_prios(xl)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(SL#_dryad_S2, $phys_ptr_cast(L#xl, ^b_node))) ==> F#treap_prios(SL#_dryad_S2, $phys_ptr_cast(L#xl, ^b_node)) == F#treap_prios(SL#_dryad_S3, $phys_ptr_cast(L#xl, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2, treap_reach(xr)))), ==(old(_dryad_S2, treap(xr)), old(_dryad_S3, treap(xr)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(SL#_dryad_S2, $phys_ptr_cast(L#xr, ^b_node))) ==> F#treap(SL#_dryad_S2, $phys_ptr_cast(L#xr, ^b_node)) == F#treap(SL#_dryad_S3, $phys_ptr_cast(L#xr, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2, treap_reach(xr)))), ==(old(_dryad_S2, treap_reach(xr)), old(_dryad_S3, treap_reach(xr)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(SL#_dryad_S2, $phys_ptr_cast(L#xr, ^b_node))) ==> F#treap_reach(SL#_dryad_S2, $phys_ptr_cast(L#xr, ^b_node)) == F#treap_reach(SL#_dryad_S3, $phys_ptr_cast(L#xr, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2, treap_reach(xr)))), ==(old(_dryad_S2, treap_keys(xr)), old(_dryad_S3, treap_keys(xr)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(SL#_dryad_S2, $phys_ptr_cast(L#xr, ^b_node))) ==> F#treap_keys(SL#_dryad_S2, $phys_ptr_cast(L#xr, ^b_node)) == F#treap_keys(SL#_dryad_S3, $phys_ptr_cast(L#xr, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2, treap_reach(xr)))), ==(old(_dryad_S2, treap_max_key(xr)), old(_dryad_S3, treap_max_key(xr)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(SL#_dryad_S2, $phys_ptr_cast(L#xr, ^b_node))) ==> F#treap_max_key(SL#_dryad_S2, $phys_ptr_cast(L#xr, ^b_node)) == F#treap_max_key(SL#_dryad_S3, $phys_ptr_cast(L#xr, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2, treap_reach(xr)))), ==(old(_dryad_S2, treap_max_prio(xr)), old(_dryad_S3, treap_max_prio(xr)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(SL#_dryad_S2, $phys_ptr_cast(L#xr, ^b_node))) ==> F#treap_max_prio(SL#_dryad_S2, $phys_ptr_cast(L#xr, ^b_node)) == F#treap_max_prio(SL#_dryad_S3, $phys_ptr_cast(L#xr, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2, treap_reach(xr)))), ==(old(_dryad_S2, treap_min_key(xr)), old(_dryad_S3, treap_min_key(xr)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(SL#_dryad_S2, $phys_ptr_cast(L#xr, ^b_node))) ==> F#treap_min_key(SL#_dryad_S2, $phys_ptr_cast(L#xr, ^b_node)) == F#treap_min_key(SL#_dryad_S3, $phys_ptr_cast(L#xr, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2, treap_reach(xr)))), ==(old(_dryad_S2, treap_prios(xr)), old(_dryad_S3, treap_prios(xr)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(SL#_dryad_S2, $phys_ptr_cast(L#xr, ^b_node))) ==> F#treap_prios(SL#_dryad_S2, $phys_ptr_cast(L#xr, ^b_node)) == F#treap_prios(SL#_dryad_S3, $phys_ptr_cast(L#xr, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2, treap_reach(l)))), ==(old(_dryad_S2, treap(l)), old(_dryad_S3, treap(l)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(SL#_dryad_S2, $phys_ptr_cast(L#l, ^b_node))) ==> F#treap(SL#_dryad_S2, $phys_ptr_cast(L#l, ^b_node)) == F#treap(SL#_dryad_S3, $phys_ptr_cast(L#l, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2, treap_reach(l)))), ==(old(_dryad_S2, treap_reach(l)), old(_dryad_S3, treap_reach(l)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(SL#_dryad_S2, $phys_ptr_cast(L#l, ^b_node))) ==> F#treap_reach(SL#_dryad_S2, $phys_ptr_cast(L#l, ^b_node)) == F#treap_reach(SL#_dryad_S3, $phys_ptr_cast(L#l, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2, treap_reach(l)))), ==(old(_dryad_S2, treap_keys(l)), old(_dryad_S3, treap_keys(l)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(SL#_dryad_S2, $phys_ptr_cast(L#l, ^b_node))) ==> F#treap_keys(SL#_dryad_S2, $phys_ptr_cast(L#l, ^b_node)) == F#treap_keys(SL#_dryad_S3, $phys_ptr_cast(L#l, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2, treap_reach(l)))), ==(old(_dryad_S2, treap_max_key(l)), old(_dryad_S3, treap_max_key(l)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(SL#_dryad_S2, $phys_ptr_cast(L#l, ^b_node))) ==> F#treap_max_key(SL#_dryad_S2, $phys_ptr_cast(L#l, ^b_node)) == F#treap_max_key(SL#_dryad_S3, $phys_ptr_cast(L#l, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2, treap_reach(l)))), ==(old(_dryad_S2, treap_max_prio(l)), old(_dryad_S3, treap_max_prio(l)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(SL#_dryad_S2, $phys_ptr_cast(L#l, ^b_node))) ==> F#treap_max_prio(SL#_dryad_S2, $phys_ptr_cast(L#l, ^b_node)) == F#treap_max_prio(SL#_dryad_S3, $phys_ptr_cast(L#l, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2, treap_reach(l)))), ==(old(_dryad_S2, treap_min_key(l)), old(_dryad_S3, treap_min_key(l)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(SL#_dryad_S2, $phys_ptr_cast(L#l, ^b_node))) ==> F#treap_min_key(SL#_dryad_S2, $phys_ptr_cast(L#l, ^b_node)) == F#treap_min_key(SL#_dryad_S3, $phys_ptr_cast(L#l, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2, treap_reach(l)))), ==(old(_dryad_S2, treap_prios(l)), old(_dryad_S3, treap_prios(l)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(SL#_dryad_S2, $phys_ptr_cast(L#l, ^b_node))) ==> F#treap_prios(SL#_dryad_S2, $phys_ptr_cast(L#l, ^b_node)) == F#treap_prios(SL#_dryad_S3, $phys_ptr_cast(L#l, ^b_node));
            // assume ==>(!(@_vcc_ptr_eq_pure(x, x1)), @_vcc_ptr_eq_pure(*((x1->left)), old(_dryad_S2, *((x1->left))))); 
            assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(SL#x1, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node) == $rd_phys_ptr(SL#_dryad_S2, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_ptr_eq_pure(x, x1)), @_vcc_ptr_eq_pure(*((x1->right)), old(_dryad_S2, *((x1->right))))); 
            assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(SL#x1, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node) == $rd_phys_ptr(SL#_dryad_S2, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_ptr_eq_pure(x, x1)), ==(*((x1->key)), old(_dryad_S2, *((x1->key))))); 
            assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(SL#x1, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)) == $rd_inv(SL#_dryad_S2, b_node.key, $phys_ptr_cast(SL#x1, ^b_node));
            // assume ==>(!(@_vcc_ptr_eq_pure(x, x1)), ==(*((x1->prio)), old(_dryad_S2, *((x1->prio))))); 
            assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(SL#x1, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node)) == $rd_inv(SL#_dryad_S2, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node));
            // assume ==>(!(@_vcc_ptr_eq_pure(x, x0)), @_vcc_ptr_eq_pure(*((x0->left)), old(_dryad_S2, *((x0->left))))); 
            assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(SL#x0, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node) == $rd_phys_ptr(SL#_dryad_S2, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_ptr_eq_pure(x, x0)), @_vcc_ptr_eq_pure(*((x0->right)), old(_dryad_S2, *((x0->right))))); 
            assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(SL#x0, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node) == $rd_phys_ptr(SL#_dryad_S2, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_ptr_eq_pure(x, x0)), ==(*((x0->key)), old(_dryad_S2, *((x0->key))))); 
            assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(SL#x0, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)) == $rd_inv(SL#_dryad_S2, b_node.key, $phys_ptr_cast(SL#x0, ^b_node));
            // assume ==>(!(@_vcc_ptr_eq_pure(x, x0)), ==(*((x0->prio)), old(_dryad_S2, *((x0->prio))))); 
            assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(SL#x0, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node)) == $rd_inv(SL#_dryad_S2, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node));
            // assume ==>(!(@_vcc_ptr_eq_pure(x, xl)), @_vcc_ptr_eq_pure(*((xl->left)), old(_dryad_S2, *((xl->left))))); 
            assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(L#xl, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node) == $rd_phys_ptr(SL#_dryad_S2, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_ptr_eq_pure(x, xl)), @_vcc_ptr_eq_pure(*((xl->right)), old(_dryad_S2, *((xl->right))))); 
            assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(L#xl, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node) == $rd_phys_ptr(SL#_dryad_S2, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_ptr_eq_pure(x, xl)), ==(*((xl->key)), old(_dryad_S2, *((xl->key))))); 
            assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(L#xl, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)) == $rd_inv(SL#_dryad_S2, b_node.key, $phys_ptr_cast(L#xl, ^b_node));
            // assume ==>(!(@_vcc_ptr_eq_pure(x, xl)), ==(*((xl->prio)), old(_dryad_S2, *((xl->prio))))); 
            assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(L#xl, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node)) == $rd_inv(SL#_dryad_S2, b_node.prio, $phys_ptr_cast(L#xl, ^b_node));
            // assume ==>(!(@_vcc_ptr_eq_pure(x, xr)), @_vcc_ptr_eq_pure(*((xr->left)), old(_dryad_S2, *((xr->left))))); 
            assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(L#xr, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node) == $rd_phys_ptr(SL#_dryad_S2, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_ptr_eq_pure(x, xr)), @_vcc_ptr_eq_pure(*((xr->right)), old(_dryad_S2, *((xr->right))))); 
            assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(L#xr, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node) == $rd_phys_ptr(SL#_dryad_S2, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_ptr_eq_pure(x, xr)), ==(*((xr->key)), old(_dryad_S2, *((xr->key))))); 
            assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(L#xr, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)) == $rd_inv(SL#_dryad_S2, b_node.key, $phys_ptr_cast(L#xr, ^b_node));
            // assume ==>(!(@_vcc_ptr_eq_pure(x, xr)), ==(*((xr->prio)), old(_dryad_S2, *((xr->prio))))); 
            assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(L#xr, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node)) == $rd_inv(SL#_dryad_S2, b_node.prio, $phys_ptr_cast(L#xr, ^b_node));
            // assume ==>(!(@_vcc_ptr_eq_pure(x, l)), @_vcc_ptr_eq_pure(*((l->left)), old(_dryad_S2, *((l->left))))); 
            assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(L#l, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node) == $rd_phys_ptr(SL#_dryad_S2, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_ptr_eq_pure(x, l)), @_vcc_ptr_eq_pure(*((l->right)), old(_dryad_S2, *((l->right))))); 
            assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(L#l, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node) == $rd_phys_ptr(SL#_dryad_S2, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_ptr_eq_pure(x, l)), ==(*((l->key)), old(_dryad_S2, *((l->key))))); 
            assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(L#l, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#l, ^b_node)) == $rd_inv(SL#_dryad_S2, b_node.key, $phys_ptr_cast(L#l, ^b_node));
            // assume ==>(!(@_vcc_ptr_eq_pure(x, l)), ==(*((l->prio)), old(_dryad_S2, *((l->prio))))); 
            assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(L#l, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(L#l, ^b_node)) == $rd_inv(SL#_dryad_S2, b_node.prio, $phys_ptr_cast(L#l, ^b_node));
            // assume ==>(@_vcc_ptr_neq_null(x1), ==(treap(x1), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x1->left))), treap(*((x1->right)))), unchecked!(@_vcc_oset_in(x1, @_vcc_oset_union(treap_reach(*((x1->left))), treap_reach(*((x1->right))))))), unchecked!(@_vcc_intset_in(*((x1->key)), @_vcc_intset_union(treap_keys(*((x1->left))), treap_keys(*((x1->right))))))), unchecked!(@_vcc_intset_in(*((x1->prio)), @_vcc_intset_union(treap_prios(*((x1->left))), treap_prios(*((x1->right))))))), @_vcc_oset_disjoint(treap_reach(*((x1->left))), treap_reach(*((x1->right))))), @_vcc_intset_disjoint(treap_keys(*((x1->left))), treap_keys(*((x1->right))))), @_vcc_intset_disjoint(treap_prios(*((x1->left))), treap_prios(*((x1->right))))), ==>(@_vcc_ptr_neq_null(*((x1->left))), <(treap_max_key(*((x1->left))), *((x1->key))))), ==>(@_vcc_ptr_neq_null(*((x1->right))), <(*((x1->key)), treap_min_key(*((x1->right)))))), ==>(@_vcc_ptr_neq_null(*((x1->left))), <(treap_max_prio(*((x1->left))), *((x1->prio))))), ==>(@_vcc_ptr_neq_null(*((x1->right))), <(treap_max_prio(*((x1->right))), *((x1->prio))))))); 
            assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> F#treap($s, $phys_ptr_cast(SL#x1, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(SL#x1, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x1), ==(treap_reach(x1), @_vcc_oset_union(@_vcc_oset_singleton(x1), @_vcc_oset_union(treap_reach(*((x1->left))), treap_reach(*((x1->right))))))); 
            assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(SL#x1, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(SL#x1, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x1), ==(treap_keys(x1), @_vcc_intset_union(@_vcc_intset_singleton(*((x1->key))), @_vcc_intset_union(treap_keys(*((x1->left))), treap_keys(*((x1->right))))))); 
            assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(SL#x1, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x1), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x1->left))), @_vcc_ptr_neq_null(*((x1->right)))), ==(treap_max_key(x1), @\int_max(*((x1->key)), @\int_max(treap_max_key(*((x1->left))), treap_max_key(*((x1->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x1->left))), @_vcc_ptr_eq_null(*((x1->right)))), ==(treap_max_key(x1), @\int_max(*((x1->key)), treap_max_key(*((x1->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x1->left))), @_vcc_ptr_neq_null(*((x1->right)))), ==(treap_max_key(x1), @\int_max(*((x1->key)), treap_max_key(*((x1->right)))))))); 
            assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x1), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x1->left))), @_vcc_ptr_neq_null(*((x1->right)))), ==(treap_max_prio(x1), @\int_max(*((x1->prio)), @\int_max(treap_max_prio(*((x1->left))), treap_max_prio(*((x1->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x1->left))), @_vcc_ptr_eq_null(*((x1->right)))), ==(treap_max_prio(x1), @\int_max(*((x1->prio)), treap_max_prio(*((x1->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x1->left))), @_vcc_ptr_neq_null(*((x1->right)))), ==(treap_max_prio(x1), @\int_max(*((x1->prio)), treap_max_prio(*((x1->right)))))))); 
            assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x1), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x1->left))), @_vcc_ptr_neq_null(*((x1->right)))), ==(treap_min_key(x1), @\int_min(*((x1->key)), @\int_min(treap_min_key(*((x1->left))), treap_min_key(*((x1->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x1->left))), @_vcc_ptr_eq_null(*((x1->right)))), ==(treap_min_key(x1), @\int_min(*((x1->key)), treap_min_key(*((x1->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x1->left))), @_vcc_ptr_neq_null(*((x1->right)))), ==(treap_min_key(x1), @\int_min(*((x1->key)), treap_min_key(*((x1->right)))))))); 
            assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x1), ==(treap_prios(x1), @_vcc_intset_union(@_vcc_intset_singleton(*((x1->prio))), @_vcc_intset_union(treap_prios(*((x1->left))), treap_prios(*((x1->right))))))); 
            assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(SL#x1, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x0), ==(treap(x0), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x0->left))), treap(*((x0->right)))), unchecked!(@_vcc_oset_in(x0, @_vcc_oset_union(treap_reach(*((x0->left))), treap_reach(*((x0->right))))))), unchecked!(@_vcc_intset_in(*((x0->key)), @_vcc_intset_union(treap_keys(*((x0->left))), treap_keys(*((x0->right))))))), unchecked!(@_vcc_intset_in(*((x0->prio)), @_vcc_intset_union(treap_prios(*((x0->left))), treap_prios(*((x0->right))))))), @_vcc_oset_disjoint(treap_reach(*((x0->left))), treap_reach(*((x0->right))))), @_vcc_intset_disjoint(treap_keys(*((x0->left))), treap_keys(*((x0->right))))), @_vcc_intset_disjoint(treap_prios(*((x0->left))), treap_prios(*((x0->right))))), ==>(@_vcc_ptr_neq_null(*((x0->left))), <(treap_max_key(*((x0->left))), *((x0->key))))), ==>(@_vcc_ptr_neq_null(*((x0->right))), <(*((x0->key)), treap_min_key(*((x0->right)))))), ==>(@_vcc_ptr_neq_null(*((x0->left))), <(treap_max_prio(*((x0->left))), *((x0->prio))))), ==>(@_vcc_ptr_neq_null(*((x0->right))), <(treap_max_prio(*((x0->right))), *((x0->prio))))))); 
            assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> F#treap($s, $phys_ptr_cast(SL#x0, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(SL#x0, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x0), ==(treap_reach(x0), @_vcc_oset_union(@_vcc_oset_singleton(x0), @_vcc_oset_union(treap_reach(*((x0->left))), treap_reach(*((x0->right))))))); 
            assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(SL#x0, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(SL#x0, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x0), ==(treap_keys(x0), @_vcc_intset_union(@_vcc_intset_singleton(*((x0->key))), @_vcc_intset_union(treap_keys(*((x0->left))), treap_keys(*((x0->right))))))); 
            assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(SL#x0, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x0), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x0->left))), @_vcc_ptr_neq_null(*((x0->right)))), ==(treap_max_key(x0), @\int_max(*((x0->key)), @\int_max(treap_max_key(*((x0->left))), treap_max_key(*((x0->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x0->left))), @_vcc_ptr_eq_null(*((x0->right)))), ==(treap_max_key(x0), @\int_max(*((x0->key)), treap_max_key(*((x0->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x0->left))), @_vcc_ptr_neq_null(*((x0->right)))), ==(treap_max_key(x0), @\int_max(*((x0->key)), treap_max_key(*((x0->right)))))))); 
            assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x0), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x0->left))), @_vcc_ptr_neq_null(*((x0->right)))), ==(treap_max_prio(x0), @\int_max(*((x0->prio)), @\int_max(treap_max_prio(*((x0->left))), treap_max_prio(*((x0->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x0->left))), @_vcc_ptr_eq_null(*((x0->right)))), ==(treap_max_prio(x0), @\int_max(*((x0->prio)), treap_max_prio(*((x0->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x0->left))), @_vcc_ptr_neq_null(*((x0->right)))), ==(treap_max_prio(x0), @\int_max(*((x0->prio)), treap_max_prio(*((x0->right)))))))); 
            assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x0), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x0->left))), @_vcc_ptr_neq_null(*((x0->right)))), ==(treap_min_key(x0), @\int_min(*((x0->key)), @\int_min(treap_min_key(*((x0->left))), treap_min_key(*((x0->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x0->left))), @_vcc_ptr_eq_null(*((x0->right)))), ==(treap_min_key(x0), @\int_min(*((x0->key)), treap_min_key(*((x0->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x0->left))), @_vcc_ptr_neq_null(*((x0->right)))), ==(treap_min_key(x0), @\int_min(*((x0->key)), treap_min_key(*((x0->right)))))))); 
            assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x0), ==(treap_prios(x0), @_vcc_intset_union(@_vcc_intset_singleton(*((x0->prio))), @_vcc_intset_union(treap_prios(*((x0->left))), treap_prios(*((x0->right))))))); 
            assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(SL#x0, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl), ==(treap(xl), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((xl->left))), treap(*((xl->right)))), unchecked!(@_vcc_oset_in(xl, @_vcc_oset_union(treap_reach(*((xl->left))), treap_reach(*((xl->right))))))), unchecked!(@_vcc_intset_in(*((xl->key)), @_vcc_intset_union(treap_keys(*((xl->left))), treap_keys(*((xl->right))))))), unchecked!(@_vcc_intset_in(*((xl->prio)), @_vcc_intset_union(treap_prios(*((xl->left))), treap_prios(*((xl->right))))))), @_vcc_oset_disjoint(treap_reach(*((xl->left))), treap_reach(*((xl->right))))), @_vcc_intset_disjoint(treap_keys(*((xl->left))), treap_keys(*((xl->right))))), @_vcc_intset_disjoint(treap_prios(*((xl->left))), treap_prios(*((xl->right))))), ==>(@_vcc_ptr_neq_null(*((xl->left))), <(treap_max_key(*((xl->left))), *((xl->key))))), ==>(@_vcc_ptr_neq_null(*((xl->right))), <(*((xl->key)), treap_min_key(*((xl->right)))))), ==>(@_vcc_ptr_neq_null(*((xl->left))), <(treap_max_prio(*((xl->left))), *((xl->prio))))), ==>(@_vcc_ptr_neq_null(*((xl->right))), <(treap_max_prio(*((xl->right))), *((xl->prio))))))); 
            assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> F#treap($s, $phys_ptr_cast(L#xl, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(L#xl, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl), ==(treap_reach(xl), @_vcc_oset_union(@_vcc_oset_singleton(xl), @_vcc_oset_union(treap_reach(*((xl->left))), treap_reach(*((xl->right))))))); 
            assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(L#xl, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(L#xl, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl), ==(treap_keys(xl), @_vcc_intset_union(@_vcc_intset_singleton(*((xl->key))), @_vcc_intset_union(treap_keys(*((xl->left))), treap_keys(*((xl->right))))))); 
            assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(L#xl, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_max_key(xl), @\int_max(*((xl->key)), @\int_max(treap_max_key(*((xl->left))), treap_max_key(*((xl->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_eq_null(*((xl->right)))), ==(treap_max_key(xl), @\int_max(*((xl->key)), treap_max_key(*((xl->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_max_key(xl), @\int_max(*((xl->key)), treap_max_key(*((xl->right)))))))); 
            assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_max_prio(xl), @\int_max(*((xl->prio)), @\int_max(treap_max_prio(*((xl->left))), treap_max_prio(*((xl->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_eq_null(*((xl->right)))), ==(treap_max_prio(xl), @\int_max(*((xl->prio)), treap_max_prio(*((xl->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_max_prio(xl), @\int_max(*((xl->prio)), treap_max_prio(*((xl->right)))))))); 
            assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_min_key(xl), @\int_min(*((xl->key)), @\int_min(treap_min_key(*((xl->left))), treap_min_key(*((xl->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_eq_null(*((xl->right)))), ==(treap_min_key(xl), @\int_min(*((xl->key)), treap_min_key(*((xl->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_min_key(xl), @\int_min(*((xl->key)), treap_min_key(*((xl->right)))))))); 
            assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl), ==(treap_prios(xl), @_vcc_intset_union(@_vcc_intset_singleton(*((xl->prio))), @_vcc_intset_union(treap_prios(*((xl->left))), treap_prios(*((xl->right))))))); 
            assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(L#xl, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr), ==(treap(xr), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((xr->left))), treap(*((xr->right)))), unchecked!(@_vcc_oset_in(xr, @_vcc_oset_union(treap_reach(*((xr->left))), treap_reach(*((xr->right))))))), unchecked!(@_vcc_intset_in(*((xr->key)), @_vcc_intset_union(treap_keys(*((xr->left))), treap_keys(*((xr->right))))))), unchecked!(@_vcc_intset_in(*((xr->prio)), @_vcc_intset_union(treap_prios(*((xr->left))), treap_prios(*((xr->right))))))), @_vcc_oset_disjoint(treap_reach(*((xr->left))), treap_reach(*((xr->right))))), @_vcc_intset_disjoint(treap_keys(*((xr->left))), treap_keys(*((xr->right))))), @_vcc_intset_disjoint(treap_prios(*((xr->left))), treap_prios(*((xr->right))))), ==>(@_vcc_ptr_neq_null(*((xr->left))), <(treap_max_key(*((xr->left))), *((xr->key))))), ==>(@_vcc_ptr_neq_null(*((xr->right))), <(*((xr->key)), treap_min_key(*((xr->right)))))), ==>(@_vcc_ptr_neq_null(*((xr->left))), <(treap_max_prio(*((xr->left))), *((xr->prio))))), ==>(@_vcc_ptr_neq_null(*((xr->right))), <(treap_max_prio(*((xr->right))), *((xr->prio))))))); 
            assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> F#treap($s, $phys_ptr_cast(L#xr, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(L#xr, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr), ==(treap_reach(xr), @_vcc_oset_union(@_vcc_oset_singleton(xr), @_vcc_oset_union(treap_reach(*((xr->left))), treap_reach(*((xr->right))))))); 
            assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(L#xr, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(L#xr, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr), ==(treap_keys(xr), @_vcc_intset_union(@_vcc_intset_singleton(*((xr->key))), @_vcc_intset_union(treap_keys(*((xr->left))), treap_keys(*((xr->right))))))); 
            assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(L#xr, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_max_key(xr), @\int_max(*((xr->key)), @\int_max(treap_max_key(*((xr->left))), treap_max_key(*((xr->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_eq_null(*((xr->right)))), ==(treap_max_key(xr), @\int_max(*((xr->key)), treap_max_key(*((xr->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_max_key(xr), @\int_max(*((xr->key)), treap_max_key(*((xr->right)))))))); 
            assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_max_prio(xr), @\int_max(*((xr->prio)), @\int_max(treap_max_prio(*((xr->left))), treap_max_prio(*((xr->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_eq_null(*((xr->right)))), ==(treap_max_prio(xr), @\int_max(*((xr->prio)), treap_max_prio(*((xr->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_max_prio(xr), @\int_max(*((xr->prio)), treap_max_prio(*((xr->right)))))))); 
            assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_min_key(xr), @\int_min(*((xr->key)), @\int_min(treap_min_key(*((xr->left))), treap_min_key(*((xr->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_eq_null(*((xr->right)))), ==(treap_min_key(xr), @\int_min(*((xr->key)), treap_min_key(*((xr->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_min_key(xr), @\int_min(*((xr->key)), treap_min_key(*((xr->right)))))))); 
            assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr), ==(treap_prios(xr), @_vcc_intset_union(@_vcc_intset_singleton(*((xr->prio))), @_vcc_intset_union(treap_prios(*((xr->left))), treap_prios(*((xr->right))))))); 
            assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(L#xr, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(l), ==(treap(l), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((l->left))), treap(*((l->right)))), unchecked!(@_vcc_oset_in(l, @_vcc_oset_union(treap_reach(*((l->left))), treap_reach(*((l->right))))))), unchecked!(@_vcc_intset_in(*((l->key)), @_vcc_intset_union(treap_keys(*((l->left))), treap_keys(*((l->right))))))), unchecked!(@_vcc_intset_in(*((l->prio)), @_vcc_intset_union(treap_prios(*((l->left))), treap_prios(*((l->right))))))), @_vcc_oset_disjoint(treap_reach(*((l->left))), treap_reach(*((l->right))))), @_vcc_intset_disjoint(treap_keys(*((l->left))), treap_keys(*((l->right))))), @_vcc_intset_disjoint(treap_prios(*((l->left))), treap_prios(*((l->right))))), ==>(@_vcc_ptr_neq_null(*((l->left))), <(treap_max_key(*((l->left))), *((l->key))))), ==>(@_vcc_ptr_neq_null(*((l->right))), <(*((l->key)), treap_min_key(*((l->right)))))), ==>(@_vcc_ptr_neq_null(*((l->left))), <(treap_max_prio(*((l->left))), *((l->prio))))), ==>(@_vcc_ptr_neq_null(*((l->right))), <(treap_max_prio(*((l->right))), *((l->prio))))))); 
            assume $non_null($phys_ptr_cast(L#l, ^b_node)) ==> F#treap($s, $phys_ptr_cast(L#l, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(L#l, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(L#l, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(L#l, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(L#l, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#l, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#l, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#l, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(l), ==(treap_reach(l), @_vcc_oset_union(@_vcc_oset_singleton(l), @_vcc_oset_union(treap_reach(*((l->left))), treap_reach(*((l->right))))))); 
            assume $non_null($phys_ptr_cast(L#l, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(L#l, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(L#l, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(l), ==(treap_keys(l), @_vcc_intset_union(@_vcc_intset_singleton(*((l->key))), @_vcc_intset_union(treap_keys(*((l->left))), treap_keys(*((l->right))))))); 
            assume $non_null($phys_ptr_cast(L#l, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(L#l, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(L#l, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(l), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((l->left))), @_vcc_ptr_neq_null(*((l->right)))), ==(treap_max_key(l), @\int_max(*((l->key)), @\int_max(treap_max_key(*((l->left))), treap_max_key(*((l->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((l->left))), @_vcc_ptr_eq_null(*((l->right)))), ==(treap_max_key(l), @\int_max(*((l->key)), treap_max_key(*((l->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((l->left))), @_vcc_ptr_neq_null(*((l->right)))), ==(treap_max_key(l), @\int_max(*((l->key)), treap_max_key(*((l->right)))))))); 
            assume $non_null($phys_ptr_cast(L#l, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#l, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#l, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#l, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#l, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#l, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#l, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(l), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((l->left))), @_vcc_ptr_neq_null(*((l->right)))), ==(treap_max_prio(l), @\int_max(*((l->prio)), @\int_max(treap_max_prio(*((l->left))), treap_max_prio(*((l->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((l->left))), @_vcc_ptr_eq_null(*((l->right)))), ==(treap_max_prio(l), @\int_max(*((l->prio)), treap_max_prio(*((l->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((l->left))), @_vcc_ptr_neq_null(*((l->right)))), ==(treap_max_prio(l), @\int_max(*((l->prio)), treap_max_prio(*((l->right)))))))); 
            assume $non_null($phys_ptr_cast(L#l, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#l, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#l, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#l, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#l, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#l, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#l, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(l), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((l->left))), @_vcc_ptr_neq_null(*((l->right)))), ==(treap_min_key(l), @\int_min(*((l->key)), @\int_min(treap_min_key(*((l->left))), treap_min_key(*((l->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((l->left))), @_vcc_ptr_eq_null(*((l->right)))), ==(treap_min_key(l), @\int_min(*((l->key)), treap_min_key(*((l->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((l->left))), @_vcc_ptr_neq_null(*((l->right)))), ==(treap_min_key(l), @\int_min(*((l->key)), treap_min_key(*((l->right)))))))); 
            assume $non_null($phys_ptr_cast(L#l, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#l, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#l, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#l, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#l, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#l, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#l, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(l), ==(treap_prios(l), @_vcc_intset_union(@_vcc_intset_singleton(*((l->prio))), @_vcc_intset_union(treap_prios(*((l->left))), treap_prios(*((l->right))))))); 
            assume $non_null($phys_ptr_cast(L#l, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(L#l, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(L#l, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap(x), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x->left))), treap(*((x->right)))), unchecked!(@_vcc_oset_in(x, @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->key)), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->prio)), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))), @_vcc_oset_disjoint(treap_reach(*((x->left))), treap_reach(*((x->right))))), @_vcc_intset_disjoint(treap_keys(*((x->left))), treap_keys(*((x->right))))), @_vcc_intset_disjoint(treap_prios(*((x->left))), treap_prios(*((x->right))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_key(*((x->left))), *((x->key))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(*((x->key)), treap_min_key(*((x->right)))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_prio(*((x->left))), *((x->prio))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(treap_max_prio(*((x->right))), *((x->prio))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap($s, $phys_ptr_cast(P#x, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(P#x, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_reach(x), @_vcc_oset_union(@_vcc_oset_singleton(x), @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(P#x, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(P#x, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_keys(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->key))), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), @\int_max(treap_max_key(*((x->left))), treap_max_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), @\int_max(treap_max_prio(*((x->left))), treap_max_prio(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), @\int_min(treap_min_key(*((x->left))), treap_min_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_prios(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->prio))), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(l), ==(treap(l), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((l->left))), treap(*((l->right)))), unchecked!(@_vcc_oset_in(l, @_vcc_oset_union(treap_reach(*((l->left))), treap_reach(*((l->right))))))), unchecked!(@_vcc_intset_in(*((l->key)), @_vcc_intset_union(treap_keys(*((l->left))), treap_keys(*((l->right))))))), unchecked!(@_vcc_intset_in(*((l->prio)), @_vcc_intset_union(treap_prios(*((l->left))), treap_prios(*((l->right))))))), @_vcc_oset_disjoint(treap_reach(*((l->left))), treap_reach(*((l->right))))), @_vcc_intset_disjoint(treap_keys(*((l->left))), treap_keys(*((l->right))))), @_vcc_intset_disjoint(treap_prios(*((l->left))), treap_prios(*((l->right))))), ==>(@_vcc_ptr_neq_null(*((l->left))), <(treap_max_key(*((l->left))), *((l->key))))), ==>(@_vcc_ptr_neq_null(*((l->right))), <(*((l->key)), treap_min_key(*((l->right)))))), ==>(@_vcc_ptr_neq_null(*((l->left))), <(treap_max_prio(*((l->left))), *((l->prio))))), ==>(@_vcc_ptr_neq_null(*((l->right))), <(treap_max_prio(*((l->right))), *((l->prio))))))); 
            assume $non_null($phys_ptr_cast(L#l, ^b_node)) ==> F#treap($s, $phys_ptr_cast(L#l, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(L#l, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(L#l, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(L#l, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(L#l, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#l, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#l, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#l, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(l), ==(treap_reach(l), @_vcc_oset_union(@_vcc_oset_singleton(l), @_vcc_oset_union(treap_reach(*((l->left))), treap_reach(*((l->right))))))); 
            assume $non_null($phys_ptr_cast(L#l, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(L#l, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(L#l, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(l), ==(treap_keys(l), @_vcc_intset_union(@_vcc_intset_singleton(*((l->key))), @_vcc_intset_union(treap_keys(*((l->left))), treap_keys(*((l->right))))))); 
            assume $non_null($phys_ptr_cast(L#l, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(L#l, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(L#l, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(l), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((l->left))), @_vcc_ptr_neq_null(*((l->right)))), ==(treap_max_key(l), @\int_max(*((l->key)), @\int_max(treap_max_key(*((l->left))), treap_max_key(*((l->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((l->left))), @_vcc_ptr_eq_null(*((l->right)))), ==(treap_max_key(l), @\int_max(*((l->key)), treap_max_key(*((l->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((l->left))), @_vcc_ptr_neq_null(*((l->right)))), ==(treap_max_key(l), @\int_max(*((l->key)), treap_max_key(*((l->right)))))))); 
            assume $non_null($phys_ptr_cast(L#l, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#l, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#l, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#l, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#l, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#l, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#l, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(l), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((l->left))), @_vcc_ptr_neq_null(*((l->right)))), ==(treap_max_prio(l), @\int_max(*((l->prio)), @\int_max(treap_max_prio(*((l->left))), treap_max_prio(*((l->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((l->left))), @_vcc_ptr_eq_null(*((l->right)))), ==(treap_max_prio(l), @\int_max(*((l->prio)), treap_max_prio(*((l->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((l->left))), @_vcc_ptr_neq_null(*((l->right)))), ==(treap_max_prio(l), @\int_max(*((l->prio)), treap_max_prio(*((l->right)))))))); 
            assume $non_null($phys_ptr_cast(L#l, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#l, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#l, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#l, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#l, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#l, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#l, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(l), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((l->left))), @_vcc_ptr_neq_null(*((l->right)))), ==(treap_min_key(l), @\int_min(*((l->key)), @\int_min(treap_min_key(*((l->left))), treap_min_key(*((l->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((l->left))), @_vcc_ptr_eq_null(*((l->right)))), ==(treap_min_key(l), @\int_min(*((l->key)), treap_min_key(*((l->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((l->left))), @_vcc_ptr_neq_null(*((l->right)))), ==(treap_min_key(l), @\int_min(*((l->key)), treap_min_key(*((l->right)))))))); 
            assume $non_null($phys_ptr_cast(L#l, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#l, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#l, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#l, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#l, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#l, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#l, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(l), ==(treap_prios(l), @_vcc_intset_union(@_vcc_intset_singleton(*((l->prio))), @_vcc_intset_union(treap_prios(*((l->left))), treap_prios(*((l->right))))))); 
            assume $non_null($phys_ptr_cast(L#l, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(L#l, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(L#l, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#l, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#l, ^b_node), ^b_node))));
            // return x; 
            $result := $phys_ptr_cast(P#x, ^b_node);
            assume true;
            assert $position_marker();
            goto #exit;
        }
        else
        {
          anon3:
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap(x), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x->left))), treap(*((x->right)))), unchecked!(@_vcc_oset_in(x, @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->key)), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->prio)), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))), @_vcc_oset_disjoint(treap_reach(*((x->left))), treap_reach(*((x->right))))), @_vcc_intset_disjoint(treap_keys(*((x->left))), treap_keys(*((x->right))))), @_vcc_intset_disjoint(treap_prios(*((x->left))), treap_prios(*((x->right))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_key(*((x->left))), *((x->key))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(*((x->key)), treap_min_key(*((x->right)))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_prio(*((x->left))), *((x->prio))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(treap_max_prio(*((x->right))), *((x->prio))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap($s, $phys_ptr_cast(P#x, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(P#x, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_reach(x), @_vcc_oset_union(@_vcc_oset_singleton(x), @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(P#x, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(P#x, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_keys(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->key))), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), @\int_max(treap_max_key(*((x->left))), treap_max_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), @\int_max(treap_max_prio(*((x->left))), treap_max_prio(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), @\int_min(treap_min_key(*((x->left))), treap_min_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_prios(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->prio))), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // struct b_node* r#2; 
            // struct b_node* xr#3; 
            // struct b_node* xl#4; 
            // struct b_node* x0#5; 
            // x0#5 := x; 
            x0#5 := $phys_ptr_cast(P#x, ^b_node);
            // struct b_node* stmtexpr0#14; 
            // stmtexpr0#14 := x0#5; 
            stmtexpr0#14 := $phys_ptr_cast(x0#5, ^b_node);
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap(x), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x->left))), treap(*((x->right)))), unchecked!(@_vcc_oset_in(x, @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->key)), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->prio)), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))), @_vcc_oset_disjoint(treap_reach(*((x->left))), treap_reach(*((x->right))))), @_vcc_intset_disjoint(treap_keys(*((x->left))), treap_keys(*((x->right))))), @_vcc_intset_disjoint(treap_prios(*((x->left))), treap_prios(*((x->right))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_key(*((x->left))), *((x->key))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(*((x->key)), treap_min_key(*((x->right)))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_prio(*((x->left))), *((x->prio))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(treap_max_prio(*((x->right))), *((x->prio))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap($s, $phys_ptr_cast(P#x, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(P#x, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_reach(x), @_vcc_oset_union(@_vcc_oset_singleton(x), @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(P#x, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(P#x, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_keys(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->key))), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), @\int_max(treap_max_key(*((x->left))), treap_max_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), @\int_max(treap_max_prio(*((x->left))), treap_max_prio(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), @\int_min(treap_min_key(*((x->left))), treap_min_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_prios(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->prio))), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assert @reads_check_normal((x->left)); 
            assert $thread_local($s, $phys_ptr_cast(P#x, ^b_node));
            // xl#4 := *((x->left)); 
            xl#4 := $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node);
            // assume ==>(@_vcc_ptr_neq_null(xl#4), ==(treap(xl#4), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((xl#4->left))), treap(*((xl#4->right)))), unchecked!(@_vcc_oset_in(xl#4, @_vcc_oset_union(treap_reach(*((xl#4->left))), treap_reach(*((xl#4->right))))))), unchecked!(@_vcc_intset_in(*((xl#4->key)), @_vcc_intset_union(treap_keys(*((xl#4->left))), treap_keys(*((xl#4->right))))))), unchecked!(@_vcc_intset_in(*((xl#4->prio)), @_vcc_intset_union(treap_prios(*((xl#4->left))), treap_prios(*((xl#4->right))))))), @_vcc_oset_disjoint(treap_reach(*((xl#4->left))), treap_reach(*((xl#4->right))))), @_vcc_intset_disjoint(treap_keys(*((xl#4->left))), treap_keys(*((xl#4->right))))), @_vcc_intset_disjoint(treap_prios(*((xl#4->left))), treap_prios(*((xl#4->right))))), ==>(@_vcc_ptr_neq_null(*((xl#4->left))), <(treap_max_key(*((xl#4->left))), *((xl#4->key))))), ==>(@_vcc_ptr_neq_null(*((xl#4->right))), <(*((xl#4->key)), treap_min_key(*((xl#4->right)))))), ==>(@_vcc_ptr_neq_null(*((xl#4->left))), <(treap_max_prio(*((xl#4->left))), *((xl#4->prio))))), ==>(@_vcc_ptr_neq_null(*((xl#4->right))), <(treap_max_prio(*((xl#4->right))), *((xl#4->prio))))))); 
            assume $non_null($phys_ptr_cast(xl#4, ^b_node)) ==> F#treap($s, $phys_ptr_cast(xl#4, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(xl#4, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(xl#4, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(xl#4, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(xl#4, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(xl#4, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(xl#4, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(xl#4, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl#4), ==(treap_reach(xl#4), @_vcc_oset_union(@_vcc_oset_singleton(xl#4), @_vcc_oset_union(treap_reach(*((xl#4->left))), treap_reach(*((xl#4->right))))))); 
            assume $non_null($phys_ptr_cast(xl#4, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(xl#4, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(xl#4, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl#4), ==(treap_keys(xl#4), @_vcc_intset_union(@_vcc_intset_singleton(*((xl#4->key))), @_vcc_intset_union(treap_keys(*((xl#4->left))), treap_keys(*((xl#4->right))))))); 
            assume $non_null($phys_ptr_cast(xl#4, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(xl#4, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(xl#4, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl#4), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl#4->left))), @_vcc_ptr_neq_null(*((xl#4->right)))), ==(treap_max_key(xl#4), @\int_max(*((xl#4->key)), @\int_max(treap_max_key(*((xl#4->left))), treap_max_key(*((xl#4->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl#4->left))), @_vcc_ptr_eq_null(*((xl#4->right)))), ==(treap_max_key(xl#4), @\int_max(*((xl#4->key)), treap_max_key(*((xl#4->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl#4->left))), @_vcc_ptr_neq_null(*((xl#4->right)))), ==(treap_max_key(xl#4), @\int_max(*((xl#4->key)), treap_max_key(*((xl#4->right)))))))); 
            assume $non_null($phys_ptr_cast(xl#4, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xl#4, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xl#4, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xl#4, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xl#4, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xl#4, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xl#4, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl#4), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl#4->left))), @_vcc_ptr_neq_null(*((xl#4->right)))), ==(treap_max_prio(xl#4), @\int_max(*((xl#4->prio)), @\int_max(treap_max_prio(*((xl#4->left))), treap_max_prio(*((xl#4->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl#4->left))), @_vcc_ptr_eq_null(*((xl#4->right)))), ==(treap_max_prio(xl#4), @\int_max(*((xl#4->prio)), treap_max_prio(*((xl#4->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl#4->left))), @_vcc_ptr_neq_null(*((xl#4->right)))), ==(treap_max_prio(xl#4), @\int_max(*((xl#4->prio)), treap_max_prio(*((xl#4->right)))))))); 
            assume $non_null($phys_ptr_cast(xl#4, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xl#4, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xl#4, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xl#4, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xl#4, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xl#4, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xl#4, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl#4), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl#4->left))), @_vcc_ptr_neq_null(*((xl#4->right)))), ==(treap_min_key(xl#4), @\int_min(*((xl#4->key)), @\int_min(treap_min_key(*((xl#4->left))), treap_min_key(*((xl#4->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl#4->left))), @_vcc_ptr_eq_null(*((xl#4->right)))), ==(treap_min_key(xl#4), @\int_min(*((xl#4->key)), treap_min_key(*((xl#4->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl#4->left))), @_vcc_ptr_neq_null(*((xl#4->right)))), ==(treap_min_key(xl#4), @\int_min(*((xl#4->key)), treap_min_key(*((xl#4->right)))))))); 
            assume $non_null($phys_ptr_cast(xl#4, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xl#4, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xl#4, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xl#4, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xl#4, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xl#4, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xl#4, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl#4), ==(treap_prios(xl#4), @_vcc_intset_union(@_vcc_intset_singleton(*((xl#4->prio))), @_vcc_intset_union(treap_prios(*((xl#4->left))), treap_prios(*((xl#4->right))))))); 
            assume $non_null($phys_ptr_cast(xl#4, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(xl#4, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(xl#4, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap(x), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x->left))), treap(*((x->right)))), unchecked!(@_vcc_oset_in(x, @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->key)), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->prio)), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))), @_vcc_oset_disjoint(treap_reach(*((x->left))), treap_reach(*((x->right))))), @_vcc_intset_disjoint(treap_keys(*((x->left))), treap_keys(*((x->right))))), @_vcc_intset_disjoint(treap_prios(*((x->left))), treap_prios(*((x->right))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_key(*((x->left))), *((x->key))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(*((x->key)), treap_min_key(*((x->right)))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_prio(*((x->left))), *((x->prio))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(treap_max_prio(*((x->right))), *((x->prio))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap($s, $phys_ptr_cast(P#x, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(P#x, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_reach(x), @_vcc_oset_union(@_vcc_oset_singleton(x), @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(P#x, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(P#x, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_keys(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->key))), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), @\int_max(treap_max_key(*((x->left))), treap_max_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), @\int_max(treap_max_prio(*((x->left))), treap_max_prio(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), @\int_min(treap_min_key(*((x->left))), treap_min_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_prios(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->prio))), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // struct b_node* x1#6; 
            // x1#6 := x; 
            x1#6 := $phys_ptr_cast(P#x, ^b_node);
            // struct b_node* stmtexpr1#15; 
            // stmtexpr1#15 := x1#6; 
            stmtexpr1#15 := $phys_ptr_cast(x1#6, ^b_node);
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap(x), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x->left))), treap(*((x->right)))), unchecked!(@_vcc_oset_in(x, @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->key)), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->prio)), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))), @_vcc_oset_disjoint(treap_reach(*((x->left))), treap_reach(*((x->right))))), @_vcc_intset_disjoint(treap_keys(*((x->left))), treap_keys(*((x->right))))), @_vcc_intset_disjoint(treap_prios(*((x->left))), treap_prios(*((x->right))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_key(*((x->left))), *((x->key))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(*((x->key)), treap_min_key(*((x->right)))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_prio(*((x->left))), *((x->prio))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(treap_max_prio(*((x->right))), *((x->prio))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap($s, $phys_ptr_cast(P#x, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(P#x, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_reach(x), @_vcc_oset_union(@_vcc_oset_singleton(x), @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(P#x, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(P#x, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_keys(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->key))), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), @\int_max(treap_max_key(*((x->left))), treap_max_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), @\int_max(treap_max_prio(*((x->left))), treap_max_prio(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), @\int_min(treap_min_key(*((x->left))), treap_min_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_prios(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->prio))), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assert @reads_check_normal((x->right)); 
            assert $thread_local($s, $phys_ptr_cast(P#x, ^b_node));
            // xr#3 := *((x->right)); 
            xr#3 := $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node);
            // assume ==>(@_vcc_ptr_neq_null(xr#3), ==(treap(xr#3), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((xr#3->left))), treap(*((xr#3->right)))), unchecked!(@_vcc_oset_in(xr#3, @_vcc_oset_union(treap_reach(*((xr#3->left))), treap_reach(*((xr#3->right))))))), unchecked!(@_vcc_intset_in(*((xr#3->key)), @_vcc_intset_union(treap_keys(*((xr#3->left))), treap_keys(*((xr#3->right))))))), unchecked!(@_vcc_intset_in(*((xr#3->prio)), @_vcc_intset_union(treap_prios(*((xr#3->left))), treap_prios(*((xr#3->right))))))), @_vcc_oset_disjoint(treap_reach(*((xr#3->left))), treap_reach(*((xr#3->right))))), @_vcc_intset_disjoint(treap_keys(*((xr#3->left))), treap_keys(*((xr#3->right))))), @_vcc_intset_disjoint(treap_prios(*((xr#3->left))), treap_prios(*((xr#3->right))))), ==>(@_vcc_ptr_neq_null(*((xr#3->left))), <(treap_max_key(*((xr#3->left))), *((xr#3->key))))), ==>(@_vcc_ptr_neq_null(*((xr#3->right))), <(*((xr#3->key)), treap_min_key(*((xr#3->right)))))), ==>(@_vcc_ptr_neq_null(*((xr#3->left))), <(treap_max_prio(*((xr#3->left))), *((xr#3->prio))))), ==>(@_vcc_ptr_neq_null(*((xr#3->right))), <(treap_max_prio(*((xr#3->right))), *((xr#3->prio))))))); 
            assume $non_null($phys_ptr_cast(xr#3, ^b_node)) ==> F#treap($s, $phys_ptr_cast(xr#3, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(xr#3, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(xr#3, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(xr#3, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(xr#3, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(xr#3, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(xr#3, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(xr#3, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr#3), ==(treap_reach(xr#3), @_vcc_oset_union(@_vcc_oset_singleton(xr#3), @_vcc_oset_union(treap_reach(*((xr#3->left))), treap_reach(*((xr#3->right))))))); 
            assume $non_null($phys_ptr_cast(xr#3, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(xr#3, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(xr#3, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr#3), ==(treap_keys(xr#3), @_vcc_intset_union(@_vcc_intset_singleton(*((xr#3->key))), @_vcc_intset_union(treap_keys(*((xr#3->left))), treap_keys(*((xr#3->right))))))); 
            assume $non_null($phys_ptr_cast(xr#3, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(xr#3, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(xr#3, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr#3), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr#3->left))), @_vcc_ptr_neq_null(*((xr#3->right)))), ==(treap_max_key(xr#3), @\int_max(*((xr#3->key)), @\int_max(treap_max_key(*((xr#3->left))), treap_max_key(*((xr#3->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr#3->left))), @_vcc_ptr_eq_null(*((xr#3->right)))), ==(treap_max_key(xr#3), @\int_max(*((xr#3->key)), treap_max_key(*((xr#3->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr#3->left))), @_vcc_ptr_neq_null(*((xr#3->right)))), ==(treap_max_key(xr#3), @\int_max(*((xr#3->key)), treap_max_key(*((xr#3->right)))))))); 
            assume $non_null($phys_ptr_cast(xr#3, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xr#3, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xr#3, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xr#3, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xr#3, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xr#3, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xr#3, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr#3), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr#3->left))), @_vcc_ptr_neq_null(*((xr#3->right)))), ==(treap_max_prio(xr#3), @\int_max(*((xr#3->prio)), @\int_max(treap_max_prio(*((xr#3->left))), treap_max_prio(*((xr#3->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr#3->left))), @_vcc_ptr_eq_null(*((xr#3->right)))), ==(treap_max_prio(xr#3), @\int_max(*((xr#3->prio)), treap_max_prio(*((xr#3->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr#3->left))), @_vcc_ptr_neq_null(*((xr#3->right)))), ==(treap_max_prio(xr#3), @\int_max(*((xr#3->prio)), treap_max_prio(*((xr#3->right)))))))); 
            assume $non_null($phys_ptr_cast(xr#3, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xr#3, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xr#3, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xr#3, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xr#3, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xr#3, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xr#3, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr#3), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr#3->left))), @_vcc_ptr_neq_null(*((xr#3->right)))), ==(treap_min_key(xr#3), @\int_min(*((xr#3->key)), @\int_min(treap_min_key(*((xr#3->left))), treap_min_key(*((xr#3->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr#3->left))), @_vcc_ptr_eq_null(*((xr#3->right)))), ==(treap_min_key(xr#3), @\int_min(*((xr#3->key)), treap_min_key(*((xr#3->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr#3->left))), @_vcc_ptr_neq_null(*((xr#3->right)))), ==(treap_min_key(xr#3), @\int_min(*((xr#3->key)), treap_min_key(*((xr#3->right)))))))); 
            assume $non_null($phys_ptr_cast(xr#3, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xr#3, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xr#3, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xr#3, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xr#3, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xr#3, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xr#3, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr#3), ==(treap_prios(xr#3), @_vcc_intset_union(@_vcc_intset_singleton(*((xr#3->prio))), @_vcc_intset_union(treap_prios(*((xr#3->left))), treap_prios(*((xr#3->right))))))); 
            assume $non_null($phys_ptr_cast(xr#3, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(xr#3, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(xr#3, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap(x), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x->left))), treap(*((x->right)))), unchecked!(@_vcc_oset_in(x, @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->key)), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->prio)), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))), @_vcc_oset_disjoint(treap_reach(*((x->left))), treap_reach(*((x->right))))), @_vcc_intset_disjoint(treap_keys(*((x->left))), treap_keys(*((x->right))))), @_vcc_intset_disjoint(treap_prios(*((x->left))), treap_prios(*((x->right))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_key(*((x->left))), *((x->key))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(*((x->key)), treap_min_key(*((x->right)))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_prio(*((x->left))), *((x->prio))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(treap_max_prio(*((x->right))), *((x->prio))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap($s, $phys_ptr_cast(P#x, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(P#x, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_reach(x), @_vcc_oset_union(@_vcc_oset_singleton(x), @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(P#x, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(P#x, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_keys(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->key))), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), @\int_max(treap_max_key(*((x->left))), treap_max_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), @\int_max(treap_max_prio(*((x->left))), treap_max_prio(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), @\int_min(treap_min_key(*((x->left))), treap_min_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_prios(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->prio))), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // _math \state _dryad_S0#7; 
            // _dryad_S0#7 := @_vcc_current_state(@state); 
            _dryad_S0#7 := $current_state($s);
            // _math \state stmtexpr2#16; 
            // stmtexpr2#16 := _dryad_S0#7; 
            stmtexpr2#16 := _dryad_S0#7;
            // non-pure function
            // r#2 := treap_delete_rec(xr#3, k); 
            call r#2 := treap_delete_rec($phys_ptr_cast(xr#3, ^b_node), P#k);
            assume $full_stop_ext(#tok$3^56.17, $s);
            // _math \state _dryad_S1#8; 
            // _dryad_S1#8 := @_vcc_current_state(@state); 
            _dryad_S1#8 := $current_state($s);
            // _math \state stmtexpr3#17; 
            // stmtexpr3#17 := _dryad_S1#8; 
            stmtexpr3#17 := _dryad_S1#8;
            // assume @_vcc_oset_disjoint(treap_reach(r#2), @_vcc_oset_diff(_dryad_G1, old(_dryad_S0#7, treap_reach(xr#3)))); 
            assume $oset_disjoint(F#treap_reach($s, $phys_ptr_cast(r#2, ^b_node)), $oset_diff(SL#_dryad_G1, F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node))));
            // _math \oset res_treap_reach#3; 
            // res_treap_reach#3 := treap_reach(r#2); 
            call res_treap_reach#3 := treap_reach($phys_ptr_cast(r#2, ^b_node));
            assume $full_stop_ext(#tok$4^0.0, $s);
            // _dryad_G1 := @_vcc_oset_union(res_treap_reach#3, @_vcc_oset_diff(_dryad_G1, pure(old(_dryad_S0#7, treap_reach(xr#3))))); 
            SL#_dryad_G1 := $oset_union(res_treap_reach#3, $oset_diff(SL#_dryad_G1, F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node))));
            // _math \oset stmtexpr4#18; 
            // stmtexpr4#18 := _dryad_G1; 
            stmtexpr4#18 := SL#_dryad_G1;
            // assume ==(glob_reach(), _dryad_G1); 
            assume F#glob_reach() == SL#_dryad_G1;
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#7, treap_reach(xr#3)), old(_dryad_S0#7, treap_reach(x1#6))), ==(old(_dryad_S0#7, treap(x1#6)), old(_dryad_S1#8, treap(x1#6)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node)), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(x1#6, ^b_node))) ==> F#treap(_dryad_S0#7, $phys_ptr_cast(x1#6, ^b_node)) == F#treap(_dryad_S1#8, $phys_ptr_cast(x1#6, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#7, treap_reach(xr#3)), old(_dryad_S0#7, treap_reach(x1#6))), ==(old(_dryad_S0#7, treap_reach(x1#6)), old(_dryad_S1#8, treap_reach(x1#6)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node)), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(x1#6, ^b_node))) ==> F#treap_reach(_dryad_S0#7, $phys_ptr_cast(x1#6, ^b_node)) == F#treap_reach(_dryad_S1#8, $phys_ptr_cast(x1#6, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#7, treap_reach(xr#3)), old(_dryad_S0#7, treap_reach(x1#6))), ==(old(_dryad_S0#7, treap_keys(x1#6)), old(_dryad_S1#8, treap_keys(x1#6)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node)), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(x1#6, ^b_node))) ==> F#treap_keys(_dryad_S0#7, $phys_ptr_cast(x1#6, ^b_node)) == F#treap_keys(_dryad_S1#8, $phys_ptr_cast(x1#6, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#7, treap_reach(xr#3)), old(_dryad_S0#7, treap_reach(x1#6))), ==(old(_dryad_S0#7, treap_max_key(x1#6)), old(_dryad_S1#8, treap_max_key(x1#6)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node)), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(x1#6, ^b_node))) ==> F#treap_max_key(_dryad_S0#7, $phys_ptr_cast(x1#6, ^b_node)) == F#treap_max_key(_dryad_S1#8, $phys_ptr_cast(x1#6, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#7, treap_reach(xr#3)), old(_dryad_S0#7, treap_reach(x1#6))), ==(old(_dryad_S0#7, treap_max_prio(x1#6)), old(_dryad_S1#8, treap_max_prio(x1#6)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node)), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(x1#6, ^b_node))) ==> F#treap_max_prio(_dryad_S0#7, $phys_ptr_cast(x1#6, ^b_node)) == F#treap_max_prio(_dryad_S1#8, $phys_ptr_cast(x1#6, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#7, treap_reach(xr#3)), old(_dryad_S0#7, treap_reach(x1#6))), ==(old(_dryad_S0#7, treap_min_key(x1#6)), old(_dryad_S1#8, treap_min_key(x1#6)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node)), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(x1#6, ^b_node))) ==> F#treap_min_key(_dryad_S0#7, $phys_ptr_cast(x1#6, ^b_node)) == F#treap_min_key(_dryad_S1#8, $phys_ptr_cast(x1#6, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#7, treap_reach(xr#3)), old(_dryad_S0#7, treap_reach(x1#6))), ==(old(_dryad_S0#7, treap_prios(x1#6)), old(_dryad_S1#8, treap_prios(x1#6)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node)), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(x1#6, ^b_node))) ==> F#treap_prios(_dryad_S0#7, $phys_ptr_cast(x1#6, ^b_node)) == F#treap_prios(_dryad_S1#8, $phys_ptr_cast(x1#6, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#7, treap_reach(xr#3)), old(_dryad_S0#7, treap_reach(x0#5))), ==(old(_dryad_S0#7, treap(x0#5)), old(_dryad_S1#8, treap(x0#5)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node)), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(x0#5, ^b_node))) ==> F#treap(_dryad_S0#7, $phys_ptr_cast(x0#5, ^b_node)) == F#treap(_dryad_S1#8, $phys_ptr_cast(x0#5, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#7, treap_reach(xr#3)), old(_dryad_S0#7, treap_reach(x0#5))), ==(old(_dryad_S0#7, treap_reach(x0#5)), old(_dryad_S1#8, treap_reach(x0#5)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node)), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(x0#5, ^b_node))) ==> F#treap_reach(_dryad_S0#7, $phys_ptr_cast(x0#5, ^b_node)) == F#treap_reach(_dryad_S1#8, $phys_ptr_cast(x0#5, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#7, treap_reach(xr#3)), old(_dryad_S0#7, treap_reach(x0#5))), ==(old(_dryad_S0#7, treap_keys(x0#5)), old(_dryad_S1#8, treap_keys(x0#5)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node)), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(x0#5, ^b_node))) ==> F#treap_keys(_dryad_S0#7, $phys_ptr_cast(x0#5, ^b_node)) == F#treap_keys(_dryad_S1#8, $phys_ptr_cast(x0#5, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#7, treap_reach(xr#3)), old(_dryad_S0#7, treap_reach(x0#5))), ==(old(_dryad_S0#7, treap_max_key(x0#5)), old(_dryad_S1#8, treap_max_key(x0#5)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node)), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(x0#5, ^b_node))) ==> F#treap_max_key(_dryad_S0#7, $phys_ptr_cast(x0#5, ^b_node)) == F#treap_max_key(_dryad_S1#8, $phys_ptr_cast(x0#5, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#7, treap_reach(xr#3)), old(_dryad_S0#7, treap_reach(x0#5))), ==(old(_dryad_S0#7, treap_max_prio(x0#5)), old(_dryad_S1#8, treap_max_prio(x0#5)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node)), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(x0#5, ^b_node))) ==> F#treap_max_prio(_dryad_S0#7, $phys_ptr_cast(x0#5, ^b_node)) == F#treap_max_prio(_dryad_S1#8, $phys_ptr_cast(x0#5, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#7, treap_reach(xr#3)), old(_dryad_S0#7, treap_reach(x0#5))), ==(old(_dryad_S0#7, treap_min_key(x0#5)), old(_dryad_S1#8, treap_min_key(x0#5)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node)), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(x0#5, ^b_node))) ==> F#treap_min_key(_dryad_S0#7, $phys_ptr_cast(x0#5, ^b_node)) == F#treap_min_key(_dryad_S1#8, $phys_ptr_cast(x0#5, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#7, treap_reach(xr#3)), old(_dryad_S0#7, treap_reach(x0#5))), ==(old(_dryad_S0#7, treap_prios(x0#5)), old(_dryad_S1#8, treap_prios(x0#5)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node)), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(x0#5, ^b_node))) ==> F#treap_prios(_dryad_S0#7, $phys_ptr_cast(x0#5, ^b_node)) == F#treap_prios(_dryad_S1#8, $phys_ptr_cast(x0#5, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#7, treap_reach(xr#3)), old(_dryad_S0#7, treap_reach(xl#4))), ==(old(_dryad_S0#7, treap(xl#4)), old(_dryad_S1#8, treap(xl#4)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node)), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xl#4, ^b_node))) ==> F#treap(_dryad_S0#7, $phys_ptr_cast(xl#4, ^b_node)) == F#treap(_dryad_S1#8, $phys_ptr_cast(xl#4, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#7, treap_reach(xr#3)), old(_dryad_S0#7, treap_reach(xl#4))), ==(old(_dryad_S0#7, treap_reach(xl#4)), old(_dryad_S1#8, treap_reach(xl#4)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node)), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xl#4, ^b_node))) ==> F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xl#4, ^b_node)) == F#treap_reach(_dryad_S1#8, $phys_ptr_cast(xl#4, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#7, treap_reach(xr#3)), old(_dryad_S0#7, treap_reach(xl#4))), ==(old(_dryad_S0#7, treap_keys(xl#4)), old(_dryad_S1#8, treap_keys(xl#4)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node)), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xl#4, ^b_node))) ==> F#treap_keys(_dryad_S0#7, $phys_ptr_cast(xl#4, ^b_node)) == F#treap_keys(_dryad_S1#8, $phys_ptr_cast(xl#4, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#7, treap_reach(xr#3)), old(_dryad_S0#7, treap_reach(xl#4))), ==(old(_dryad_S0#7, treap_max_key(xl#4)), old(_dryad_S1#8, treap_max_key(xl#4)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node)), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xl#4, ^b_node))) ==> F#treap_max_key(_dryad_S0#7, $phys_ptr_cast(xl#4, ^b_node)) == F#treap_max_key(_dryad_S1#8, $phys_ptr_cast(xl#4, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#7, treap_reach(xr#3)), old(_dryad_S0#7, treap_reach(xl#4))), ==(old(_dryad_S0#7, treap_max_prio(xl#4)), old(_dryad_S1#8, treap_max_prio(xl#4)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node)), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xl#4, ^b_node))) ==> F#treap_max_prio(_dryad_S0#7, $phys_ptr_cast(xl#4, ^b_node)) == F#treap_max_prio(_dryad_S1#8, $phys_ptr_cast(xl#4, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#7, treap_reach(xr#3)), old(_dryad_S0#7, treap_reach(xl#4))), ==(old(_dryad_S0#7, treap_min_key(xl#4)), old(_dryad_S1#8, treap_min_key(xl#4)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node)), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xl#4, ^b_node))) ==> F#treap_min_key(_dryad_S0#7, $phys_ptr_cast(xl#4, ^b_node)) == F#treap_min_key(_dryad_S1#8, $phys_ptr_cast(xl#4, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#7, treap_reach(xr#3)), old(_dryad_S0#7, treap_reach(xl#4))), ==(old(_dryad_S0#7, treap_prios(xl#4)), old(_dryad_S1#8, treap_prios(xl#4)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node)), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xl#4, ^b_node))) ==> F#treap_prios(_dryad_S0#7, $phys_ptr_cast(xl#4, ^b_node)) == F#treap_prios(_dryad_S1#8, $phys_ptr_cast(xl#4, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#7, treap_reach(xr#3)), old(_dryad_S0#7, treap_reach(xr#3))), ==(old(_dryad_S0#7, treap(xr#3)), old(_dryad_S1#8, treap(xr#3)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node)), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node))) ==> F#treap(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node)) == F#treap(_dryad_S1#8, $phys_ptr_cast(xr#3, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#7, treap_reach(xr#3)), old(_dryad_S0#7, treap_reach(xr#3))), ==(old(_dryad_S0#7, treap_reach(xr#3)), old(_dryad_S1#8, treap_reach(xr#3)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node)), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node))) ==> F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node)) == F#treap_reach(_dryad_S1#8, $phys_ptr_cast(xr#3, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#7, treap_reach(xr#3)), old(_dryad_S0#7, treap_reach(xr#3))), ==(old(_dryad_S0#7, treap_keys(xr#3)), old(_dryad_S1#8, treap_keys(xr#3)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node)), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node))) ==> F#treap_keys(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node)) == F#treap_keys(_dryad_S1#8, $phys_ptr_cast(xr#3, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#7, treap_reach(xr#3)), old(_dryad_S0#7, treap_reach(xr#3))), ==(old(_dryad_S0#7, treap_max_key(xr#3)), old(_dryad_S1#8, treap_max_key(xr#3)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node)), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node))) ==> F#treap_max_key(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node)) == F#treap_max_key(_dryad_S1#8, $phys_ptr_cast(xr#3, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#7, treap_reach(xr#3)), old(_dryad_S0#7, treap_reach(xr#3))), ==(old(_dryad_S0#7, treap_max_prio(xr#3)), old(_dryad_S1#8, treap_max_prio(xr#3)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node)), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node))) ==> F#treap_max_prio(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node)) == F#treap_max_prio(_dryad_S1#8, $phys_ptr_cast(xr#3, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#7, treap_reach(xr#3)), old(_dryad_S0#7, treap_reach(xr#3))), ==(old(_dryad_S0#7, treap_min_key(xr#3)), old(_dryad_S1#8, treap_min_key(xr#3)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node)), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node))) ==> F#treap_min_key(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node)) == F#treap_min_key(_dryad_S1#8, $phys_ptr_cast(xr#3, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#7, treap_reach(xr#3)), old(_dryad_S0#7, treap_reach(xr#3))), ==(old(_dryad_S0#7, treap_prios(xr#3)), old(_dryad_S1#8, treap_prios(xr#3)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node)), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node))) ==> F#treap_prios(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node)) == F#treap_prios(_dryad_S1#8, $phys_ptr_cast(xr#3, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#7, treap_reach(xr#3)), old(_dryad_S0#7, treap_reach(x))), ==(old(_dryad_S0#7, treap(x)), old(_dryad_S1#8, treap(x)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node)), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap(_dryad_S0#7, $phys_ptr_cast(P#x, ^b_node)) == F#treap(_dryad_S1#8, $phys_ptr_cast(P#x, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#7, treap_reach(xr#3)), old(_dryad_S0#7, treap_reach(x))), ==(old(_dryad_S0#7, treap_reach(x)), old(_dryad_S1#8, treap_reach(x)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node)), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_reach(_dryad_S0#7, $phys_ptr_cast(P#x, ^b_node)) == F#treap_reach(_dryad_S1#8, $phys_ptr_cast(P#x, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#7, treap_reach(xr#3)), old(_dryad_S0#7, treap_reach(x))), ==(old(_dryad_S0#7, treap_keys(x)), old(_dryad_S1#8, treap_keys(x)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node)), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_keys(_dryad_S0#7, $phys_ptr_cast(P#x, ^b_node)) == F#treap_keys(_dryad_S1#8, $phys_ptr_cast(P#x, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#7, treap_reach(xr#3)), old(_dryad_S0#7, treap_reach(x))), ==(old(_dryad_S0#7, treap_max_key(x)), old(_dryad_S1#8, treap_max_key(x)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node)), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_max_key(_dryad_S0#7, $phys_ptr_cast(P#x, ^b_node)) == F#treap_max_key(_dryad_S1#8, $phys_ptr_cast(P#x, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#7, treap_reach(xr#3)), old(_dryad_S0#7, treap_reach(x))), ==(old(_dryad_S0#7, treap_max_prio(x)), old(_dryad_S1#8, treap_max_prio(x)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node)), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_max_prio(_dryad_S0#7, $phys_ptr_cast(P#x, ^b_node)) == F#treap_max_prio(_dryad_S1#8, $phys_ptr_cast(P#x, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#7, treap_reach(xr#3)), old(_dryad_S0#7, treap_reach(x))), ==(old(_dryad_S0#7, treap_min_key(x)), old(_dryad_S1#8, treap_min_key(x)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node)), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_min_key(_dryad_S0#7, $phys_ptr_cast(P#x, ^b_node)) == F#treap_min_key(_dryad_S1#8, $phys_ptr_cast(P#x, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#7, treap_reach(xr#3)), old(_dryad_S0#7, treap_reach(x))), ==(old(_dryad_S0#7, treap_prios(x)), old(_dryad_S1#8, treap_prios(x)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node)), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_prios(_dryad_S0#7, $phys_ptr_cast(P#x, ^b_node)) == F#treap_prios(_dryad_S1#8, $phys_ptr_cast(P#x, ^b_node));
            // assume ==>(@_vcc_ptr_neq_null(x1#6), ==(treap(x1#6), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x1#6->left))), treap(*((x1#6->right)))), unchecked!(@_vcc_oset_in(x1#6, @_vcc_oset_union(treap_reach(*((x1#6->left))), treap_reach(*((x1#6->right))))))), unchecked!(@_vcc_intset_in(*((x1#6->key)), @_vcc_intset_union(treap_keys(*((x1#6->left))), treap_keys(*((x1#6->right))))))), unchecked!(@_vcc_intset_in(*((x1#6->prio)), @_vcc_intset_union(treap_prios(*((x1#6->left))), treap_prios(*((x1#6->right))))))), @_vcc_oset_disjoint(treap_reach(*((x1#6->left))), treap_reach(*((x1#6->right))))), @_vcc_intset_disjoint(treap_keys(*((x1#6->left))), treap_keys(*((x1#6->right))))), @_vcc_intset_disjoint(treap_prios(*((x1#6->left))), treap_prios(*((x1#6->right))))), ==>(@_vcc_ptr_neq_null(*((x1#6->left))), <(treap_max_key(*((x1#6->left))), *((x1#6->key))))), ==>(@_vcc_ptr_neq_null(*((x1#6->right))), <(*((x1#6->key)), treap_min_key(*((x1#6->right)))))), ==>(@_vcc_ptr_neq_null(*((x1#6->left))), <(treap_max_prio(*((x1#6->left))), *((x1#6->prio))))), ==>(@_vcc_ptr_neq_null(*((x1#6->right))), <(treap_max_prio(*((x1#6->right))), *((x1#6->prio))))))); 
            assume $non_null($phys_ptr_cast(x1#6, ^b_node)) ==> F#treap($s, $phys_ptr_cast(x1#6, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(x1#6, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(x1#6, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(x1#6, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(x1#6, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(x1#6, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(x1#6, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(x1#6, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x1#6), ==(treap_reach(x1#6), @_vcc_oset_union(@_vcc_oset_singleton(x1#6), @_vcc_oset_union(treap_reach(*((x1#6->left))), treap_reach(*((x1#6->right))))))); 
            assume $non_null($phys_ptr_cast(x1#6, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(x1#6, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(x1#6, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x1#6), ==(treap_keys(x1#6), @_vcc_intset_union(@_vcc_intset_singleton(*((x1#6->key))), @_vcc_intset_union(treap_keys(*((x1#6->left))), treap_keys(*((x1#6->right))))))); 
            assume $non_null($phys_ptr_cast(x1#6, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(x1#6, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(x1#6, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x1#6), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x1#6->left))), @_vcc_ptr_neq_null(*((x1#6->right)))), ==(treap_max_key(x1#6), @\int_max(*((x1#6->key)), @\int_max(treap_max_key(*((x1#6->left))), treap_max_key(*((x1#6->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x1#6->left))), @_vcc_ptr_eq_null(*((x1#6->right)))), ==(treap_max_key(x1#6), @\int_max(*((x1#6->key)), treap_max_key(*((x1#6->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x1#6->left))), @_vcc_ptr_neq_null(*((x1#6->right)))), ==(treap_max_key(x1#6), @\int_max(*((x1#6->key)), treap_max_key(*((x1#6->right)))))))); 
            assume $non_null($phys_ptr_cast(x1#6, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(x1#6, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(x1#6, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(x1#6, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(x1#6, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(x1#6, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(x1#6, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x1#6), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x1#6->left))), @_vcc_ptr_neq_null(*((x1#6->right)))), ==(treap_max_prio(x1#6), @\int_max(*((x1#6->prio)), @\int_max(treap_max_prio(*((x1#6->left))), treap_max_prio(*((x1#6->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x1#6->left))), @_vcc_ptr_eq_null(*((x1#6->right)))), ==(treap_max_prio(x1#6), @\int_max(*((x1#6->prio)), treap_max_prio(*((x1#6->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x1#6->left))), @_vcc_ptr_neq_null(*((x1#6->right)))), ==(treap_max_prio(x1#6), @\int_max(*((x1#6->prio)), treap_max_prio(*((x1#6->right)))))))); 
            assume $non_null($phys_ptr_cast(x1#6, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(x1#6, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(x1#6, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(x1#6, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(x1#6, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(x1#6, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(x1#6, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x1#6), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x1#6->left))), @_vcc_ptr_neq_null(*((x1#6->right)))), ==(treap_min_key(x1#6), @\int_min(*((x1#6->key)), @\int_min(treap_min_key(*((x1#6->left))), treap_min_key(*((x1#6->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x1#6->left))), @_vcc_ptr_eq_null(*((x1#6->right)))), ==(treap_min_key(x1#6), @\int_min(*((x1#6->key)), treap_min_key(*((x1#6->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x1#6->left))), @_vcc_ptr_neq_null(*((x1#6->right)))), ==(treap_min_key(x1#6), @\int_min(*((x1#6->key)), treap_min_key(*((x1#6->right)))))))); 
            assume $non_null($phys_ptr_cast(x1#6, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(x1#6, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(x1#6, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(x1#6, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(x1#6, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(x1#6, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(x1#6, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x1#6), ==(treap_prios(x1#6), @_vcc_intset_union(@_vcc_intset_singleton(*((x1#6->prio))), @_vcc_intset_union(treap_prios(*((x1#6->left))), treap_prios(*((x1#6->right))))))); 
            assume $non_null($phys_ptr_cast(x1#6, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(x1#6, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(x1#6, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x0#5), ==(treap(x0#5), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x0#5->left))), treap(*((x0#5->right)))), unchecked!(@_vcc_oset_in(x0#5, @_vcc_oset_union(treap_reach(*((x0#5->left))), treap_reach(*((x0#5->right))))))), unchecked!(@_vcc_intset_in(*((x0#5->key)), @_vcc_intset_union(treap_keys(*((x0#5->left))), treap_keys(*((x0#5->right))))))), unchecked!(@_vcc_intset_in(*((x0#5->prio)), @_vcc_intset_union(treap_prios(*((x0#5->left))), treap_prios(*((x0#5->right))))))), @_vcc_oset_disjoint(treap_reach(*((x0#5->left))), treap_reach(*((x0#5->right))))), @_vcc_intset_disjoint(treap_keys(*((x0#5->left))), treap_keys(*((x0#5->right))))), @_vcc_intset_disjoint(treap_prios(*((x0#5->left))), treap_prios(*((x0#5->right))))), ==>(@_vcc_ptr_neq_null(*((x0#5->left))), <(treap_max_key(*((x0#5->left))), *((x0#5->key))))), ==>(@_vcc_ptr_neq_null(*((x0#5->right))), <(*((x0#5->key)), treap_min_key(*((x0#5->right)))))), ==>(@_vcc_ptr_neq_null(*((x0#5->left))), <(treap_max_prio(*((x0#5->left))), *((x0#5->prio))))), ==>(@_vcc_ptr_neq_null(*((x0#5->right))), <(treap_max_prio(*((x0#5->right))), *((x0#5->prio))))))); 
            assume $non_null($phys_ptr_cast(x0#5, ^b_node)) ==> F#treap($s, $phys_ptr_cast(x0#5, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(x0#5, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(x0#5, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(x0#5, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(x0#5, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(x0#5, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(x0#5, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(x0#5, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x0#5), ==(treap_reach(x0#5), @_vcc_oset_union(@_vcc_oset_singleton(x0#5), @_vcc_oset_union(treap_reach(*((x0#5->left))), treap_reach(*((x0#5->right))))))); 
            assume $non_null($phys_ptr_cast(x0#5, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(x0#5, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(x0#5, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x0#5), ==(treap_keys(x0#5), @_vcc_intset_union(@_vcc_intset_singleton(*((x0#5->key))), @_vcc_intset_union(treap_keys(*((x0#5->left))), treap_keys(*((x0#5->right))))))); 
            assume $non_null($phys_ptr_cast(x0#5, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(x0#5, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(x0#5, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x0#5), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x0#5->left))), @_vcc_ptr_neq_null(*((x0#5->right)))), ==(treap_max_key(x0#5), @\int_max(*((x0#5->key)), @\int_max(treap_max_key(*((x0#5->left))), treap_max_key(*((x0#5->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x0#5->left))), @_vcc_ptr_eq_null(*((x0#5->right)))), ==(treap_max_key(x0#5), @\int_max(*((x0#5->key)), treap_max_key(*((x0#5->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x0#5->left))), @_vcc_ptr_neq_null(*((x0#5->right)))), ==(treap_max_key(x0#5), @\int_max(*((x0#5->key)), treap_max_key(*((x0#5->right)))))))); 
            assume $non_null($phys_ptr_cast(x0#5, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(x0#5, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(x0#5, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(x0#5, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(x0#5, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(x0#5, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(x0#5, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x0#5), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x0#5->left))), @_vcc_ptr_neq_null(*((x0#5->right)))), ==(treap_max_prio(x0#5), @\int_max(*((x0#5->prio)), @\int_max(treap_max_prio(*((x0#5->left))), treap_max_prio(*((x0#5->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x0#5->left))), @_vcc_ptr_eq_null(*((x0#5->right)))), ==(treap_max_prio(x0#5), @\int_max(*((x0#5->prio)), treap_max_prio(*((x0#5->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x0#5->left))), @_vcc_ptr_neq_null(*((x0#5->right)))), ==(treap_max_prio(x0#5), @\int_max(*((x0#5->prio)), treap_max_prio(*((x0#5->right)))))))); 
            assume $non_null($phys_ptr_cast(x0#5, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(x0#5, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(x0#5, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(x0#5, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(x0#5, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(x0#5, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(x0#5, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x0#5), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x0#5->left))), @_vcc_ptr_neq_null(*((x0#5->right)))), ==(treap_min_key(x0#5), @\int_min(*((x0#5->key)), @\int_min(treap_min_key(*((x0#5->left))), treap_min_key(*((x0#5->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x0#5->left))), @_vcc_ptr_eq_null(*((x0#5->right)))), ==(treap_min_key(x0#5), @\int_min(*((x0#5->key)), treap_min_key(*((x0#5->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x0#5->left))), @_vcc_ptr_neq_null(*((x0#5->right)))), ==(treap_min_key(x0#5), @\int_min(*((x0#5->key)), treap_min_key(*((x0#5->right)))))))); 
            assume $non_null($phys_ptr_cast(x0#5, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(x0#5, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(x0#5, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(x0#5, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(x0#5, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(x0#5, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(x0#5, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x0#5), ==(treap_prios(x0#5), @_vcc_intset_union(@_vcc_intset_singleton(*((x0#5->prio))), @_vcc_intset_union(treap_prios(*((x0#5->left))), treap_prios(*((x0#5->right))))))); 
            assume $non_null($phys_ptr_cast(x0#5, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(x0#5, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(x0#5, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl#4), ==(treap(xl#4), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((xl#4->left))), treap(*((xl#4->right)))), unchecked!(@_vcc_oset_in(xl#4, @_vcc_oset_union(treap_reach(*((xl#4->left))), treap_reach(*((xl#4->right))))))), unchecked!(@_vcc_intset_in(*((xl#4->key)), @_vcc_intset_union(treap_keys(*((xl#4->left))), treap_keys(*((xl#4->right))))))), unchecked!(@_vcc_intset_in(*((xl#4->prio)), @_vcc_intset_union(treap_prios(*((xl#4->left))), treap_prios(*((xl#4->right))))))), @_vcc_oset_disjoint(treap_reach(*((xl#4->left))), treap_reach(*((xl#4->right))))), @_vcc_intset_disjoint(treap_keys(*((xl#4->left))), treap_keys(*((xl#4->right))))), @_vcc_intset_disjoint(treap_prios(*((xl#4->left))), treap_prios(*((xl#4->right))))), ==>(@_vcc_ptr_neq_null(*((xl#4->left))), <(treap_max_key(*((xl#4->left))), *((xl#4->key))))), ==>(@_vcc_ptr_neq_null(*((xl#4->right))), <(*((xl#4->key)), treap_min_key(*((xl#4->right)))))), ==>(@_vcc_ptr_neq_null(*((xl#4->left))), <(treap_max_prio(*((xl#4->left))), *((xl#4->prio))))), ==>(@_vcc_ptr_neq_null(*((xl#4->right))), <(treap_max_prio(*((xl#4->right))), *((xl#4->prio))))))); 
            assume $non_null($phys_ptr_cast(xl#4, ^b_node)) ==> F#treap($s, $phys_ptr_cast(xl#4, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(xl#4, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(xl#4, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(xl#4, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(xl#4, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(xl#4, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(xl#4, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(xl#4, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl#4), ==(treap_reach(xl#4), @_vcc_oset_union(@_vcc_oset_singleton(xl#4), @_vcc_oset_union(treap_reach(*((xl#4->left))), treap_reach(*((xl#4->right))))))); 
            assume $non_null($phys_ptr_cast(xl#4, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(xl#4, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(xl#4, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl#4), ==(treap_keys(xl#4), @_vcc_intset_union(@_vcc_intset_singleton(*((xl#4->key))), @_vcc_intset_union(treap_keys(*((xl#4->left))), treap_keys(*((xl#4->right))))))); 
            assume $non_null($phys_ptr_cast(xl#4, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(xl#4, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(xl#4, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl#4), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl#4->left))), @_vcc_ptr_neq_null(*((xl#4->right)))), ==(treap_max_key(xl#4), @\int_max(*((xl#4->key)), @\int_max(treap_max_key(*((xl#4->left))), treap_max_key(*((xl#4->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl#4->left))), @_vcc_ptr_eq_null(*((xl#4->right)))), ==(treap_max_key(xl#4), @\int_max(*((xl#4->key)), treap_max_key(*((xl#4->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl#4->left))), @_vcc_ptr_neq_null(*((xl#4->right)))), ==(treap_max_key(xl#4), @\int_max(*((xl#4->key)), treap_max_key(*((xl#4->right)))))))); 
            assume $non_null($phys_ptr_cast(xl#4, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xl#4, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xl#4, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xl#4, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xl#4, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xl#4, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xl#4, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl#4), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl#4->left))), @_vcc_ptr_neq_null(*((xl#4->right)))), ==(treap_max_prio(xl#4), @\int_max(*((xl#4->prio)), @\int_max(treap_max_prio(*((xl#4->left))), treap_max_prio(*((xl#4->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl#4->left))), @_vcc_ptr_eq_null(*((xl#4->right)))), ==(treap_max_prio(xl#4), @\int_max(*((xl#4->prio)), treap_max_prio(*((xl#4->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl#4->left))), @_vcc_ptr_neq_null(*((xl#4->right)))), ==(treap_max_prio(xl#4), @\int_max(*((xl#4->prio)), treap_max_prio(*((xl#4->right)))))))); 
            assume $non_null($phys_ptr_cast(xl#4, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xl#4, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xl#4, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xl#4, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xl#4, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xl#4, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xl#4, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl#4), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl#4->left))), @_vcc_ptr_neq_null(*((xl#4->right)))), ==(treap_min_key(xl#4), @\int_min(*((xl#4->key)), @\int_min(treap_min_key(*((xl#4->left))), treap_min_key(*((xl#4->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl#4->left))), @_vcc_ptr_eq_null(*((xl#4->right)))), ==(treap_min_key(xl#4), @\int_min(*((xl#4->key)), treap_min_key(*((xl#4->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl#4->left))), @_vcc_ptr_neq_null(*((xl#4->right)))), ==(treap_min_key(xl#4), @\int_min(*((xl#4->key)), treap_min_key(*((xl#4->right)))))))); 
            assume $non_null($phys_ptr_cast(xl#4, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xl#4, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xl#4, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xl#4, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xl#4, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xl#4, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xl#4, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl#4), ==(treap_prios(xl#4), @_vcc_intset_union(@_vcc_intset_singleton(*((xl#4->prio))), @_vcc_intset_union(treap_prios(*((xl#4->left))), treap_prios(*((xl#4->right))))))); 
            assume $non_null($phys_ptr_cast(xl#4, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(xl#4, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(xl#4, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr#3), ==(treap(xr#3), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((xr#3->left))), treap(*((xr#3->right)))), unchecked!(@_vcc_oset_in(xr#3, @_vcc_oset_union(treap_reach(*((xr#3->left))), treap_reach(*((xr#3->right))))))), unchecked!(@_vcc_intset_in(*((xr#3->key)), @_vcc_intset_union(treap_keys(*((xr#3->left))), treap_keys(*((xr#3->right))))))), unchecked!(@_vcc_intset_in(*((xr#3->prio)), @_vcc_intset_union(treap_prios(*((xr#3->left))), treap_prios(*((xr#3->right))))))), @_vcc_oset_disjoint(treap_reach(*((xr#3->left))), treap_reach(*((xr#3->right))))), @_vcc_intset_disjoint(treap_keys(*((xr#3->left))), treap_keys(*((xr#3->right))))), @_vcc_intset_disjoint(treap_prios(*((xr#3->left))), treap_prios(*((xr#3->right))))), ==>(@_vcc_ptr_neq_null(*((xr#3->left))), <(treap_max_key(*((xr#3->left))), *((xr#3->key))))), ==>(@_vcc_ptr_neq_null(*((xr#3->right))), <(*((xr#3->key)), treap_min_key(*((xr#3->right)))))), ==>(@_vcc_ptr_neq_null(*((xr#3->left))), <(treap_max_prio(*((xr#3->left))), *((xr#3->prio))))), ==>(@_vcc_ptr_neq_null(*((xr#3->right))), <(treap_max_prio(*((xr#3->right))), *((xr#3->prio))))))); 
            assume $non_null($phys_ptr_cast(xr#3, ^b_node)) ==> F#treap($s, $phys_ptr_cast(xr#3, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(xr#3, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(xr#3, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(xr#3, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(xr#3, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(xr#3, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(xr#3, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(xr#3, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr#3), ==(treap_reach(xr#3), @_vcc_oset_union(@_vcc_oset_singleton(xr#3), @_vcc_oset_union(treap_reach(*((xr#3->left))), treap_reach(*((xr#3->right))))))); 
            assume $non_null($phys_ptr_cast(xr#3, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(xr#3, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(xr#3, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr#3), ==(treap_keys(xr#3), @_vcc_intset_union(@_vcc_intset_singleton(*((xr#3->key))), @_vcc_intset_union(treap_keys(*((xr#3->left))), treap_keys(*((xr#3->right))))))); 
            assume $non_null($phys_ptr_cast(xr#3, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(xr#3, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(xr#3, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr#3), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr#3->left))), @_vcc_ptr_neq_null(*((xr#3->right)))), ==(treap_max_key(xr#3), @\int_max(*((xr#3->key)), @\int_max(treap_max_key(*((xr#3->left))), treap_max_key(*((xr#3->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr#3->left))), @_vcc_ptr_eq_null(*((xr#3->right)))), ==(treap_max_key(xr#3), @\int_max(*((xr#3->key)), treap_max_key(*((xr#3->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr#3->left))), @_vcc_ptr_neq_null(*((xr#3->right)))), ==(treap_max_key(xr#3), @\int_max(*((xr#3->key)), treap_max_key(*((xr#3->right)))))))); 
            assume $non_null($phys_ptr_cast(xr#3, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xr#3, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xr#3, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xr#3, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xr#3, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xr#3, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xr#3, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr#3), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr#3->left))), @_vcc_ptr_neq_null(*((xr#3->right)))), ==(treap_max_prio(xr#3), @\int_max(*((xr#3->prio)), @\int_max(treap_max_prio(*((xr#3->left))), treap_max_prio(*((xr#3->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr#3->left))), @_vcc_ptr_eq_null(*((xr#3->right)))), ==(treap_max_prio(xr#3), @\int_max(*((xr#3->prio)), treap_max_prio(*((xr#3->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr#3->left))), @_vcc_ptr_neq_null(*((xr#3->right)))), ==(treap_max_prio(xr#3), @\int_max(*((xr#3->prio)), treap_max_prio(*((xr#3->right)))))))); 
            assume $non_null($phys_ptr_cast(xr#3, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xr#3, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xr#3, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xr#3, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xr#3, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xr#3, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xr#3, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr#3), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr#3->left))), @_vcc_ptr_neq_null(*((xr#3->right)))), ==(treap_min_key(xr#3), @\int_min(*((xr#3->key)), @\int_min(treap_min_key(*((xr#3->left))), treap_min_key(*((xr#3->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr#3->left))), @_vcc_ptr_eq_null(*((xr#3->right)))), ==(treap_min_key(xr#3), @\int_min(*((xr#3->key)), treap_min_key(*((xr#3->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr#3->left))), @_vcc_ptr_neq_null(*((xr#3->right)))), ==(treap_min_key(xr#3), @\int_min(*((xr#3->key)), treap_min_key(*((xr#3->right)))))))); 
            assume $non_null($phys_ptr_cast(xr#3, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xr#3, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xr#3, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xr#3, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xr#3, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xr#3, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xr#3, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr#3), ==(treap_prios(xr#3), @_vcc_intset_union(@_vcc_intset_singleton(*((xr#3->prio))), @_vcc_intset_union(treap_prios(*((xr#3->left))), treap_prios(*((xr#3->right))))))); 
            assume $non_null($phys_ptr_cast(xr#3, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(xr#3, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(xr#3, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(r#2), ==(treap(r#2), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((r#2->left))), treap(*((r#2->right)))), unchecked!(@_vcc_oset_in(r#2, @_vcc_oset_union(treap_reach(*((r#2->left))), treap_reach(*((r#2->right))))))), unchecked!(@_vcc_intset_in(*((r#2->key)), @_vcc_intset_union(treap_keys(*((r#2->left))), treap_keys(*((r#2->right))))))), unchecked!(@_vcc_intset_in(*((r#2->prio)), @_vcc_intset_union(treap_prios(*((r#2->left))), treap_prios(*((r#2->right))))))), @_vcc_oset_disjoint(treap_reach(*((r#2->left))), treap_reach(*((r#2->right))))), @_vcc_intset_disjoint(treap_keys(*((r#2->left))), treap_keys(*((r#2->right))))), @_vcc_intset_disjoint(treap_prios(*((r#2->left))), treap_prios(*((r#2->right))))), ==>(@_vcc_ptr_neq_null(*((r#2->left))), <(treap_max_key(*((r#2->left))), *((r#2->key))))), ==>(@_vcc_ptr_neq_null(*((r#2->right))), <(*((r#2->key)), treap_min_key(*((r#2->right)))))), ==>(@_vcc_ptr_neq_null(*((r#2->left))), <(treap_max_prio(*((r#2->left))), *((r#2->prio))))), ==>(@_vcc_ptr_neq_null(*((r#2->right))), <(treap_max_prio(*((r#2->right))), *((r#2->prio))))))); 
            assume $non_null($phys_ptr_cast(r#2, ^b_node)) ==> F#treap($s, $phys_ptr_cast(r#2, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(r#2, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(r#2, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(r#2, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(r#2, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(r#2, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(r#2, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(r#2, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(r#2), ==(treap_reach(r#2), @_vcc_oset_union(@_vcc_oset_singleton(r#2), @_vcc_oset_union(treap_reach(*((r#2->left))), treap_reach(*((r#2->right))))))); 
            assume $non_null($phys_ptr_cast(r#2, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(r#2, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(r#2, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(r#2), ==(treap_keys(r#2), @_vcc_intset_union(@_vcc_intset_singleton(*((r#2->key))), @_vcc_intset_union(treap_keys(*((r#2->left))), treap_keys(*((r#2->right))))))); 
            assume $non_null($phys_ptr_cast(r#2, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(r#2, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(r#2, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(r#2), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((r#2->left))), @_vcc_ptr_neq_null(*((r#2->right)))), ==(treap_max_key(r#2), @\int_max(*((r#2->key)), @\int_max(treap_max_key(*((r#2->left))), treap_max_key(*((r#2->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((r#2->left))), @_vcc_ptr_eq_null(*((r#2->right)))), ==(treap_max_key(r#2), @\int_max(*((r#2->key)), treap_max_key(*((r#2->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((r#2->left))), @_vcc_ptr_neq_null(*((r#2->right)))), ==(treap_max_key(r#2), @\int_max(*((r#2->key)), treap_max_key(*((r#2->right)))))))); 
            assume $non_null($phys_ptr_cast(r#2, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(r#2, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(r#2, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(r#2, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(r#2, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(r#2, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(r#2, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(r#2), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((r#2->left))), @_vcc_ptr_neq_null(*((r#2->right)))), ==(treap_max_prio(r#2), @\int_max(*((r#2->prio)), @\int_max(treap_max_prio(*((r#2->left))), treap_max_prio(*((r#2->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((r#2->left))), @_vcc_ptr_eq_null(*((r#2->right)))), ==(treap_max_prio(r#2), @\int_max(*((r#2->prio)), treap_max_prio(*((r#2->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((r#2->left))), @_vcc_ptr_neq_null(*((r#2->right)))), ==(treap_max_prio(r#2), @\int_max(*((r#2->prio)), treap_max_prio(*((r#2->right)))))))); 
            assume $non_null($phys_ptr_cast(r#2, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(r#2, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(r#2, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(r#2, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(r#2, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(r#2, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(r#2, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(r#2), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((r#2->left))), @_vcc_ptr_neq_null(*((r#2->right)))), ==(treap_min_key(r#2), @\int_min(*((r#2->key)), @\int_min(treap_min_key(*((r#2->left))), treap_min_key(*((r#2->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((r#2->left))), @_vcc_ptr_eq_null(*((r#2->right)))), ==(treap_min_key(r#2), @\int_min(*((r#2->key)), treap_min_key(*((r#2->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((r#2->left))), @_vcc_ptr_neq_null(*((r#2->right)))), ==(treap_min_key(r#2), @\int_min(*((r#2->key)), treap_min_key(*((r#2->right)))))))); 
            assume $non_null($phys_ptr_cast(r#2, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(r#2, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(r#2, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(r#2, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(r#2, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(r#2, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(r#2, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(r#2), ==(treap_prios(r#2), @_vcc_intset_union(@_vcc_intset_singleton(*((r#2->prio))), @_vcc_intset_union(treap_prios(*((r#2->left))), treap_prios(*((r#2->right))))))); 
            assume $non_null($phys_ptr_cast(r#2, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(r#2, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(r#2, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap(x), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x->left))), treap(*((x->right)))), unchecked!(@_vcc_oset_in(x, @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->key)), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->prio)), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))), @_vcc_oset_disjoint(treap_reach(*((x->left))), treap_reach(*((x->right))))), @_vcc_intset_disjoint(treap_keys(*((x->left))), treap_keys(*((x->right))))), @_vcc_intset_disjoint(treap_prios(*((x->left))), treap_prios(*((x->right))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_key(*((x->left))), *((x->key))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(*((x->key)), treap_min_key(*((x->right)))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_prio(*((x->left))), *((x->prio))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(treap_max_prio(*((x->right))), *((x->prio))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap($s, $phys_ptr_cast(P#x, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(P#x, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_reach(x), @_vcc_oset_union(@_vcc_oset_singleton(x), @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(P#x, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(P#x, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_keys(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->key))), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), @\int_max(treap_max_key(*((x->left))), treap_max_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), @\int_max(treap_max_prio(*((x->left))), treap_max_prio(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), @\int_min(treap_min_key(*((x->left))), treap_min_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_prios(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->prio))), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(!(@_vcc_oset_in(x1#6, old(_dryad_S0#7, treap_reach(xr#3)))), @_vcc_ptr_eq_pure(*((x1#6->left)), old(_dryad_S0#7, *((x1#6->left))))); 
            assume !$oset_in($phys_ptr_cast(x1#6, ^b_node), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node))) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S0#7, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_oset_in(x1#6, old(_dryad_S0#7, treap_reach(xr#3)))), @_vcc_ptr_eq_pure(*((x1#6->right)), old(_dryad_S0#7, *((x1#6->right))))); 
            assume !$oset_in($phys_ptr_cast(x1#6, ^b_node), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node))) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S0#7, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_oset_in(x1#6, old(_dryad_S0#7, treap_reach(xr#3)))), ==(*((x1#6->key)), old(_dryad_S0#7, *((x1#6->key))))); 
            assume !$oset_in($phys_ptr_cast(x1#6, ^b_node), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node))) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(x1#6, ^b_node)) == $rd_inv(_dryad_S0#7, b_node.key, $phys_ptr_cast(x1#6, ^b_node));
            // assume ==>(!(@_vcc_oset_in(x1#6, old(_dryad_S0#7, treap_reach(xr#3)))), ==(*((x1#6->prio)), old(_dryad_S0#7, *((x1#6->prio))))); 
            assume !$oset_in($phys_ptr_cast(x1#6, ^b_node), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node))) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(x1#6, ^b_node)) == $rd_inv(_dryad_S0#7, b_node.prio, $phys_ptr_cast(x1#6, ^b_node));
            // assume ==>(!(@_vcc_oset_in(x0#5, old(_dryad_S0#7, treap_reach(xr#3)))), @_vcc_ptr_eq_pure(*((x0#5->left)), old(_dryad_S0#7, *((x0#5->left))))); 
            assume !$oset_in($phys_ptr_cast(x0#5, ^b_node), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node))) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S0#7, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_oset_in(x0#5, old(_dryad_S0#7, treap_reach(xr#3)))), @_vcc_ptr_eq_pure(*((x0#5->right)), old(_dryad_S0#7, *((x0#5->right))))); 
            assume !$oset_in($phys_ptr_cast(x0#5, ^b_node), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node))) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S0#7, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_oset_in(x0#5, old(_dryad_S0#7, treap_reach(xr#3)))), ==(*((x0#5->key)), old(_dryad_S0#7, *((x0#5->key))))); 
            assume !$oset_in($phys_ptr_cast(x0#5, ^b_node), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node))) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(x0#5, ^b_node)) == $rd_inv(_dryad_S0#7, b_node.key, $phys_ptr_cast(x0#5, ^b_node));
            // assume ==>(!(@_vcc_oset_in(x0#5, old(_dryad_S0#7, treap_reach(xr#3)))), ==(*((x0#5->prio)), old(_dryad_S0#7, *((x0#5->prio))))); 
            assume !$oset_in($phys_ptr_cast(x0#5, ^b_node), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node))) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(x0#5, ^b_node)) == $rd_inv(_dryad_S0#7, b_node.prio, $phys_ptr_cast(x0#5, ^b_node));
            // assume ==>(!(@_vcc_oset_in(xl#4, old(_dryad_S0#7, treap_reach(xr#3)))), @_vcc_ptr_eq_pure(*((xl#4->left)), old(_dryad_S0#7, *((xl#4->left))))); 
            assume !$oset_in($phys_ptr_cast(xl#4, ^b_node), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node))) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S0#7, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_oset_in(xl#4, old(_dryad_S0#7, treap_reach(xr#3)))), @_vcc_ptr_eq_pure(*((xl#4->right)), old(_dryad_S0#7, *((xl#4->right))))); 
            assume !$oset_in($phys_ptr_cast(xl#4, ^b_node), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node))) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S0#7, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_oset_in(xl#4, old(_dryad_S0#7, treap_reach(xr#3)))), ==(*((xl#4->key)), old(_dryad_S0#7, *((xl#4->key))))); 
            assume !$oset_in($phys_ptr_cast(xl#4, ^b_node), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node))) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(xl#4, ^b_node)) == $rd_inv(_dryad_S0#7, b_node.key, $phys_ptr_cast(xl#4, ^b_node));
            // assume ==>(!(@_vcc_oset_in(xl#4, old(_dryad_S0#7, treap_reach(xr#3)))), ==(*((xl#4->prio)), old(_dryad_S0#7, *((xl#4->prio))))); 
            assume !$oset_in($phys_ptr_cast(xl#4, ^b_node), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node))) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(xl#4, ^b_node)) == $rd_inv(_dryad_S0#7, b_node.prio, $phys_ptr_cast(xl#4, ^b_node));
            // assume ==>(!(@_vcc_oset_in(xr#3, old(_dryad_S0#7, treap_reach(xr#3)))), @_vcc_ptr_eq_pure(*((xr#3->left)), old(_dryad_S0#7, *((xr#3->left))))); 
            assume !$oset_in($phys_ptr_cast(xr#3, ^b_node), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node))) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S0#7, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_oset_in(xr#3, old(_dryad_S0#7, treap_reach(xr#3)))), @_vcc_ptr_eq_pure(*((xr#3->right)), old(_dryad_S0#7, *((xr#3->right))))); 
            assume !$oset_in($phys_ptr_cast(xr#3, ^b_node), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node))) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S0#7, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_oset_in(xr#3, old(_dryad_S0#7, treap_reach(xr#3)))), ==(*((xr#3->key)), old(_dryad_S0#7, *((xr#3->key))))); 
            assume !$oset_in($phys_ptr_cast(xr#3, ^b_node), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node))) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(xr#3, ^b_node)) == $rd_inv(_dryad_S0#7, b_node.key, $phys_ptr_cast(xr#3, ^b_node));
            // assume ==>(!(@_vcc_oset_in(xr#3, old(_dryad_S0#7, treap_reach(xr#3)))), ==(*((xr#3->prio)), old(_dryad_S0#7, *((xr#3->prio))))); 
            assume !$oset_in($phys_ptr_cast(xr#3, ^b_node), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node))) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(xr#3, ^b_node)) == $rd_inv(_dryad_S0#7, b_node.prio, $phys_ptr_cast(xr#3, ^b_node));
            // assume ==>(!(@_vcc_oset_in(x, old(_dryad_S0#7, treap_reach(xr#3)))), @_vcc_ptr_eq_pure(*((x->left)), old(_dryad_S0#7, *((x->left))))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node))) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S0#7, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_oset_in(x, old(_dryad_S0#7, treap_reach(xr#3)))), @_vcc_ptr_eq_pure(*((x->right)), old(_dryad_S0#7, *((x->right))))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node))) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S0#7, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_oset_in(x, old(_dryad_S0#7, treap_reach(xr#3)))), ==(*((x->key)), old(_dryad_S0#7, *((x->key))))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node))) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) == $rd_inv(_dryad_S0#7, b_node.key, $phys_ptr_cast(P#x, ^b_node));
            // assume ==>(!(@_vcc_oset_in(x, old(_dryad_S0#7, treap_reach(xr#3)))), ==(*((x->prio)), old(_dryad_S0#7, *((x->prio))))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S0#7, $phys_ptr_cast(xr#3, ^b_node))) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)) == $rd_inv(_dryad_S0#7, b_node.prio, $phys_ptr_cast(P#x, ^b_node));
            // _math \state _dryad_S2#9; 
            // _dryad_S2#9 := @_vcc_current_state(@state); 
            _dryad_S2#9 := $current_state($s);
            // _math \state stmtexpr5#19; 
            // stmtexpr5#19 := _dryad_S2#9; 
            stmtexpr5#19 := _dryad_S2#9;
            // assert @prim_writes_check((x->right)); 
            assert $writable_prim($s, #wrTime$3^23.3, $dot($phys_ptr_cast(P#x, ^b_node), b_node.right));
            // *(x->right) := r#2; 
            call $write_int(b_node.right, $phys_ptr_cast(P#x, ^b_node), $ptr_to_int($phys_ptr_cast(r#2, ^b_node)));
            assume $full_stop_ext(#tok$3^58.5, $s);
            // _math \state _dryad_S3#10; 
            // _dryad_S3#10 := @_vcc_current_state(@state); 
            _dryad_S3#10 := $current_state($s);
            // _math \state stmtexpr6#20; 
            // stmtexpr6#20 := _dryad_S3#10; 
            stmtexpr6#20 := _dryad_S3#10;
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#9, treap_reach(*((x->left)))))), ==(old(_dryad_S2#9, treap(*((x->left)))), old(_dryad_S3#10, treap(*((x->left)))))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#9, $rd_phys_ptr(_dryad_S2#9, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node))) ==> F#treap(_dryad_S2#9, $rd_phys_ptr(_dryad_S2#9, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) == F#treap(_dryad_S3#10, $rd_phys_ptr(_dryad_S3#10, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#9, treap_reach(*((x->left)))))), ==(old(_dryad_S2#9, treap_reach(*((x->left)))), old(_dryad_S3#10, treap_reach(*((x->left)))))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#9, $rd_phys_ptr(_dryad_S2#9, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node))) ==> F#treap_reach(_dryad_S2#9, $rd_phys_ptr(_dryad_S2#9, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) == F#treap_reach(_dryad_S3#10, $rd_phys_ptr(_dryad_S3#10, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#9, treap_reach(*((x->left)))))), ==(old(_dryad_S2#9, treap_keys(*((x->left)))), old(_dryad_S3#10, treap_keys(*((x->left)))))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#9, $rd_phys_ptr(_dryad_S2#9, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node))) ==> F#treap_keys(_dryad_S2#9, $rd_phys_ptr(_dryad_S2#9, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) == F#treap_keys(_dryad_S3#10, $rd_phys_ptr(_dryad_S3#10, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#9, treap_reach(*((x->left)))))), ==(old(_dryad_S2#9, treap_max_key(*((x->left)))), old(_dryad_S3#10, treap_max_key(*((x->left)))))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#9, $rd_phys_ptr(_dryad_S2#9, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node))) ==> F#treap_max_key(_dryad_S2#9, $rd_phys_ptr(_dryad_S2#9, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) == F#treap_max_key(_dryad_S3#10, $rd_phys_ptr(_dryad_S3#10, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#9, treap_reach(*((x->left)))))), ==(old(_dryad_S2#9, treap_max_prio(*((x->left)))), old(_dryad_S3#10, treap_max_prio(*((x->left)))))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#9, $rd_phys_ptr(_dryad_S2#9, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node))) ==> F#treap_max_prio(_dryad_S2#9, $rd_phys_ptr(_dryad_S2#9, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) == F#treap_max_prio(_dryad_S3#10, $rd_phys_ptr(_dryad_S3#10, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#9, treap_reach(*((x->left)))))), ==(old(_dryad_S2#9, treap_min_key(*((x->left)))), old(_dryad_S3#10, treap_min_key(*((x->left)))))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#9, $rd_phys_ptr(_dryad_S2#9, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node))) ==> F#treap_min_key(_dryad_S2#9, $rd_phys_ptr(_dryad_S2#9, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) == F#treap_min_key(_dryad_S3#10, $rd_phys_ptr(_dryad_S3#10, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#9, treap_reach(*((x->left)))))), ==(old(_dryad_S2#9, treap_prios(*((x->left)))), old(_dryad_S3#10, treap_prios(*((x->left)))))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#9, $rd_phys_ptr(_dryad_S2#9, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node))) ==> F#treap_prios(_dryad_S2#9, $rd_phys_ptr(_dryad_S2#9, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) == F#treap_prios(_dryad_S3#10, $rd_phys_ptr(_dryad_S3#10, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#9, treap_reach(x1#6)))), ==(old(_dryad_S2#9, treap(x1#6)), old(_dryad_S3#10, treap(x1#6)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#9, $phys_ptr_cast(x1#6, ^b_node))) ==> F#treap(_dryad_S2#9, $phys_ptr_cast(x1#6, ^b_node)) == F#treap(_dryad_S3#10, $phys_ptr_cast(x1#6, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#9, treap_reach(x1#6)))), ==(old(_dryad_S2#9, treap_reach(x1#6)), old(_dryad_S3#10, treap_reach(x1#6)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#9, $phys_ptr_cast(x1#6, ^b_node))) ==> F#treap_reach(_dryad_S2#9, $phys_ptr_cast(x1#6, ^b_node)) == F#treap_reach(_dryad_S3#10, $phys_ptr_cast(x1#6, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#9, treap_reach(x1#6)))), ==(old(_dryad_S2#9, treap_keys(x1#6)), old(_dryad_S3#10, treap_keys(x1#6)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#9, $phys_ptr_cast(x1#6, ^b_node))) ==> F#treap_keys(_dryad_S2#9, $phys_ptr_cast(x1#6, ^b_node)) == F#treap_keys(_dryad_S3#10, $phys_ptr_cast(x1#6, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#9, treap_reach(x1#6)))), ==(old(_dryad_S2#9, treap_max_key(x1#6)), old(_dryad_S3#10, treap_max_key(x1#6)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#9, $phys_ptr_cast(x1#6, ^b_node))) ==> F#treap_max_key(_dryad_S2#9, $phys_ptr_cast(x1#6, ^b_node)) == F#treap_max_key(_dryad_S3#10, $phys_ptr_cast(x1#6, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#9, treap_reach(x1#6)))), ==(old(_dryad_S2#9, treap_max_prio(x1#6)), old(_dryad_S3#10, treap_max_prio(x1#6)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#9, $phys_ptr_cast(x1#6, ^b_node))) ==> F#treap_max_prio(_dryad_S2#9, $phys_ptr_cast(x1#6, ^b_node)) == F#treap_max_prio(_dryad_S3#10, $phys_ptr_cast(x1#6, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#9, treap_reach(x1#6)))), ==(old(_dryad_S2#9, treap_min_key(x1#6)), old(_dryad_S3#10, treap_min_key(x1#6)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#9, $phys_ptr_cast(x1#6, ^b_node))) ==> F#treap_min_key(_dryad_S2#9, $phys_ptr_cast(x1#6, ^b_node)) == F#treap_min_key(_dryad_S3#10, $phys_ptr_cast(x1#6, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#9, treap_reach(x1#6)))), ==(old(_dryad_S2#9, treap_prios(x1#6)), old(_dryad_S3#10, treap_prios(x1#6)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#9, $phys_ptr_cast(x1#6, ^b_node))) ==> F#treap_prios(_dryad_S2#9, $phys_ptr_cast(x1#6, ^b_node)) == F#treap_prios(_dryad_S3#10, $phys_ptr_cast(x1#6, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#9, treap_reach(x0#5)))), ==(old(_dryad_S2#9, treap(x0#5)), old(_dryad_S3#10, treap(x0#5)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#9, $phys_ptr_cast(x0#5, ^b_node))) ==> F#treap(_dryad_S2#9, $phys_ptr_cast(x0#5, ^b_node)) == F#treap(_dryad_S3#10, $phys_ptr_cast(x0#5, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#9, treap_reach(x0#5)))), ==(old(_dryad_S2#9, treap_reach(x0#5)), old(_dryad_S3#10, treap_reach(x0#5)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#9, $phys_ptr_cast(x0#5, ^b_node))) ==> F#treap_reach(_dryad_S2#9, $phys_ptr_cast(x0#5, ^b_node)) == F#treap_reach(_dryad_S3#10, $phys_ptr_cast(x0#5, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#9, treap_reach(x0#5)))), ==(old(_dryad_S2#9, treap_keys(x0#5)), old(_dryad_S3#10, treap_keys(x0#5)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#9, $phys_ptr_cast(x0#5, ^b_node))) ==> F#treap_keys(_dryad_S2#9, $phys_ptr_cast(x0#5, ^b_node)) == F#treap_keys(_dryad_S3#10, $phys_ptr_cast(x0#5, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#9, treap_reach(x0#5)))), ==(old(_dryad_S2#9, treap_max_key(x0#5)), old(_dryad_S3#10, treap_max_key(x0#5)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#9, $phys_ptr_cast(x0#5, ^b_node))) ==> F#treap_max_key(_dryad_S2#9, $phys_ptr_cast(x0#5, ^b_node)) == F#treap_max_key(_dryad_S3#10, $phys_ptr_cast(x0#5, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#9, treap_reach(x0#5)))), ==(old(_dryad_S2#9, treap_max_prio(x0#5)), old(_dryad_S3#10, treap_max_prio(x0#5)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#9, $phys_ptr_cast(x0#5, ^b_node))) ==> F#treap_max_prio(_dryad_S2#9, $phys_ptr_cast(x0#5, ^b_node)) == F#treap_max_prio(_dryad_S3#10, $phys_ptr_cast(x0#5, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#9, treap_reach(x0#5)))), ==(old(_dryad_S2#9, treap_min_key(x0#5)), old(_dryad_S3#10, treap_min_key(x0#5)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#9, $phys_ptr_cast(x0#5, ^b_node))) ==> F#treap_min_key(_dryad_S2#9, $phys_ptr_cast(x0#5, ^b_node)) == F#treap_min_key(_dryad_S3#10, $phys_ptr_cast(x0#5, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#9, treap_reach(x0#5)))), ==(old(_dryad_S2#9, treap_prios(x0#5)), old(_dryad_S3#10, treap_prios(x0#5)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#9, $phys_ptr_cast(x0#5, ^b_node))) ==> F#treap_prios(_dryad_S2#9, $phys_ptr_cast(x0#5, ^b_node)) == F#treap_prios(_dryad_S3#10, $phys_ptr_cast(x0#5, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#9, treap_reach(xl#4)))), ==(old(_dryad_S2#9, treap(xl#4)), old(_dryad_S3#10, treap(xl#4)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#9, $phys_ptr_cast(xl#4, ^b_node))) ==> F#treap(_dryad_S2#9, $phys_ptr_cast(xl#4, ^b_node)) == F#treap(_dryad_S3#10, $phys_ptr_cast(xl#4, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#9, treap_reach(xl#4)))), ==(old(_dryad_S2#9, treap_reach(xl#4)), old(_dryad_S3#10, treap_reach(xl#4)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#9, $phys_ptr_cast(xl#4, ^b_node))) ==> F#treap_reach(_dryad_S2#9, $phys_ptr_cast(xl#4, ^b_node)) == F#treap_reach(_dryad_S3#10, $phys_ptr_cast(xl#4, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#9, treap_reach(xl#4)))), ==(old(_dryad_S2#9, treap_keys(xl#4)), old(_dryad_S3#10, treap_keys(xl#4)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#9, $phys_ptr_cast(xl#4, ^b_node))) ==> F#treap_keys(_dryad_S2#9, $phys_ptr_cast(xl#4, ^b_node)) == F#treap_keys(_dryad_S3#10, $phys_ptr_cast(xl#4, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#9, treap_reach(xl#4)))), ==(old(_dryad_S2#9, treap_max_key(xl#4)), old(_dryad_S3#10, treap_max_key(xl#4)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#9, $phys_ptr_cast(xl#4, ^b_node))) ==> F#treap_max_key(_dryad_S2#9, $phys_ptr_cast(xl#4, ^b_node)) == F#treap_max_key(_dryad_S3#10, $phys_ptr_cast(xl#4, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#9, treap_reach(xl#4)))), ==(old(_dryad_S2#9, treap_max_prio(xl#4)), old(_dryad_S3#10, treap_max_prio(xl#4)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#9, $phys_ptr_cast(xl#4, ^b_node))) ==> F#treap_max_prio(_dryad_S2#9, $phys_ptr_cast(xl#4, ^b_node)) == F#treap_max_prio(_dryad_S3#10, $phys_ptr_cast(xl#4, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#9, treap_reach(xl#4)))), ==(old(_dryad_S2#9, treap_min_key(xl#4)), old(_dryad_S3#10, treap_min_key(xl#4)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#9, $phys_ptr_cast(xl#4, ^b_node))) ==> F#treap_min_key(_dryad_S2#9, $phys_ptr_cast(xl#4, ^b_node)) == F#treap_min_key(_dryad_S3#10, $phys_ptr_cast(xl#4, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#9, treap_reach(xl#4)))), ==(old(_dryad_S2#9, treap_prios(xl#4)), old(_dryad_S3#10, treap_prios(xl#4)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#9, $phys_ptr_cast(xl#4, ^b_node))) ==> F#treap_prios(_dryad_S2#9, $phys_ptr_cast(xl#4, ^b_node)) == F#treap_prios(_dryad_S3#10, $phys_ptr_cast(xl#4, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#9, treap_reach(xr#3)))), ==(old(_dryad_S2#9, treap(xr#3)), old(_dryad_S3#10, treap(xr#3)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#9, $phys_ptr_cast(xr#3, ^b_node))) ==> F#treap(_dryad_S2#9, $phys_ptr_cast(xr#3, ^b_node)) == F#treap(_dryad_S3#10, $phys_ptr_cast(xr#3, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#9, treap_reach(xr#3)))), ==(old(_dryad_S2#9, treap_reach(xr#3)), old(_dryad_S3#10, treap_reach(xr#3)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#9, $phys_ptr_cast(xr#3, ^b_node))) ==> F#treap_reach(_dryad_S2#9, $phys_ptr_cast(xr#3, ^b_node)) == F#treap_reach(_dryad_S3#10, $phys_ptr_cast(xr#3, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#9, treap_reach(xr#3)))), ==(old(_dryad_S2#9, treap_keys(xr#3)), old(_dryad_S3#10, treap_keys(xr#3)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#9, $phys_ptr_cast(xr#3, ^b_node))) ==> F#treap_keys(_dryad_S2#9, $phys_ptr_cast(xr#3, ^b_node)) == F#treap_keys(_dryad_S3#10, $phys_ptr_cast(xr#3, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#9, treap_reach(xr#3)))), ==(old(_dryad_S2#9, treap_max_key(xr#3)), old(_dryad_S3#10, treap_max_key(xr#3)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#9, $phys_ptr_cast(xr#3, ^b_node))) ==> F#treap_max_key(_dryad_S2#9, $phys_ptr_cast(xr#3, ^b_node)) == F#treap_max_key(_dryad_S3#10, $phys_ptr_cast(xr#3, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#9, treap_reach(xr#3)))), ==(old(_dryad_S2#9, treap_max_prio(xr#3)), old(_dryad_S3#10, treap_max_prio(xr#3)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#9, $phys_ptr_cast(xr#3, ^b_node))) ==> F#treap_max_prio(_dryad_S2#9, $phys_ptr_cast(xr#3, ^b_node)) == F#treap_max_prio(_dryad_S3#10, $phys_ptr_cast(xr#3, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#9, treap_reach(xr#3)))), ==(old(_dryad_S2#9, treap_min_key(xr#3)), old(_dryad_S3#10, treap_min_key(xr#3)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#9, $phys_ptr_cast(xr#3, ^b_node))) ==> F#treap_min_key(_dryad_S2#9, $phys_ptr_cast(xr#3, ^b_node)) == F#treap_min_key(_dryad_S3#10, $phys_ptr_cast(xr#3, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#9, treap_reach(xr#3)))), ==(old(_dryad_S2#9, treap_prios(xr#3)), old(_dryad_S3#10, treap_prios(xr#3)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#9, $phys_ptr_cast(xr#3, ^b_node))) ==> F#treap_prios(_dryad_S2#9, $phys_ptr_cast(xr#3, ^b_node)) == F#treap_prios(_dryad_S3#10, $phys_ptr_cast(xr#3, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#9, treap_reach(r#2)))), ==(old(_dryad_S2#9, treap(r#2)), old(_dryad_S3#10, treap(r#2)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#9, $phys_ptr_cast(r#2, ^b_node))) ==> F#treap(_dryad_S2#9, $phys_ptr_cast(r#2, ^b_node)) == F#treap(_dryad_S3#10, $phys_ptr_cast(r#2, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#9, treap_reach(r#2)))), ==(old(_dryad_S2#9, treap_reach(r#2)), old(_dryad_S3#10, treap_reach(r#2)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#9, $phys_ptr_cast(r#2, ^b_node))) ==> F#treap_reach(_dryad_S2#9, $phys_ptr_cast(r#2, ^b_node)) == F#treap_reach(_dryad_S3#10, $phys_ptr_cast(r#2, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#9, treap_reach(r#2)))), ==(old(_dryad_S2#9, treap_keys(r#2)), old(_dryad_S3#10, treap_keys(r#2)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#9, $phys_ptr_cast(r#2, ^b_node))) ==> F#treap_keys(_dryad_S2#9, $phys_ptr_cast(r#2, ^b_node)) == F#treap_keys(_dryad_S3#10, $phys_ptr_cast(r#2, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#9, treap_reach(r#2)))), ==(old(_dryad_S2#9, treap_max_key(r#2)), old(_dryad_S3#10, treap_max_key(r#2)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#9, $phys_ptr_cast(r#2, ^b_node))) ==> F#treap_max_key(_dryad_S2#9, $phys_ptr_cast(r#2, ^b_node)) == F#treap_max_key(_dryad_S3#10, $phys_ptr_cast(r#2, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#9, treap_reach(r#2)))), ==(old(_dryad_S2#9, treap_max_prio(r#2)), old(_dryad_S3#10, treap_max_prio(r#2)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#9, $phys_ptr_cast(r#2, ^b_node))) ==> F#treap_max_prio(_dryad_S2#9, $phys_ptr_cast(r#2, ^b_node)) == F#treap_max_prio(_dryad_S3#10, $phys_ptr_cast(r#2, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#9, treap_reach(r#2)))), ==(old(_dryad_S2#9, treap_min_key(r#2)), old(_dryad_S3#10, treap_min_key(r#2)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#9, $phys_ptr_cast(r#2, ^b_node))) ==> F#treap_min_key(_dryad_S2#9, $phys_ptr_cast(r#2, ^b_node)) == F#treap_min_key(_dryad_S3#10, $phys_ptr_cast(r#2, ^b_node));
            // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#9, treap_reach(r#2)))), ==(old(_dryad_S2#9, treap_prios(r#2)), old(_dryad_S3#10, treap_prios(r#2)))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#9, $phys_ptr_cast(r#2, ^b_node))) ==> F#treap_prios(_dryad_S2#9, $phys_ptr_cast(r#2, ^b_node)) == F#treap_prios(_dryad_S3#10, $phys_ptr_cast(r#2, ^b_node));
            // assume ==>(!(@_vcc_ptr_eq_pure(x, x1#6)), @_vcc_ptr_eq_pure(*((x1#6->left)), old(_dryad_S2#9, *((x1#6->left))))); 
            assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(x1#6, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#9, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_ptr_eq_pure(x, x1#6)), @_vcc_ptr_eq_pure(*((x1#6->right)), old(_dryad_S2#9, *((x1#6->right))))); 
            assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(x1#6, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#9, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_ptr_eq_pure(x, x1#6)), ==(*((x1#6->key)), old(_dryad_S2#9, *((x1#6->key))))); 
            assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(x1#6, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(x1#6, ^b_node)) == $rd_inv(_dryad_S2#9, b_node.key, $phys_ptr_cast(x1#6, ^b_node));
            // assume ==>(!(@_vcc_ptr_eq_pure(x, x1#6)), ==(*((x1#6->prio)), old(_dryad_S2#9, *((x1#6->prio))))); 
            assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(x1#6, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(x1#6, ^b_node)) == $rd_inv(_dryad_S2#9, b_node.prio, $phys_ptr_cast(x1#6, ^b_node));
            // assume ==>(!(@_vcc_ptr_eq_pure(x, x0#5)), @_vcc_ptr_eq_pure(*((x0#5->left)), old(_dryad_S2#9, *((x0#5->left))))); 
            assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(x0#5, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#9, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_ptr_eq_pure(x, x0#5)), @_vcc_ptr_eq_pure(*((x0#5->right)), old(_dryad_S2#9, *((x0#5->right))))); 
            assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(x0#5, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#9, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_ptr_eq_pure(x, x0#5)), ==(*((x0#5->key)), old(_dryad_S2#9, *((x0#5->key))))); 
            assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(x0#5, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(x0#5, ^b_node)) == $rd_inv(_dryad_S2#9, b_node.key, $phys_ptr_cast(x0#5, ^b_node));
            // assume ==>(!(@_vcc_ptr_eq_pure(x, x0#5)), ==(*((x0#5->prio)), old(_dryad_S2#9, *((x0#5->prio))))); 
            assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(x0#5, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(x0#5, ^b_node)) == $rd_inv(_dryad_S2#9, b_node.prio, $phys_ptr_cast(x0#5, ^b_node));
            // assume ==>(!(@_vcc_ptr_eq_pure(x, xl#4)), @_vcc_ptr_eq_pure(*((xl#4->left)), old(_dryad_S2#9, *((xl#4->left))))); 
            assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(xl#4, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#9, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_ptr_eq_pure(x, xl#4)), @_vcc_ptr_eq_pure(*((xl#4->right)), old(_dryad_S2#9, *((xl#4->right))))); 
            assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(xl#4, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#9, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_ptr_eq_pure(x, xl#4)), ==(*((xl#4->key)), old(_dryad_S2#9, *((xl#4->key))))); 
            assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(xl#4, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(xl#4, ^b_node)) == $rd_inv(_dryad_S2#9, b_node.key, $phys_ptr_cast(xl#4, ^b_node));
            // assume ==>(!(@_vcc_ptr_eq_pure(x, xl#4)), ==(*((xl#4->prio)), old(_dryad_S2#9, *((xl#4->prio))))); 
            assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(xl#4, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(xl#4, ^b_node)) == $rd_inv(_dryad_S2#9, b_node.prio, $phys_ptr_cast(xl#4, ^b_node));
            // assume ==>(!(@_vcc_ptr_eq_pure(x, xr#3)), @_vcc_ptr_eq_pure(*((xr#3->left)), old(_dryad_S2#9, *((xr#3->left))))); 
            assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(xr#3, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#9, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_ptr_eq_pure(x, xr#3)), @_vcc_ptr_eq_pure(*((xr#3->right)), old(_dryad_S2#9, *((xr#3->right))))); 
            assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(xr#3, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#9, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_ptr_eq_pure(x, xr#3)), ==(*((xr#3->key)), old(_dryad_S2#9, *((xr#3->key))))); 
            assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(xr#3, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(xr#3, ^b_node)) == $rd_inv(_dryad_S2#9, b_node.key, $phys_ptr_cast(xr#3, ^b_node));
            // assume ==>(!(@_vcc_ptr_eq_pure(x, xr#3)), ==(*((xr#3->prio)), old(_dryad_S2#9, *((xr#3->prio))))); 
            assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(xr#3, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(xr#3, ^b_node)) == $rd_inv(_dryad_S2#9, b_node.prio, $phys_ptr_cast(xr#3, ^b_node));
            // assume ==>(!(@_vcc_ptr_eq_pure(x, r#2)), @_vcc_ptr_eq_pure(*((r#2->left)), old(_dryad_S2#9, *((r#2->left))))); 
            assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(r#2, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#9, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_ptr_eq_pure(x, r#2)), @_vcc_ptr_eq_pure(*((r#2->right)), old(_dryad_S2#9, *((r#2->right))))); 
            assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(r#2, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#9, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_ptr_eq_pure(x, r#2)), ==(*((r#2->key)), old(_dryad_S2#9, *((r#2->key))))); 
            assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(r#2, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(r#2, ^b_node)) == $rd_inv(_dryad_S2#9, b_node.key, $phys_ptr_cast(r#2, ^b_node));
            // assume ==>(!(@_vcc_ptr_eq_pure(x, r#2)), ==(*((r#2->prio)), old(_dryad_S2#9, *((r#2->prio))))); 
            assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(r#2, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(r#2, ^b_node)) == $rd_inv(_dryad_S2#9, b_node.prio, $phys_ptr_cast(r#2, ^b_node));
            // assume ==>(@_vcc_ptr_neq_null(x1#6), ==(treap(x1#6), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x1#6->left))), treap(*((x1#6->right)))), unchecked!(@_vcc_oset_in(x1#6, @_vcc_oset_union(treap_reach(*((x1#6->left))), treap_reach(*((x1#6->right))))))), unchecked!(@_vcc_intset_in(*((x1#6->key)), @_vcc_intset_union(treap_keys(*((x1#6->left))), treap_keys(*((x1#6->right))))))), unchecked!(@_vcc_intset_in(*((x1#6->prio)), @_vcc_intset_union(treap_prios(*((x1#6->left))), treap_prios(*((x1#6->right))))))), @_vcc_oset_disjoint(treap_reach(*((x1#6->left))), treap_reach(*((x1#6->right))))), @_vcc_intset_disjoint(treap_keys(*((x1#6->left))), treap_keys(*((x1#6->right))))), @_vcc_intset_disjoint(treap_prios(*((x1#6->left))), treap_prios(*((x1#6->right))))), ==>(@_vcc_ptr_neq_null(*((x1#6->left))), <(treap_max_key(*((x1#6->left))), *((x1#6->key))))), ==>(@_vcc_ptr_neq_null(*((x1#6->right))), <(*((x1#6->key)), treap_min_key(*((x1#6->right)))))), ==>(@_vcc_ptr_neq_null(*((x1#6->left))), <(treap_max_prio(*((x1#6->left))), *((x1#6->prio))))), ==>(@_vcc_ptr_neq_null(*((x1#6->right))), <(treap_max_prio(*((x1#6->right))), *((x1#6->prio))))))); 
            assume $non_null($phys_ptr_cast(x1#6, ^b_node)) ==> F#treap($s, $phys_ptr_cast(x1#6, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(x1#6, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(x1#6, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(x1#6, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(x1#6, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(x1#6, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(x1#6, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(x1#6, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x1#6), ==(treap_reach(x1#6), @_vcc_oset_union(@_vcc_oset_singleton(x1#6), @_vcc_oset_union(treap_reach(*((x1#6->left))), treap_reach(*((x1#6->right))))))); 
            assume $non_null($phys_ptr_cast(x1#6, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(x1#6, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(x1#6, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x1#6), ==(treap_keys(x1#6), @_vcc_intset_union(@_vcc_intset_singleton(*((x1#6->key))), @_vcc_intset_union(treap_keys(*((x1#6->left))), treap_keys(*((x1#6->right))))))); 
            assume $non_null($phys_ptr_cast(x1#6, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(x1#6, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(x1#6, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x1#6), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x1#6->left))), @_vcc_ptr_neq_null(*((x1#6->right)))), ==(treap_max_key(x1#6), @\int_max(*((x1#6->key)), @\int_max(treap_max_key(*((x1#6->left))), treap_max_key(*((x1#6->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x1#6->left))), @_vcc_ptr_eq_null(*((x1#6->right)))), ==(treap_max_key(x1#6), @\int_max(*((x1#6->key)), treap_max_key(*((x1#6->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x1#6->left))), @_vcc_ptr_neq_null(*((x1#6->right)))), ==(treap_max_key(x1#6), @\int_max(*((x1#6->key)), treap_max_key(*((x1#6->right)))))))); 
            assume $non_null($phys_ptr_cast(x1#6, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(x1#6, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(x1#6, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(x1#6, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(x1#6, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(x1#6, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(x1#6, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x1#6), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x1#6->left))), @_vcc_ptr_neq_null(*((x1#6->right)))), ==(treap_max_prio(x1#6), @\int_max(*((x1#6->prio)), @\int_max(treap_max_prio(*((x1#6->left))), treap_max_prio(*((x1#6->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x1#6->left))), @_vcc_ptr_eq_null(*((x1#6->right)))), ==(treap_max_prio(x1#6), @\int_max(*((x1#6->prio)), treap_max_prio(*((x1#6->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x1#6->left))), @_vcc_ptr_neq_null(*((x1#6->right)))), ==(treap_max_prio(x1#6), @\int_max(*((x1#6->prio)), treap_max_prio(*((x1#6->right)))))))); 
            assume $non_null($phys_ptr_cast(x1#6, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(x1#6, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(x1#6, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(x1#6, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(x1#6, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(x1#6, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(x1#6, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x1#6), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x1#6->left))), @_vcc_ptr_neq_null(*((x1#6->right)))), ==(treap_min_key(x1#6), @\int_min(*((x1#6->key)), @\int_min(treap_min_key(*((x1#6->left))), treap_min_key(*((x1#6->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x1#6->left))), @_vcc_ptr_eq_null(*((x1#6->right)))), ==(treap_min_key(x1#6), @\int_min(*((x1#6->key)), treap_min_key(*((x1#6->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x1#6->left))), @_vcc_ptr_neq_null(*((x1#6->right)))), ==(treap_min_key(x1#6), @\int_min(*((x1#6->key)), treap_min_key(*((x1#6->right)))))))); 
            assume $non_null($phys_ptr_cast(x1#6, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(x1#6, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(x1#6, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(x1#6, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(x1#6, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(x1#6, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(x1#6, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x1#6), ==(treap_prios(x1#6), @_vcc_intset_union(@_vcc_intset_singleton(*((x1#6->prio))), @_vcc_intset_union(treap_prios(*((x1#6->left))), treap_prios(*((x1#6->right))))))); 
            assume $non_null($phys_ptr_cast(x1#6, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(x1#6, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(x1#6, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#6, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#6, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x0#5), ==(treap(x0#5), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x0#5->left))), treap(*((x0#5->right)))), unchecked!(@_vcc_oset_in(x0#5, @_vcc_oset_union(treap_reach(*((x0#5->left))), treap_reach(*((x0#5->right))))))), unchecked!(@_vcc_intset_in(*((x0#5->key)), @_vcc_intset_union(treap_keys(*((x0#5->left))), treap_keys(*((x0#5->right))))))), unchecked!(@_vcc_intset_in(*((x0#5->prio)), @_vcc_intset_union(treap_prios(*((x0#5->left))), treap_prios(*((x0#5->right))))))), @_vcc_oset_disjoint(treap_reach(*((x0#5->left))), treap_reach(*((x0#5->right))))), @_vcc_intset_disjoint(treap_keys(*((x0#5->left))), treap_keys(*((x0#5->right))))), @_vcc_intset_disjoint(treap_prios(*((x0#5->left))), treap_prios(*((x0#5->right))))), ==>(@_vcc_ptr_neq_null(*((x0#5->left))), <(treap_max_key(*((x0#5->left))), *((x0#5->key))))), ==>(@_vcc_ptr_neq_null(*((x0#5->right))), <(*((x0#5->key)), treap_min_key(*((x0#5->right)))))), ==>(@_vcc_ptr_neq_null(*((x0#5->left))), <(treap_max_prio(*((x0#5->left))), *((x0#5->prio))))), ==>(@_vcc_ptr_neq_null(*((x0#5->right))), <(treap_max_prio(*((x0#5->right))), *((x0#5->prio))))))); 
            assume $non_null($phys_ptr_cast(x0#5, ^b_node)) ==> F#treap($s, $phys_ptr_cast(x0#5, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(x0#5, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(x0#5, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(x0#5, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(x0#5, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(x0#5, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(x0#5, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(x0#5, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x0#5), ==(treap_reach(x0#5), @_vcc_oset_union(@_vcc_oset_singleton(x0#5), @_vcc_oset_union(treap_reach(*((x0#5->left))), treap_reach(*((x0#5->right))))))); 
            assume $non_null($phys_ptr_cast(x0#5, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(x0#5, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(x0#5, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x0#5), ==(treap_keys(x0#5), @_vcc_intset_union(@_vcc_intset_singleton(*((x0#5->key))), @_vcc_intset_union(treap_keys(*((x0#5->left))), treap_keys(*((x0#5->right))))))); 
            assume $non_null($phys_ptr_cast(x0#5, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(x0#5, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(x0#5, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x0#5), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x0#5->left))), @_vcc_ptr_neq_null(*((x0#5->right)))), ==(treap_max_key(x0#5), @\int_max(*((x0#5->key)), @\int_max(treap_max_key(*((x0#5->left))), treap_max_key(*((x0#5->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x0#5->left))), @_vcc_ptr_eq_null(*((x0#5->right)))), ==(treap_max_key(x0#5), @\int_max(*((x0#5->key)), treap_max_key(*((x0#5->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x0#5->left))), @_vcc_ptr_neq_null(*((x0#5->right)))), ==(treap_max_key(x0#5), @\int_max(*((x0#5->key)), treap_max_key(*((x0#5->right)))))))); 
            assume $non_null($phys_ptr_cast(x0#5, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(x0#5, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(x0#5, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(x0#5, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(x0#5, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(x0#5, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(x0#5, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x0#5), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x0#5->left))), @_vcc_ptr_neq_null(*((x0#5->right)))), ==(treap_max_prio(x0#5), @\int_max(*((x0#5->prio)), @\int_max(treap_max_prio(*((x0#5->left))), treap_max_prio(*((x0#5->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x0#5->left))), @_vcc_ptr_eq_null(*((x0#5->right)))), ==(treap_max_prio(x0#5), @\int_max(*((x0#5->prio)), treap_max_prio(*((x0#5->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x0#5->left))), @_vcc_ptr_neq_null(*((x0#5->right)))), ==(treap_max_prio(x0#5), @\int_max(*((x0#5->prio)), treap_max_prio(*((x0#5->right)))))))); 
            assume $non_null($phys_ptr_cast(x0#5, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(x0#5, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(x0#5, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(x0#5, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(x0#5, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(x0#5, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(x0#5, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x0#5), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x0#5->left))), @_vcc_ptr_neq_null(*((x0#5->right)))), ==(treap_min_key(x0#5), @\int_min(*((x0#5->key)), @\int_min(treap_min_key(*((x0#5->left))), treap_min_key(*((x0#5->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x0#5->left))), @_vcc_ptr_eq_null(*((x0#5->right)))), ==(treap_min_key(x0#5), @\int_min(*((x0#5->key)), treap_min_key(*((x0#5->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x0#5->left))), @_vcc_ptr_neq_null(*((x0#5->right)))), ==(treap_min_key(x0#5), @\int_min(*((x0#5->key)), treap_min_key(*((x0#5->right)))))))); 
            assume $non_null($phys_ptr_cast(x0#5, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(x0#5, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(x0#5, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(x0#5, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(x0#5, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(x0#5, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(x0#5, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x0#5), ==(treap_prios(x0#5), @_vcc_intset_union(@_vcc_intset_singleton(*((x0#5->prio))), @_vcc_intset_union(treap_prios(*((x0#5->left))), treap_prios(*((x0#5->right))))))); 
            assume $non_null($phys_ptr_cast(x0#5, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(x0#5, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(x0#5, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#5, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#5, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl#4), ==(treap(xl#4), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((xl#4->left))), treap(*((xl#4->right)))), unchecked!(@_vcc_oset_in(xl#4, @_vcc_oset_union(treap_reach(*((xl#4->left))), treap_reach(*((xl#4->right))))))), unchecked!(@_vcc_intset_in(*((xl#4->key)), @_vcc_intset_union(treap_keys(*((xl#4->left))), treap_keys(*((xl#4->right))))))), unchecked!(@_vcc_intset_in(*((xl#4->prio)), @_vcc_intset_union(treap_prios(*((xl#4->left))), treap_prios(*((xl#4->right))))))), @_vcc_oset_disjoint(treap_reach(*((xl#4->left))), treap_reach(*((xl#4->right))))), @_vcc_intset_disjoint(treap_keys(*((xl#4->left))), treap_keys(*((xl#4->right))))), @_vcc_intset_disjoint(treap_prios(*((xl#4->left))), treap_prios(*((xl#4->right))))), ==>(@_vcc_ptr_neq_null(*((xl#4->left))), <(treap_max_key(*((xl#4->left))), *((xl#4->key))))), ==>(@_vcc_ptr_neq_null(*((xl#4->right))), <(*((xl#4->key)), treap_min_key(*((xl#4->right)))))), ==>(@_vcc_ptr_neq_null(*((xl#4->left))), <(treap_max_prio(*((xl#4->left))), *((xl#4->prio))))), ==>(@_vcc_ptr_neq_null(*((xl#4->right))), <(treap_max_prio(*((xl#4->right))), *((xl#4->prio))))))); 
            assume $non_null($phys_ptr_cast(xl#4, ^b_node)) ==> F#treap($s, $phys_ptr_cast(xl#4, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(xl#4, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(xl#4, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(xl#4, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(xl#4, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(xl#4, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(xl#4, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(xl#4, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl#4), ==(treap_reach(xl#4), @_vcc_oset_union(@_vcc_oset_singleton(xl#4), @_vcc_oset_union(treap_reach(*((xl#4->left))), treap_reach(*((xl#4->right))))))); 
            assume $non_null($phys_ptr_cast(xl#4, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(xl#4, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(xl#4, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl#4), ==(treap_keys(xl#4), @_vcc_intset_union(@_vcc_intset_singleton(*((xl#4->key))), @_vcc_intset_union(treap_keys(*((xl#4->left))), treap_keys(*((xl#4->right))))))); 
            assume $non_null($phys_ptr_cast(xl#4, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(xl#4, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(xl#4, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl#4), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl#4->left))), @_vcc_ptr_neq_null(*((xl#4->right)))), ==(treap_max_key(xl#4), @\int_max(*((xl#4->key)), @\int_max(treap_max_key(*((xl#4->left))), treap_max_key(*((xl#4->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl#4->left))), @_vcc_ptr_eq_null(*((xl#4->right)))), ==(treap_max_key(xl#4), @\int_max(*((xl#4->key)), treap_max_key(*((xl#4->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl#4->left))), @_vcc_ptr_neq_null(*((xl#4->right)))), ==(treap_max_key(xl#4), @\int_max(*((xl#4->key)), treap_max_key(*((xl#4->right)))))))); 
            assume $non_null($phys_ptr_cast(xl#4, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xl#4, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xl#4, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xl#4, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xl#4, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xl#4, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xl#4, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl#4), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl#4->left))), @_vcc_ptr_neq_null(*((xl#4->right)))), ==(treap_max_prio(xl#4), @\int_max(*((xl#4->prio)), @\int_max(treap_max_prio(*((xl#4->left))), treap_max_prio(*((xl#4->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl#4->left))), @_vcc_ptr_eq_null(*((xl#4->right)))), ==(treap_max_prio(xl#4), @\int_max(*((xl#4->prio)), treap_max_prio(*((xl#4->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl#4->left))), @_vcc_ptr_neq_null(*((xl#4->right)))), ==(treap_max_prio(xl#4), @\int_max(*((xl#4->prio)), treap_max_prio(*((xl#4->right)))))))); 
            assume $non_null($phys_ptr_cast(xl#4, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xl#4, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xl#4, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xl#4, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xl#4, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xl#4, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xl#4, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl#4), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl#4->left))), @_vcc_ptr_neq_null(*((xl#4->right)))), ==(treap_min_key(xl#4), @\int_min(*((xl#4->key)), @\int_min(treap_min_key(*((xl#4->left))), treap_min_key(*((xl#4->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl#4->left))), @_vcc_ptr_eq_null(*((xl#4->right)))), ==(treap_min_key(xl#4), @\int_min(*((xl#4->key)), treap_min_key(*((xl#4->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl#4->left))), @_vcc_ptr_neq_null(*((xl#4->right)))), ==(treap_min_key(xl#4), @\int_min(*((xl#4->key)), treap_min_key(*((xl#4->right)))))))); 
            assume $non_null($phys_ptr_cast(xl#4, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xl#4, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xl#4, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xl#4, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xl#4, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xl#4, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xl#4, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl#4), ==(treap_prios(xl#4), @_vcc_intset_union(@_vcc_intset_singleton(*((xl#4->prio))), @_vcc_intset_union(treap_prios(*((xl#4->left))), treap_prios(*((xl#4->right))))))); 
            assume $non_null($phys_ptr_cast(xl#4, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(xl#4, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(xl#4, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#4, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#4, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr#3), ==(treap(xr#3), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((xr#3->left))), treap(*((xr#3->right)))), unchecked!(@_vcc_oset_in(xr#3, @_vcc_oset_union(treap_reach(*((xr#3->left))), treap_reach(*((xr#3->right))))))), unchecked!(@_vcc_intset_in(*((xr#3->key)), @_vcc_intset_union(treap_keys(*((xr#3->left))), treap_keys(*((xr#3->right))))))), unchecked!(@_vcc_intset_in(*((xr#3->prio)), @_vcc_intset_union(treap_prios(*((xr#3->left))), treap_prios(*((xr#3->right))))))), @_vcc_oset_disjoint(treap_reach(*((xr#3->left))), treap_reach(*((xr#3->right))))), @_vcc_intset_disjoint(treap_keys(*((xr#3->left))), treap_keys(*((xr#3->right))))), @_vcc_intset_disjoint(treap_prios(*((xr#3->left))), treap_prios(*((xr#3->right))))), ==>(@_vcc_ptr_neq_null(*((xr#3->left))), <(treap_max_key(*((xr#3->left))), *((xr#3->key))))), ==>(@_vcc_ptr_neq_null(*((xr#3->right))), <(*((xr#3->key)), treap_min_key(*((xr#3->right)))))), ==>(@_vcc_ptr_neq_null(*((xr#3->left))), <(treap_max_prio(*((xr#3->left))), *((xr#3->prio))))), ==>(@_vcc_ptr_neq_null(*((xr#3->right))), <(treap_max_prio(*((xr#3->right))), *((xr#3->prio))))))); 
            assume $non_null($phys_ptr_cast(xr#3, ^b_node)) ==> F#treap($s, $phys_ptr_cast(xr#3, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(xr#3, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(xr#3, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(xr#3, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(xr#3, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(xr#3, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(xr#3, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(xr#3, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr#3), ==(treap_reach(xr#3), @_vcc_oset_union(@_vcc_oset_singleton(xr#3), @_vcc_oset_union(treap_reach(*((xr#3->left))), treap_reach(*((xr#3->right))))))); 
            assume $non_null($phys_ptr_cast(xr#3, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(xr#3, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(xr#3, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr#3), ==(treap_keys(xr#3), @_vcc_intset_union(@_vcc_intset_singleton(*((xr#3->key))), @_vcc_intset_union(treap_keys(*((xr#3->left))), treap_keys(*((xr#3->right))))))); 
            assume $non_null($phys_ptr_cast(xr#3, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(xr#3, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(xr#3, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr#3), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr#3->left))), @_vcc_ptr_neq_null(*((xr#3->right)))), ==(treap_max_key(xr#3), @\int_max(*((xr#3->key)), @\int_max(treap_max_key(*((xr#3->left))), treap_max_key(*((xr#3->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr#3->left))), @_vcc_ptr_eq_null(*((xr#3->right)))), ==(treap_max_key(xr#3), @\int_max(*((xr#3->key)), treap_max_key(*((xr#3->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr#3->left))), @_vcc_ptr_neq_null(*((xr#3->right)))), ==(treap_max_key(xr#3), @\int_max(*((xr#3->key)), treap_max_key(*((xr#3->right)))))))); 
            assume $non_null($phys_ptr_cast(xr#3, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xr#3, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xr#3, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xr#3, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xr#3, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xr#3, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xr#3, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr#3), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr#3->left))), @_vcc_ptr_neq_null(*((xr#3->right)))), ==(treap_max_prio(xr#3), @\int_max(*((xr#3->prio)), @\int_max(treap_max_prio(*((xr#3->left))), treap_max_prio(*((xr#3->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr#3->left))), @_vcc_ptr_eq_null(*((xr#3->right)))), ==(treap_max_prio(xr#3), @\int_max(*((xr#3->prio)), treap_max_prio(*((xr#3->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr#3->left))), @_vcc_ptr_neq_null(*((xr#3->right)))), ==(treap_max_prio(xr#3), @\int_max(*((xr#3->prio)), treap_max_prio(*((xr#3->right)))))))); 
            assume $non_null($phys_ptr_cast(xr#3, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xr#3, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xr#3, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xr#3, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xr#3, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xr#3, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xr#3, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr#3), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr#3->left))), @_vcc_ptr_neq_null(*((xr#3->right)))), ==(treap_min_key(xr#3), @\int_min(*((xr#3->key)), @\int_min(treap_min_key(*((xr#3->left))), treap_min_key(*((xr#3->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr#3->left))), @_vcc_ptr_eq_null(*((xr#3->right)))), ==(treap_min_key(xr#3), @\int_min(*((xr#3->key)), treap_min_key(*((xr#3->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr#3->left))), @_vcc_ptr_neq_null(*((xr#3->right)))), ==(treap_min_key(xr#3), @\int_min(*((xr#3->key)), treap_min_key(*((xr#3->right)))))))); 
            assume $non_null($phys_ptr_cast(xr#3, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xr#3, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xr#3, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xr#3, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xr#3, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xr#3, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xr#3, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr#3), ==(treap_prios(xr#3), @_vcc_intset_union(@_vcc_intset_singleton(*((xr#3->prio))), @_vcc_intset_union(treap_prios(*((xr#3->left))), treap_prios(*((xr#3->right))))))); 
            assume $non_null($phys_ptr_cast(xr#3, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(xr#3, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(xr#3, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#3, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#3, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(r#2), ==(treap(r#2), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((r#2->left))), treap(*((r#2->right)))), unchecked!(@_vcc_oset_in(r#2, @_vcc_oset_union(treap_reach(*((r#2->left))), treap_reach(*((r#2->right))))))), unchecked!(@_vcc_intset_in(*((r#2->key)), @_vcc_intset_union(treap_keys(*((r#2->left))), treap_keys(*((r#2->right))))))), unchecked!(@_vcc_intset_in(*((r#2->prio)), @_vcc_intset_union(treap_prios(*((r#2->left))), treap_prios(*((r#2->right))))))), @_vcc_oset_disjoint(treap_reach(*((r#2->left))), treap_reach(*((r#2->right))))), @_vcc_intset_disjoint(treap_keys(*((r#2->left))), treap_keys(*((r#2->right))))), @_vcc_intset_disjoint(treap_prios(*((r#2->left))), treap_prios(*((r#2->right))))), ==>(@_vcc_ptr_neq_null(*((r#2->left))), <(treap_max_key(*((r#2->left))), *((r#2->key))))), ==>(@_vcc_ptr_neq_null(*((r#2->right))), <(*((r#2->key)), treap_min_key(*((r#2->right)))))), ==>(@_vcc_ptr_neq_null(*((r#2->left))), <(treap_max_prio(*((r#2->left))), *((r#2->prio))))), ==>(@_vcc_ptr_neq_null(*((r#2->right))), <(treap_max_prio(*((r#2->right))), *((r#2->prio))))))); 
            assume $non_null($phys_ptr_cast(r#2, ^b_node)) ==> F#treap($s, $phys_ptr_cast(r#2, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(r#2, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(r#2, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(r#2, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(r#2, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(r#2, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(r#2, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(r#2, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(r#2), ==(treap_reach(r#2), @_vcc_oset_union(@_vcc_oset_singleton(r#2), @_vcc_oset_union(treap_reach(*((r#2->left))), treap_reach(*((r#2->right))))))); 
            assume $non_null($phys_ptr_cast(r#2, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(r#2, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(r#2, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(r#2), ==(treap_keys(r#2), @_vcc_intset_union(@_vcc_intset_singleton(*((r#2->key))), @_vcc_intset_union(treap_keys(*((r#2->left))), treap_keys(*((r#2->right))))))); 
            assume $non_null($phys_ptr_cast(r#2, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(r#2, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(r#2, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(r#2), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((r#2->left))), @_vcc_ptr_neq_null(*((r#2->right)))), ==(treap_max_key(r#2), @\int_max(*((r#2->key)), @\int_max(treap_max_key(*((r#2->left))), treap_max_key(*((r#2->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((r#2->left))), @_vcc_ptr_eq_null(*((r#2->right)))), ==(treap_max_key(r#2), @\int_max(*((r#2->key)), treap_max_key(*((r#2->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((r#2->left))), @_vcc_ptr_neq_null(*((r#2->right)))), ==(treap_max_key(r#2), @\int_max(*((r#2->key)), treap_max_key(*((r#2->right)))))))); 
            assume $non_null($phys_ptr_cast(r#2, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(r#2, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(r#2, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(r#2, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(r#2, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(r#2, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(r#2, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(r#2), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((r#2->left))), @_vcc_ptr_neq_null(*((r#2->right)))), ==(treap_max_prio(r#2), @\int_max(*((r#2->prio)), @\int_max(treap_max_prio(*((r#2->left))), treap_max_prio(*((r#2->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((r#2->left))), @_vcc_ptr_eq_null(*((r#2->right)))), ==(treap_max_prio(r#2), @\int_max(*((r#2->prio)), treap_max_prio(*((r#2->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((r#2->left))), @_vcc_ptr_neq_null(*((r#2->right)))), ==(treap_max_prio(r#2), @\int_max(*((r#2->prio)), treap_max_prio(*((r#2->right)))))))); 
            assume $non_null($phys_ptr_cast(r#2, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(r#2, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(r#2, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(r#2, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(r#2, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(r#2, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(r#2, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(r#2), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((r#2->left))), @_vcc_ptr_neq_null(*((r#2->right)))), ==(treap_min_key(r#2), @\int_min(*((r#2->key)), @\int_min(treap_min_key(*((r#2->left))), treap_min_key(*((r#2->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((r#2->left))), @_vcc_ptr_eq_null(*((r#2->right)))), ==(treap_min_key(r#2), @\int_min(*((r#2->key)), treap_min_key(*((r#2->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((r#2->left))), @_vcc_ptr_neq_null(*((r#2->right)))), ==(treap_min_key(r#2), @\int_min(*((r#2->key)), treap_min_key(*((r#2->right)))))))); 
            assume $non_null($phys_ptr_cast(r#2, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(r#2, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(r#2, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(r#2, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(r#2, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(r#2, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(r#2, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(r#2), ==(treap_prios(r#2), @_vcc_intset_union(@_vcc_intset_singleton(*((r#2->prio))), @_vcc_intset_union(treap_prios(*((r#2->left))), treap_prios(*((r#2->right))))))); 
            assume $non_null($phys_ptr_cast(r#2, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(r#2, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(r#2, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap(x), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x->left))), treap(*((x->right)))), unchecked!(@_vcc_oset_in(x, @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->key)), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->prio)), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))), @_vcc_oset_disjoint(treap_reach(*((x->left))), treap_reach(*((x->right))))), @_vcc_intset_disjoint(treap_keys(*((x->left))), treap_keys(*((x->right))))), @_vcc_intset_disjoint(treap_prios(*((x->left))), treap_prios(*((x->right))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_key(*((x->left))), *((x->key))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(*((x->key)), treap_min_key(*((x->right)))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_prio(*((x->left))), *((x->prio))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(treap_max_prio(*((x->right))), *((x->prio))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap($s, $phys_ptr_cast(P#x, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(P#x, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_reach(x), @_vcc_oset_union(@_vcc_oset_singleton(x), @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(P#x, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(P#x, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_keys(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->key))), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), @\int_max(treap_max_key(*((x->left))), treap_max_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), @\int_max(treap_max_prio(*((x->left))), treap_max_prio(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), @\int_min(treap_min_key(*((x->left))), treap_min_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_prios(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->prio))), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(r#2), ==(treap(r#2), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((r#2->left))), treap(*((r#2->right)))), unchecked!(@_vcc_oset_in(r#2, @_vcc_oset_union(treap_reach(*((r#2->left))), treap_reach(*((r#2->right))))))), unchecked!(@_vcc_intset_in(*((r#2->key)), @_vcc_intset_union(treap_keys(*((r#2->left))), treap_keys(*((r#2->right))))))), unchecked!(@_vcc_intset_in(*((r#2->prio)), @_vcc_intset_union(treap_prios(*((r#2->left))), treap_prios(*((r#2->right))))))), @_vcc_oset_disjoint(treap_reach(*((r#2->left))), treap_reach(*((r#2->right))))), @_vcc_intset_disjoint(treap_keys(*((r#2->left))), treap_keys(*((r#2->right))))), @_vcc_intset_disjoint(treap_prios(*((r#2->left))), treap_prios(*((r#2->right))))), ==>(@_vcc_ptr_neq_null(*((r#2->left))), <(treap_max_key(*((r#2->left))), *((r#2->key))))), ==>(@_vcc_ptr_neq_null(*((r#2->right))), <(*((r#2->key)), treap_min_key(*((r#2->right)))))), ==>(@_vcc_ptr_neq_null(*((r#2->left))), <(treap_max_prio(*((r#2->left))), *((r#2->prio))))), ==>(@_vcc_ptr_neq_null(*((r#2->right))), <(treap_max_prio(*((r#2->right))), *((r#2->prio))))))); 
            assume $non_null($phys_ptr_cast(r#2, ^b_node)) ==> F#treap($s, $phys_ptr_cast(r#2, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(r#2, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(r#2, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(r#2, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(r#2, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(r#2, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(r#2, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(r#2, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(r#2), ==(treap_reach(r#2), @_vcc_oset_union(@_vcc_oset_singleton(r#2), @_vcc_oset_union(treap_reach(*((r#2->left))), treap_reach(*((r#2->right))))))); 
            assume $non_null($phys_ptr_cast(r#2, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(r#2, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(r#2, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(r#2), ==(treap_keys(r#2), @_vcc_intset_union(@_vcc_intset_singleton(*((r#2->key))), @_vcc_intset_union(treap_keys(*((r#2->left))), treap_keys(*((r#2->right))))))); 
            assume $non_null($phys_ptr_cast(r#2, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(r#2, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(r#2, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(r#2), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((r#2->left))), @_vcc_ptr_neq_null(*((r#2->right)))), ==(treap_max_key(r#2), @\int_max(*((r#2->key)), @\int_max(treap_max_key(*((r#2->left))), treap_max_key(*((r#2->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((r#2->left))), @_vcc_ptr_eq_null(*((r#2->right)))), ==(treap_max_key(r#2), @\int_max(*((r#2->key)), treap_max_key(*((r#2->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((r#2->left))), @_vcc_ptr_neq_null(*((r#2->right)))), ==(treap_max_key(r#2), @\int_max(*((r#2->key)), treap_max_key(*((r#2->right)))))))); 
            assume $non_null($phys_ptr_cast(r#2, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(r#2, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(r#2, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(r#2, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(r#2, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(r#2, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(r#2, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(r#2), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((r#2->left))), @_vcc_ptr_neq_null(*((r#2->right)))), ==(treap_max_prio(r#2), @\int_max(*((r#2->prio)), @\int_max(treap_max_prio(*((r#2->left))), treap_max_prio(*((r#2->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((r#2->left))), @_vcc_ptr_eq_null(*((r#2->right)))), ==(treap_max_prio(r#2), @\int_max(*((r#2->prio)), treap_max_prio(*((r#2->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((r#2->left))), @_vcc_ptr_neq_null(*((r#2->right)))), ==(treap_max_prio(r#2), @\int_max(*((r#2->prio)), treap_max_prio(*((r#2->right)))))))); 
            assume $non_null($phys_ptr_cast(r#2, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(r#2, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(r#2, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(r#2, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(r#2, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(r#2, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(r#2, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(r#2), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((r#2->left))), @_vcc_ptr_neq_null(*((r#2->right)))), ==(treap_min_key(r#2), @\int_min(*((r#2->key)), @\int_min(treap_min_key(*((r#2->left))), treap_min_key(*((r#2->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((r#2->left))), @_vcc_ptr_eq_null(*((r#2->right)))), ==(treap_min_key(r#2), @\int_min(*((r#2->key)), treap_min_key(*((r#2->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((r#2->left))), @_vcc_ptr_neq_null(*((r#2->right)))), ==(treap_min_key(r#2), @\int_min(*((r#2->key)), treap_min_key(*((r#2->right)))))))); 
            assume $non_null($phys_ptr_cast(r#2, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(r#2, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(r#2, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(r#2, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(r#2, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(r#2, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(r#2, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(r#2), ==(treap_prios(r#2), @_vcc_intset_union(@_vcc_intset_singleton(*((r#2->prio))), @_vcc_intset_union(treap_prios(*((r#2->left))), treap_prios(*((r#2->right))))))); 
            assume $non_null($phys_ptr_cast(r#2, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(r#2, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(r#2, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(r#2, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(r#2, ^b_node), ^b_node))));
            // return x; 
            $result := $phys_ptr_cast(P#x, ^b_node);
            assume true;
            assert $position_marker();
            goto #exit;
        }
    }

  anon6:
    // skip

  #exit:
// INV:LOOPTAIL
}



axiom (forall Q#__vcc_state$2^230.9#tc3#1396: $state, Q#x$2^230.9#dt1#1332: $ptr, Q#i$2^230.9#tc1#1333: int :: {:weight 10} { $intset_in(Q#i$2^230.9#tc1#1333, F#treap_keys(Q#__vcc_state$2^230.9#tc3#1396, $phys_ptr_cast(Q#x$2^230.9#dt1#1332, ^b_node))) } $good_state(Q#__vcc_state$2^230.9#tc3#1396) && $in_range_i4(Q#i$2^230.9#tc1#1333) ==> Q#i$2^230.9#tc1#1333 < F#treap_min_key(Q#__vcc_state$2^230.9#tc3#1396, $phys_ptr_cast(Q#x$2^230.9#dt1#1332, ^b_node)) ==> !$intset_in(Q#i$2^230.9#tc1#1333, F#treap_keys(Q#__vcc_state$2^230.9#tc3#1396, $phys_ptr_cast(Q#x$2^230.9#dt1#1332, ^b_node))));

axiom (forall Q#__vcc_state$2^231.9#tc3#1397: $state, Q#x$2^231.9#dt1#1334: $ptr, Q#i$2^231.9#tc1#1335: int :: {:weight 10} { $intset_in(Q#i$2^231.9#tc1#1335, F#treap_keys(Q#__vcc_state$2^231.9#tc3#1397, $phys_ptr_cast(Q#x$2^231.9#dt1#1334, ^b_node))) } $good_state(Q#__vcc_state$2^231.9#tc3#1397) && $in_range_i4(Q#i$2^231.9#tc1#1335) ==> Q#i$2^231.9#tc1#1335 > F#treap_max_key(Q#__vcc_state$2^231.9#tc3#1397, $phys_ptr_cast(Q#x$2^231.9#dt1#1334, ^b_node)) ==> !$intset_in(Q#i$2^231.9#tc1#1335, F#treap_keys(Q#__vcc_state$2^231.9#tc3#1397, $phys_ptr_cast(Q#x$2^231.9#dt1#1334, ^b_node))));

axiom (forall Q#__vcc_state$2^232.9#tc3#1398: $state, Q#x$2^232.9#dt1#1336: $ptr, Q#i$2^232.9#tc1#1337: int :: {:weight 10} { $intset_in(Q#i$2^232.9#tc1#1337, F#treap_prios(Q#__vcc_state$2^232.9#tc3#1398, $phys_ptr_cast(Q#x$2^232.9#dt1#1336, ^b_node))) } $good_state(Q#__vcc_state$2^232.9#tc3#1398) && $in_range_i4(Q#i$2^232.9#tc1#1337) ==> Q#i$2^232.9#tc1#1337 > F#treap_max_prio(Q#__vcc_state$2^232.9#tc3#1398, $phys_ptr_cast(Q#x$2^232.9#dt1#1336, ^b_node)) ==> !$intset_in(Q#i$2^232.9#tc1#1337, F#treap_prios(Q#__vcc_state$2^232.9#tc3#1398, $phys_ptr_cast(Q#x$2^232.9#dt1#1336, ^b_node))));

axiom (forall Q#__vcc_state$2^233.9#tc3#1399: $state, Q#x$2^233.9#dt1#1338: $ptr :: {:weight 10} { F#treap(Q#__vcc_state$2^233.9#tc3#1399, $phys_ptr_cast(Q#x$2^233.9#dt1#1338, ^b_node)) } { F#treap_max_prio(Q#__vcc_state$2^233.9#tc3#1399, $phys_ptr_cast(Q#x$2^233.9#dt1#1338, ^b_node)) } { $rd_inv(Q#__vcc_state$2^233.9#tc3#1399, b_node.prio, $phys_ptr_cast(Q#x$2^233.9#dt1#1338, ^b_node)) } $good_state(Q#__vcc_state$2^233.9#tc3#1399) && true ==> F#treap(Q#__vcc_state$2^233.9#tc3#1399, $phys_ptr_cast(Q#x$2^233.9#dt1#1338, ^b_node)) ==> F#treap_max_prio(Q#__vcc_state$2^233.9#tc3#1399, $phys_ptr_cast(Q#x$2^233.9#dt1#1338, ^b_node)) == $rd_inv(Q#__vcc_state$2^233.9#tc3#1399, b_node.prio, $phys_ptr_cast(Q#x$2^233.9#dt1#1338, ^b_node)));

const unique l#public: $label;

axiom $type_code_is(3, ^$#state_t);

axiom $type_code_is(1, ^^i4);

const unique #tok$3^58.5: $token;

const unique #tok$3^56.17: $token;

const unique #tok$3^49.5: $token;

const unique #tok$3^47.17: $token;

const unique #tok$3^41.17: $token;

const unique #tok$4^0.0: $token;

const unique #file^?3Cno?20file?3E: $token;

axiom $file_name_is(4, #file^?3Cno?20file?3E);

const unique #tok$3^23.3: $token;

const unique #file^Z?3A?5CInvariantSynthesis?5CVCDryad?5Cvcc?5CHost?5Cbin?5CTests?5Ctreap?5Ctreap?2Ddelete?2Drec.c: $token;

axiom $file_name_is(3, #file^Z?3A?5CInvariantSynthesis?5CVCDryad?5Cvcc?5CHost?5Cbin?5CTests?5Ctreap?5Ctreap?2Ddelete?2Drec.c);

const unique #file^z?3A?5Cinvariantsynthesis?5Cvcdryad?5Cvcc?5Chost?5Cbin?5Ctests?5Ctreap?5Cdryad_treap.h: $token;

axiom $file_name_is(2, #file^z?3A?5Cinvariantsynthesis?5Cvcdryad?5Cvcc?5Chost?5Cbin?5Ctests?5Ctreap?5Cdryad_treap.h);

const unique #file^Z?3A?5CInvariantSynthesis?5CVCDryad?2Dbin?5CHeaders?5Cvccp.h: $token;

axiom $file_name_is(1, #file^Z?3A?5CInvariantSynthesis?5CVCDryad?2Dbin?5CHeaders?5Cvccp.h);

const unique #distTp1: $ctype;

axiom #distTp1 == $ptr_to(^b_node);

