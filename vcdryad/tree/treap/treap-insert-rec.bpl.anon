axiom $arch_ptr_size == 8;

axiom $arch_spec_ptr_start == $max.u8;

const unique ^$##thread_id: $ctype;

axiom $def_math_type(^$##thread_id);

type $##thread_id;

const unique ^$##club: $ctype;

axiom $def_math_type(^$##club);

type $##club;

const unique ^b_node: $ctype;

axiom $is_span_sequential(^b_node);

axiom $def_struct_type(^b_node, 24, false, false);

axiom (forall #s1: $state, #s2: $state, #p: $ptr :: { $inv2(#s1, #s2, #p, ^b_node) } $inv2(#s1, #s2, #p, ^b_node) == $set_eq($owns(#s2, #p), $set_empty()));

axiom (forall #s1: $state, #s2: $state, #p: $ptr :: { $inv2_without_lemmas(#s1, #s2, #p, ^b_node) } $inv2_without_lemmas(#s1, #s2, #p, ^b_node) == $set_eq($owns(#s2, #p), $set_empty()));

axiom (forall p: $ptr, q: $ptr, s: $state :: { $in(q, $composite_extent(s, p, ^b_node)) } $in(q, $composite_extent(s, p, ^b_node)) == (q == p));

const unique b_node.left: $field;

axiom $def_phys_field(^b_node, b_node.left, $ptr_to(^b_node), false, 0);

const unique b_node.right: $field;

axiom $def_phys_field(^b_node, b_node.right, $ptr_to(^b_node), false, 8);

const unique b_node.key: $field;

axiom $def_phys_field(^b_node, b_node.key, ^^i4, false, 16);

const unique b_node.prio: $field;

axiom $def_phys_field(^b_node, b_node.prio, ^^i4, false, 20);

function F#glob_reach() : $oset;

const unique cf#glob_reach: $pure_function;

axiom $function_arg_type(cf#glob_reach, 0, ^$#oset);

procedure glob_reach() returns ($result: $oset);
  free ensures $result == F#glob_reach();
  free ensures $call_transition(old($s), $s);



const unique ^$#_purecall_handler#1: $ctype;

axiom $def_fnptr_type(^$#_purecall_handler#1);

type $#_purecall_handler#1;

const unique ^$#_invalid_parameter_handler#2: $ctype;

axiom $def_fnptr_type(^$#_invalid_parameter_handler#2);

type $#_invalid_parameter_handler#2;

const unique ^$#treap_insert_rec.c..36261#3: $ctype;

axiom $def_fnptr_type(^$#treap_insert_rec.c..36261#3);

type $#treap_insert_rec.c..36261#3;

const unique ^$#_PtFuncCompare#4: $ctype;

axiom $def_fnptr_type(^$#_PtFuncCompare#4);

type $#_PtFuncCompare#4;

const unique ^$#_PtFuncCompare#5: $ctype;

axiom $def_fnptr_type(^$#_PtFuncCompare#5);

type $#_PtFuncCompare#5;

const unique ^$#_PtFuncCompare#6: $ctype;

axiom $def_fnptr_type(^$#_PtFuncCompare#6);

type $#_PtFuncCompare#6;

const unique ^$#_PtFuncCompare#7: $ctype;

axiom $def_fnptr_type(^$#_PtFuncCompare#7);

type $#_PtFuncCompare#7;

const unique ^$#_onexit_t#8: $ctype;

axiom $def_fnptr_type(^$#_onexit_t#8);

type $#_onexit_t#8;

function F##int_max(SP#x: int, SP#y: int) : int;

const unique cf##int_max: $pure_function;

axiom (forall SP#x: int, SP#y: int :: { F##int_max(SP#x, SP#y) } $in_range_i4(F##int_max(SP#x, SP#y)));

axiom $function_arg_type(cf##int_max, 0, ^^i4);

axiom $function_arg_type(cf##int_max, 1, ^^i4);

axiom $function_arg_type(cf##int_max, 2, ^^i4);

procedure #int_max(SP#x: int, SP#y: int) returns ($result: int);
  free ensures $in_range_i4($result);
  free ensures $result == F##int_max(SP#x, SP#y);
  free ensures $call_transition(old($s), $s);



function F##int_min(SP#x: int, SP#y: int) : int;

const unique cf##int_min: $pure_function;

axiom (forall SP#x: int, SP#y: int :: { F##int_min(SP#x, SP#y) } $in_range_i4(F##int_min(SP#x, SP#y)));

axiom $function_arg_type(cf##int_min, 0, ^^i4);

axiom $function_arg_type(cf##int_min, 1, ^^i4);

axiom $function_arg_type(cf##int_min, 2, ^^i4);

procedure #int_min(SP#x: int, SP#y: int) returns ($result: int);
  free ensures $in_range_i4($result);
  free ensures $result == F##int_min(SP#x, SP#y);
  free ensures $call_transition(old($s), $s);



function F#treap(#s: $state, SP#root: $ptr) : bool;

const unique cf#treap: $pure_function;

axiom (forall #s: $state, SP#root: $ptr :: { F#treap(#s, SP#root) } 1 < $decreases_level ==> $is_null($phys_ptr_cast(SP#root, ^b_node)) ==> F#treap(#s, SP#root));

axiom $function_arg_type(cf#treap, 0, ^^bool);

axiom $function_arg_type(cf#treap, 1, $ptr_to(^b_node));

procedure treap(SP#root: $ptr) returns ($result: bool);
  ensures $is_null($phys_ptr_cast(SP#root, ^b_node)) ==> $result;
  free ensures $result == F#treap($s, SP#root);
  free ensures $call_transition(old($s), $s);



function F#treap_reach(#s: $state, SP#root: $ptr) : $oset;

const unique cf#treap_reach: $pure_function;

axiom (forall #s: $state, SP#root: $ptr :: { F#treap_reach(#s, SP#root) } 1 < $decreases_level ==> ($non_null($phys_ptr_cast(SP#root, ^b_node)) ==> $oset_in($phys_ptr_cast(SP#root, ^b_node), F#treap_reach(#s, SP#root))) && ($is_null($phys_ptr_cast(SP#root, ^b_node)) ==> F#treap_reach(#s, SP#root) == $oset_empty()));

axiom $function_arg_type(cf#treap_reach, 0, ^$#oset);

axiom $function_arg_type(cf#treap_reach, 1, $ptr_to(^b_node));

procedure treap_reach(SP#root: $ptr) returns ($result: $oset);
  ensures $non_null($phys_ptr_cast(SP#root, ^b_node)) ==> $oset_in($phys_ptr_cast(SP#root, ^b_node), $result);
  ensures $is_null($phys_ptr_cast(SP#root, ^b_node)) ==> $result == $oset_empty();
  free ensures $result == F#treap_reach($s, SP#root);
  free ensures $call_transition(old($s), $s);



function F#treap_keys(#s: $state, SP#root: $ptr) : $intset;

const unique cf#treap_keys: $pure_function;

axiom (forall #s: $state, SP#root: $ptr :: { F#treap_keys(#s, SP#root) } 1 < $decreases_level ==> ($non_null($phys_ptr_cast(SP#root, ^b_node)) ==> $intset_in($rd_inv(#s, b_node.key, $phys_ptr_cast(SP#root, ^b_node)), F#treap_keys(#s, SP#root))) && ($is_null($phys_ptr_cast(SP#root, ^b_node)) ==> F#treap_keys(#s, SP#root) == $intset_empty()));

axiom $function_arg_type(cf#treap_keys, 0, ^$#intset);

axiom $function_arg_type(cf#treap_keys, 1, $ptr_to(^b_node));

procedure treap_keys(SP#root: $ptr) returns ($result: $intset);
  ensures $non_null($phys_ptr_cast(SP#root, ^b_node)) ==> $intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(SP#root, ^b_node)), $result);
  ensures $is_null($phys_ptr_cast(SP#root, ^b_node)) ==> $result == $intset_empty();
  free ensures $result == F#treap_keys($s, SP#root);
  free ensures $call_transition(old($s), $s);



function F#treap_prios(#s: $state, SP#root: $ptr) : $intset;

const unique cf#treap_prios: $pure_function;

axiom (forall #s: $state, SP#root: $ptr :: { F#treap_prios(#s, SP#root) } 1 < $decreases_level ==> ($non_null($phys_ptr_cast(SP#root, ^b_node)) ==> $intset_in($rd_inv(#s, b_node.prio, $phys_ptr_cast(SP#root, ^b_node)), F#treap_prios(#s, SP#root))) && ($is_null($phys_ptr_cast(SP#root, ^b_node)) ==> F#treap_prios(#s, SP#root) == $intset_empty()));

axiom $function_arg_type(cf#treap_prios, 0, ^$#intset);

axiom $function_arg_type(cf#treap_prios, 1, $ptr_to(^b_node));

procedure treap_prios(SP#root: $ptr) returns ($result: $intset);
  ensures $non_null($phys_ptr_cast(SP#root, ^b_node)) ==> $intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(SP#root, ^b_node)), $result);
  ensures $is_null($phys_ptr_cast(SP#root, ^b_node)) ==> $result == $intset_empty();
  free ensures $result == F#treap_prios($s, SP#root);
  free ensures $call_transition(old($s), $s);



function F#treap_min_key(#s: $state, SP#root: $ptr) : int;

const unique cf#treap_min_key: $pure_function;

axiom (forall #s: $state, SP#root: $ptr :: { F#treap_min_key(#s, SP#root) } 1 < $decreases_level ==> $in_range_i4(F#treap_min_key(#s, SP#root)) && ($non_null($phys_ptr_cast(SP#root, ^b_node)) && $is_null($rd_phys_ptr(#s, b_node.left, $phys_ptr_cast(SP#root, ^b_node), ^b_node)) && $is_null($rd_phys_ptr(#s, b_node.right, $phys_ptr_cast(SP#root, ^b_node), ^b_node)) ==> F#treap_min_key(#s, SP#root) == $rd_inv(#s, b_node.key, $phys_ptr_cast(SP#root, ^b_node))));

axiom $function_arg_type(cf#treap_min_key, 0, ^^i4);

axiom $function_arg_type(cf#treap_min_key, 1, $ptr_to(^b_node));

procedure treap_min_key(SP#root: $ptr) returns ($result: int);
  free ensures $in_range_i4($result);
  ensures $non_null($phys_ptr_cast(SP#root, ^b_node)) && $is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SP#root, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SP#root, ^b_node), ^b_node)) ==> $result == $rd_inv($s, b_node.key, $phys_ptr_cast(SP#root, ^b_node));
  free ensures $result == F#treap_min_key($s, SP#root);
  free ensures $call_transition(old($s), $s);



function F#treap_max_key(#s: $state, SP#root: $ptr) : int;

const unique cf#treap_max_key: $pure_function;

axiom (forall #s: $state, SP#root: $ptr :: { F#treap_max_key(#s, SP#root) } 1 < $decreases_level ==> $in_range_i4(F#treap_max_key(#s, SP#root)) && ($non_null($phys_ptr_cast(SP#root, ^b_node)) && $is_null($rd_phys_ptr(#s, b_node.left, $phys_ptr_cast(SP#root, ^b_node), ^b_node)) && $is_null($rd_phys_ptr(#s, b_node.right, $phys_ptr_cast(SP#root, ^b_node), ^b_node)) ==> F#treap_max_key(#s, SP#root) == $rd_inv(#s, b_node.key, $phys_ptr_cast(SP#root, ^b_node))));

axiom $function_arg_type(cf#treap_max_key, 0, ^^i4);

axiom $function_arg_type(cf#treap_max_key, 1, $ptr_to(^b_node));

procedure treap_max_key(SP#root: $ptr) returns ($result: int);
  free ensures $in_range_i4($result);
  ensures $non_null($phys_ptr_cast(SP#root, ^b_node)) && $is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SP#root, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SP#root, ^b_node), ^b_node)) ==> $result == $rd_inv($s, b_node.key, $phys_ptr_cast(SP#root, ^b_node));
  free ensures $result == F#treap_max_key($s, SP#root);
  free ensures $call_transition(old($s), $s);



function F#treap_max_prio(#s: $state, SP#root: $ptr) : int;

const unique cf#treap_max_prio: $pure_function;

axiom (forall #s: $state, SP#root: $ptr :: { F#treap_max_prio(#s, SP#root) } 1 < $decreases_level ==> $in_range_i4(F#treap_max_prio(#s, SP#root)) && ($non_null($phys_ptr_cast(SP#root, ^b_node)) && $is_null($rd_phys_ptr(#s, b_node.left, $phys_ptr_cast(SP#root, ^b_node), ^b_node)) && $is_null($rd_phys_ptr(#s, b_node.right, $phys_ptr_cast(SP#root, ^b_node), ^b_node)) ==> F#treap_max_prio(#s, SP#root) == $rd_inv(#s, b_node.prio, $phys_ptr_cast(SP#root, ^b_node))));

axiom $function_arg_type(cf#treap_max_prio, 0, ^^i4);

axiom $function_arg_type(cf#treap_max_prio, 1, $ptr_to(^b_node));

procedure treap_max_prio(SP#root: $ptr) returns ($result: int);
  free ensures $in_range_i4($result);
  ensures $non_null($phys_ptr_cast(SP#root, ^b_node)) && $is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SP#root, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SP#root, ^b_node), ^b_node)) ==> $result == $rd_inv($s, b_node.prio, $phys_ptr_cast(SP#root, ^b_node));
  free ensures $result == F#treap_max_prio($s, SP#root);
  free ensures $call_transition(old($s), $s);



procedure treap_insert_rec(P#x: $ptr, P#k: int, P#p: int) returns ($result: $ptr);
  requires F#treap($s, $phys_ptr_cast(P#x, ^b_node));
  requires !$intset_in(P#k, F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)));
  requires !$intset_in(P#p, F#treap_prios($s, $phys_ptr_cast(P#x, ^b_node)));
  modifies $s, $cev_pc;
  ensures F#treap($s, $phys_ptr_cast($result, ^b_node));
  ensures F#treap_keys($s, $phys_ptr_cast($result, ^b_node)) == $intset_union(F#treap_keys(old($s), $phys_ptr_cast(P#x, ^b_node)), $intset_singleton(P#k));
  ensures F#treap_prios($s, $phys_ptr_cast($result, ^b_node)) == $intset_union(F#treap_prios(old($s), $phys_ptr_cast(P#x, ^b_node)), $intset_singleton(P#p));
// INV:BEGIN
  ensures $non_null($phys_ptr_cast($result, ^b_node));
  ensures $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast($result, ^b_node)) == $int_min(F#treap_min_key(old($s), $phys_ptr_cast(P#x, ^b_node)), P#k);
  ensures $is_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast($result, ^b_node)) == P#k;
  ensures $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast($result, ^b_node)) == $int_max(F#treap_max_key(old($s), $phys_ptr_cast(P#x, ^b_node)), P#k);
  ensures $is_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast($result, ^b_node)) == P#k;
  ensures $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast($result, ^b_node)) == $int_max(F#treap_max_prio(old($s), $phys_ptr_cast(P#x, ^b_node)), P#p);
  ensures $is_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast($result, ^b_node)) == P#p;
// INV:END
  ensures $non_null($phys_ptr_cast(P#x, ^b_node)) ==> P#p > F#treap_max_prio(old($s), $phys_ptr_cast(P#x, ^b_node)) ==> P#p == $rd_inv($s, b_node.prio, $phys_ptr_cast($result, ^b_node));
  ensures $intset_subset(F#treap_prios(old($s), $phys_ptr_cast(P#x, ^b_node)), F#treap_prios($s, $phys_ptr_cast($result, ^b_node)));
  ensures $intset_subset(F#treap_keys(old($s), $phys_ptr_cast(P#x, ^b_node)), F#treap_keys($s, $phys_ptr_cast($result, ^b_node)));
  ensures $intset_in(P#k, F#treap_keys($s, $phys_ptr_cast($result, ^b_node)));
  free ensures $writes_nothing(old($s), $s);
  free ensures $call_transition(old($s), $s);

// INV:PTR: P#x, $result
// INV:INT: P#k, P#p
// INV:LST: treap


implementation treap_insert_rec(P#x: $ptr, P#k: int, P#p: int) returns ($result: $ptr)
{
  var stmtexpr4#37: $state;
  var _dryad_S5#21: $state;
  var stmtexpr3#36: $state;
  var _dryad_S4#20: $state;
  var stmtexpr2#35: $state;
  var _dryad_S3#19: $state;
  var stmtexpr1#34: $state;
  var _dryad_S2#18: $state;
  var stmtexpr0#33: $ptr;
  var tmp2#17: $ptr;
  var L#rl: $ptr;
  var stmtexpr1#32: $state;
  var _dryad_S3#16: $state;
  var stmtexpr0#31: $state;
  var _dryad_S2#15: $state;
  var stmtexpr4#30: $oset;
  var res_treap_reach#2: $oset;
  var stmtexpr3#29: $state;
  var _dryad_S1#14: $state;
  var stmtexpr2#28: $state;
  var _dryad_S0#13: $state;
  var stmtexpr1#27: $ptr;
  var x1#12: $ptr;
  var stmtexpr0#26: $ptr;
  var x0#11: $ptr;
  var xr#10: $ptr;
  var xl#9: $ptr;
  var tmp#8: $ptr;
  var stmtexpr4#25: $state;
  var _dryad_S5#7: $state;
  var stmtexpr3#24: $state;
  var _dryad_S4#6: $state;
  var stmtexpr2#23: $state;
  var _dryad_S3#5: $state;
  var stmtexpr1#22: $state;
  var _dryad_S2#4: $state;
  var stmtexpr0#21: $ptr;
  var SL#tmp2: $ptr;
  var L#lr: $ptr;
  var stmtexpr1#20: $state;
  var _dryad_S3#3: $state;
  var stmtexpr0#19: $state;
  var _dryad_S2#2: $state;
  var stmtexpr4#18: $oset;
  var res_treap_reach#1: $oset;
  var stmtexpr3#17: $state;
  var _dryad_S1#1: $state;
  var stmtexpr2#16: $state;
  var _dryad_S0#0: $state;
  var stmtexpr1#15: $ptr;
  var SL#x1: $ptr;
  var stmtexpr0#14: $ptr;
  var SL#x0: $ptr;
  var L#xr: $ptr;
  var L#xl: $ptr;
  var L#tmp: $ptr;
  var stmtexpr10#13: $state;
  var SL#_dryad_S9: $state;
  var stmtexpr9#12: $state;
  var SL#_dryad_S8: $state;
  var stmtexpr8#11: $state;
  var SL#_dryad_S7: $state;
  var stmtexpr7#10: $state;
  var SL#_dryad_S6: $state;
  var stmtexpr6#9: $state;
  var SL#_dryad_S5: $state;
  var stmtexpr5#8: $state;
  var SL#_dryad_S4: $state;
  var stmtexpr4#7: $state;
  var SL#_dryad_S3: $state;
  var stmtexpr3#6: $state;
  var SL#_dryad_S2: $state;
  var stmtexpr2#5: $state;
  var SL#_dryad_S1: $state;
  var stmtexpr1#4: $oset;
  var stmtexpr0#3: $state;
  var SL#_dryad_S0: $state;
  var L#leaf: $ptr;
  var stmtexpr1#39: $oset;
  var stmtexpr0#38: $oset;
  var SL#_dryad_G1: $oset;
  var SL#_dryad_G0: $oset;
  var #wrTime$3^5.3: int;
  var #stackframe: int;

  anon9:
    assume $function_entry($s);
    assume $full_stop_ext(#tok$3^5.3, $s);
    assume $can_use_all_frame_axioms($s);
    assume #wrTime$3^5.3 == $current_timestamp($s);
    assume $def_writes($s, #wrTime$3^5.3, (lambda #p: $ptr :: false));
    // assume true
    // assume @in_range_i4(k); 
    assume $in_range_i4(P#k);
    // assume @in_range_i4(p); 
    assume $in_range_i4(P#p);
    // assume @decreases_level_is(2147483647); 
    assume 2147483647 == $decreases_level;
    // assume true
    //  --- Dryad annotated function --- 
    // _math \oset _dryad_G0; 
    // _math \oset _dryad_G1; 
    // _dryad_G0 := treap_reach(x); 
    call SL#_dryad_G0 := treap_reach($phys_ptr_cast(P#x, ^b_node));
    assume $full_stop_ext(#tok$4^0.0, $s);
    // _math \oset stmtexpr0#38; 
    // stmtexpr0#38 := _dryad_G0; 
    stmtexpr0#38 := SL#_dryad_G0;
    // _dryad_G1 := _dryad_G0; 
    SL#_dryad_G1 := SL#_dryad_G0;
    // _math \oset stmtexpr1#39; 
    // stmtexpr1#39 := _dryad_G1; 
    stmtexpr1#39 := SL#_dryad_G1;
    // assume ==>(@_vcc_ptr_neq_null(x), ==(treap(x), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x->left))), treap(*((x->right)))), unchecked!(@_vcc_oset_in(x, @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->key)), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->prio)), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))), @_vcc_oset_disjoint(treap_reach(*((x->left))), treap_reach(*((x->right))))), @_vcc_intset_disjoint(treap_keys(*((x->left))), treap_keys(*((x->right))))), @_vcc_intset_disjoint(treap_prios(*((x->left))), treap_prios(*((x->right))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_key(*((x->left))), *((x->key))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(*((x->key)), treap_min_key(*((x->right)))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_prio(*((x->left))), *((x->prio))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(treap_max_prio(*((x->right))), *((x->prio))))))); 
    assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap($s, $phys_ptr_cast(P#x, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(P#x, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))));
    // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_reach(x), @_vcc_oset_union(@_vcc_oset_singleton(x), @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))); 
    assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(P#x, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(P#x, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
    // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_keys(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->key))), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))); 
    assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
    // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), @\int_max(treap_max_key(*((x->left))), treap_max_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->right)))))))); 
    assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
    // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), @\int_max(treap_max_prio(*((x->left))), treap_max_prio(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->right)))))))); 
    assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
    // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), @\int_min(treap_min_key(*((x->left))), treap_min_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->right)))))))); 
    assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
    // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_prios(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->prio))), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))); 
    assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
    // assume ==>(@_vcc_ptr_neq_null(x), &&(@_vcc_mutable(@state, x), @writes_check(x))); 
    assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> $mutable($s, $phys_ptr_cast(P#x, ^b_node)) && $top_writable($s, #wrTime$3^5.3, $phys_ptr_cast(P#x, ^b_node));
    assume true;
    // if (@_vcc_ptr_eq_null(x)) ...
    if ($is_null($phys_ptr_cast(P#x, ^b_node)))
    {
      anon1:
        // assume ==>(@_vcc_ptr_neq_null(x), ==(treap(x), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x->left))), treap(*((x->right)))), unchecked!(@_vcc_oset_in(x, @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->key)), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->prio)), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))), @_vcc_oset_disjoint(treap_reach(*((x->left))), treap_reach(*((x->right))))), @_vcc_intset_disjoint(treap_keys(*((x->left))), treap_keys(*((x->right))))), @_vcc_intset_disjoint(treap_prios(*((x->left))), treap_prios(*((x->right))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_key(*((x->left))), *((x->key))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(*((x->key)), treap_min_key(*((x->right)))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_prio(*((x->left))), *((x->prio))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(treap_max_prio(*((x->right))), *((x->prio))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap($s, $phys_ptr_cast(P#x, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(P#x, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_reach(x), @_vcc_oset_union(@_vcc_oset_singleton(x), @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(P#x, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(P#x, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_keys(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->key))), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), @\int_max(treap_max_key(*((x->left))), treap_max_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->right)))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), @\int_max(treap_max_prio(*((x->left))), treap_max_prio(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->right)))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), @\int_min(treap_min_key(*((x->left))), treap_min_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->right)))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_prios(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->prio))), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // struct b_node* leaf; 
        // _math \state _dryad_S0; 
        // _dryad_S0 := @_vcc_current_state(@state); 
        SL#_dryad_S0 := $current_state($s);
        // _math \state stmtexpr0#3; 
        // stmtexpr0#3 := _dryad_S0; 
        stmtexpr0#3 := SL#_dryad_S0;
        // leaf := _vcc_alloc(@_vcc_typeof((struct b_node*)@null)); 
        call L#leaf := $alloc(^b_node);
        assume $full_stop_ext(#tok$3^35.20, $s);
        // assume !(@_vcc_oset_in(leaf, @_vcc_oset_union(_dryad_G0, _dryad_G1))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), $oset_union(SL#_dryad_G0, SL#_dryad_G1));
        // _dryad_G1 := @_vcc_oset_union(_dryad_G0, @_vcc_oset_singleton(leaf)); 
        SL#_dryad_G1 := $oset_union(SL#_dryad_G0, $oset_singleton($phys_ptr_cast(L#leaf, ^b_node)));
        // _math \oset stmtexpr1#4; 
        // stmtexpr1#4 := _dryad_G1; 
        stmtexpr1#4 := SL#_dryad_G1;
        // assume ==(glob_reach(), _dryad_G1); 
        assume F#glob_reach() == SL#_dryad_G1;
        // _math \state _dryad_S1; 
        // _dryad_S1 := @_vcc_current_state(@state); 
        SL#_dryad_S1 := $current_state($s);
        // _math \state stmtexpr2#5; 
        // stmtexpr2#5 := _dryad_S1; 
        stmtexpr2#5 := SL#_dryad_S1;
        // assume ==>(@_vcc_ptr_neq_null(leaf), ==(treap(leaf), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((leaf->left))), treap(*((leaf->right)))), unchecked!(@_vcc_oset_in(leaf, @_vcc_oset_union(treap_reach(*((leaf->left))), treap_reach(*((leaf->right))))))), unchecked!(@_vcc_intset_in(*((leaf->key)), @_vcc_intset_union(treap_keys(*((leaf->left))), treap_keys(*((leaf->right))))))), unchecked!(@_vcc_intset_in(*((leaf->prio)), @_vcc_intset_union(treap_prios(*((leaf->left))), treap_prios(*((leaf->right))))))), @_vcc_oset_disjoint(treap_reach(*((leaf->left))), treap_reach(*((leaf->right))))), @_vcc_intset_disjoint(treap_keys(*((leaf->left))), treap_keys(*((leaf->right))))), @_vcc_intset_disjoint(treap_prios(*((leaf->left))), treap_prios(*((leaf->right))))), ==>(@_vcc_ptr_neq_null(*((leaf->left))), <(treap_max_key(*((leaf->left))), *((leaf->key))))), ==>(@_vcc_ptr_neq_null(*((leaf->right))), <(*((leaf->key)), treap_min_key(*((leaf->right)))))), ==>(@_vcc_ptr_neq_null(*((leaf->left))), <(treap_max_prio(*((leaf->left))), *((leaf->prio))))), ==>(@_vcc_ptr_neq_null(*((leaf->right))), <(treap_max_prio(*((leaf->right))), *((leaf->prio))))))); 
        assume $non_null($phys_ptr_cast(L#leaf, ^b_node)) ==> F#treap($s, $phys_ptr_cast(L#leaf, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(L#leaf, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(L#leaf, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(L#leaf, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(L#leaf, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#leaf, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#leaf, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#leaf, ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(leaf), ==(treap_reach(leaf), @_vcc_oset_union(@_vcc_oset_singleton(leaf), @_vcc_oset_union(treap_reach(*((leaf->left))), treap_reach(*((leaf->right))))))); 
        assume $non_null($phys_ptr_cast(L#leaf, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(L#leaf, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(L#leaf, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(leaf), ==(treap_keys(leaf), @_vcc_intset_union(@_vcc_intset_singleton(*((leaf->key))), @_vcc_intset_union(treap_keys(*((leaf->left))), treap_keys(*((leaf->right))))))); 
        assume $non_null($phys_ptr_cast(L#leaf, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(L#leaf, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(L#leaf, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(leaf), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((leaf->left))), @_vcc_ptr_neq_null(*((leaf->right)))), ==(treap_max_key(leaf), @\int_max(*((leaf->key)), @\int_max(treap_max_key(*((leaf->left))), treap_max_key(*((leaf->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((leaf->left))), @_vcc_ptr_eq_null(*((leaf->right)))), ==(treap_max_key(leaf), @\int_max(*((leaf->key)), treap_max_key(*((leaf->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((leaf->left))), @_vcc_ptr_neq_null(*((leaf->right)))), ==(treap_max_key(leaf), @\int_max(*((leaf->key)), treap_max_key(*((leaf->right)))))))); 
        assume $non_null($phys_ptr_cast(L#leaf, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#leaf, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#leaf, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#leaf, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#leaf, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#leaf, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#leaf, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(leaf), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((leaf->left))), @_vcc_ptr_neq_null(*((leaf->right)))), ==(treap_max_prio(leaf), @\int_max(*((leaf->prio)), @\int_max(treap_max_prio(*((leaf->left))), treap_max_prio(*((leaf->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((leaf->left))), @_vcc_ptr_eq_null(*((leaf->right)))), ==(treap_max_prio(leaf), @\int_max(*((leaf->prio)), treap_max_prio(*((leaf->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((leaf->left))), @_vcc_ptr_neq_null(*((leaf->right)))), ==(treap_max_prio(leaf), @\int_max(*((leaf->prio)), treap_max_prio(*((leaf->right)))))))); 
        assume $non_null($phys_ptr_cast(L#leaf, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#leaf, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#leaf, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#leaf, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#leaf, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#leaf, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#leaf, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(leaf), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((leaf->left))), @_vcc_ptr_neq_null(*((leaf->right)))), ==(treap_min_key(leaf), @\int_min(*((leaf->key)), @\int_min(treap_min_key(*((leaf->left))), treap_min_key(*((leaf->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((leaf->left))), @_vcc_ptr_eq_null(*((leaf->right)))), ==(treap_min_key(leaf), @\int_min(*((leaf->key)), treap_min_key(*((leaf->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((leaf->left))), @_vcc_ptr_neq_null(*((leaf->right)))), ==(treap_min_key(leaf), @\int_min(*((leaf->key)), treap_min_key(*((leaf->right)))))))); 
        assume $non_null($phys_ptr_cast(L#leaf, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#leaf, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#leaf, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#leaf, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#leaf, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#leaf, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#leaf, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(leaf), ==(treap_prios(leaf), @_vcc_intset_union(@_vcc_intset_singleton(*((leaf->prio))), @_vcc_intset_union(treap_prios(*((leaf->left))), treap_prios(*((leaf->right))))))); 
        assume $non_null($phys_ptr_cast(L#leaf, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(L#leaf, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(L#leaf, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), ==(treap(x), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x->left))), treap(*((x->right)))), unchecked!(@_vcc_oset_in(x, @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->key)), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->prio)), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))), @_vcc_oset_disjoint(treap_reach(*((x->left))), treap_reach(*((x->right))))), @_vcc_intset_disjoint(treap_keys(*((x->left))), treap_keys(*((x->right))))), @_vcc_intset_disjoint(treap_prios(*((x->left))), treap_prios(*((x->right))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_key(*((x->left))), *((x->key))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(*((x->key)), treap_min_key(*((x->right)))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_prio(*((x->left))), *((x->prio))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(treap_max_prio(*((x->right))), *((x->prio))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap($s, $phys_ptr_cast(P#x, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(P#x, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_reach(x), @_vcc_oset_union(@_vcc_oset_singleton(x), @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(P#x, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(P#x, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_keys(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->key))), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), @\int_max(treap_max_key(*((x->left))), treap_max_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->right)))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), @\int_max(treap_max_prio(*((x->left))), treap_max_prio(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->right)))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), @\int_min(treap_min_key(*((x->left))), treap_min_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->right)))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_prios(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->prio))), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S0, treap_reach(x)))), ==(old(_dryad_S0, treap(x)), old(_dryad_S1, treap(x)))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S0, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap(SL#_dryad_S0, $phys_ptr_cast(P#x, ^b_node)) == F#treap(SL#_dryad_S1, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S0, treap_reach(x)))), ==(old(_dryad_S0, treap_reach(x)), old(_dryad_S1, treap_reach(x)))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S0, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_reach(SL#_dryad_S0, $phys_ptr_cast(P#x, ^b_node)) == F#treap_reach(SL#_dryad_S1, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S0, treap_reach(x)))), ==(old(_dryad_S0, treap_keys(x)), old(_dryad_S1, treap_keys(x)))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S0, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_keys(SL#_dryad_S0, $phys_ptr_cast(P#x, ^b_node)) == F#treap_keys(SL#_dryad_S1, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S0, treap_reach(x)))), ==(old(_dryad_S0, treap_max_key(x)), old(_dryad_S1, treap_max_key(x)))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S0, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_max_key(SL#_dryad_S0, $phys_ptr_cast(P#x, ^b_node)) == F#treap_max_key(SL#_dryad_S1, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S0, treap_reach(x)))), ==(old(_dryad_S0, treap_max_prio(x)), old(_dryad_S1, treap_max_prio(x)))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S0, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_max_prio(SL#_dryad_S0, $phys_ptr_cast(P#x, ^b_node)) == F#treap_max_prio(SL#_dryad_S1, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S0, treap_reach(x)))), ==(old(_dryad_S0, treap_min_key(x)), old(_dryad_S1, treap_min_key(x)))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S0, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_min_key(SL#_dryad_S0, $phys_ptr_cast(P#x, ^b_node)) == F#treap_min_key(SL#_dryad_S1, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S0, treap_reach(x)))), ==(old(_dryad_S0, treap_prios(x)), old(_dryad_S1, treap_prios(x)))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S0, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_prios(SL#_dryad_S0, $phys_ptr_cast(P#x, ^b_node)) == F#treap_prios(SL#_dryad_S1, $phys_ptr_cast(P#x, ^b_node));
        // assume @_vcc_ptr_neq_null(leaf); 
        assume $non_null($phys_ptr_cast(L#leaf, ^b_node));
        // _math \state _dryad_S2; 
        // _dryad_S2 := @_vcc_current_state(@state); 
        SL#_dryad_S2 := $current_state($s);
        // _math \state stmtexpr3#6; 
        // stmtexpr3#6 := _dryad_S2; 
        stmtexpr3#6 := SL#_dryad_S2;
        // assert @prim_writes_check((leaf->key)); 
        assert $writable_prim($s, #wrTime$3^5.3, $dot($phys_ptr_cast(L#leaf, ^b_node), b_node.key));
        // *(leaf->key) := k; 
        call $write_int(b_node.key, $phys_ptr_cast(L#leaf, ^b_node), P#k);
        assume $full_stop_ext(#tok$3^38.5, $s);
        // _math \state _dryad_S3; 
        // _dryad_S3 := @_vcc_current_state(@state); 
        SL#_dryad_S3 := $current_state($s);
        // _math \state stmtexpr4#7; 
        // stmtexpr4#7 := _dryad_S3; 
        stmtexpr4#7 := SL#_dryad_S3;
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S2, treap_reach(*((leaf->left)))))), ==(old(_dryad_S2, treap(*((leaf->left)))), old(_dryad_S3, treap(*((leaf->left)))))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S2, $rd_phys_ptr(SL#_dryad_S2, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) ==> F#treap(SL#_dryad_S2, $rd_phys_ptr(SL#_dryad_S2, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) == F#treap(SL#_dryad_S3, $rd_phys_ptr(SL#_dryad_S3, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S2, treap_reach(*((leaf->left)))))), ==(old(_dryad_S2, treap_reach(*((leaf->left)))), old(_dryad_S3, treap_reach(*((leaf->left)))))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S2, $rd_phys_ptr(SL#_dryad_S2, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) ==> F#treap_reach(SL#_dryad_S2, $rd_phys_ptr(SL#_dryad_S2, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) == F#treap_reach(SL#_dryad_S3, $rd_phys_ptr(SL#_dryad_S3, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S2, treap_reach(*((leaf->left)))))), ==(old(_dryad_S2, treap_keys(*((leaf->left)))), old(_dryad_S3, treap_keys(*((leaf->left)))))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S2, $rd_phys_ptr(SL#_dryad_S2, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) ==> F#treap_keys(SL#_dryad_S2, $rd_phys_ptr(SL#_dryad_S2, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) == F#treap_keys(SL#_dryad_S3, $rd_phys_ptr(SL#_dryad_S3, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S2, treap_reach(*((leaf->left)))))), ==(old(_dryad_S2, treap_max_key(*((leaf->left)))), old(_dryad_S3, treap_max_key(*((leaf->left)))))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S2, $rd_phys_ptr(SL#_dryad_S2, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) ==> F#treap_max_key(SL#_dryad_S2, $rd_phys_ptr(SL#_dryad_S2, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) == F#treap_max_key(SL#_dryad_S3, $rd_phys_ptr(SL#_dryad_S3, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S2, treap_reach(*((leaf->left)))))), ==(old(_dryad_S2, treap_max_prio(*((leaf->left)))), old(_dryad_S3, treap_max_prio(*((leaf->left)))))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S2, $rd_phys_ptr(SL#_dryad_S2, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) ==> F#treap_max_prio(SL#_dryad_S2, $rd_phys_ptr(SL#_dryad_S2, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) == F#treap_max_prio(SL#_dryad_S3, $rd_phys_ptr(SL#_dryad_S3, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S2, treap_reach(*((leaf->left)))))), ==(old(_dryad_S2, treap_min_key(*((leaf->left)))), old(_dryad_S3, treap_min_key(*((leaf->left)))))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S2, $rd_phys_ptr(SL#_dryad_S2, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) ==> F#treap_min_key(SL#_dryad_S2, $rd_phys_ptr(SL#_dryad_S2, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) == F#treap_min_key(SL#_dryad_S3, $rd_phys_ptr(SL#_dryad_S3, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S2, treap_reach(*((leaf->left)))))), ==(old(_dryad_S2, treap_prios(*((leaf->left)))), old(_dryad_S3, treap_prios(*((leaf->left)))))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S2, $rd_phys_ptr(SL#_dryad_S2, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) ==> F#treap_prios(SL#_dryad_S2, $rd_phys_ptr(SL#_dryad_S2, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) == F#treap_prios(SL#_dryad_S3, $rd_phys_ptr(SL#_dryad_S3, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S2, treap_reach(*((leaf->right)))))), ==(old(_dryad_S2, treap(*((leaf->right)))), old(_dryad_S3, treap(*((leaf->right)))))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S2, $rd_phys_ptr(SL#_dryad_S2, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) ==> F#treap(SL#_dryad_S2, $rd_phys_ptr(SL#_dryad_S2, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) == F#treap(SL#_dryad_S3, $rd_phys_ptr(SL#_dryad_S3, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S2, treap_reach(*((leaf->right)))))), ==(old(_dryad_S2, treap_reach(*((leaf->right)))), old(_dryad_S3, treap_reach(*((leaf->right)))))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S2, $rd_phys_ptr(SL#_dryad_S2, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) ==> F#treap_reach(SL#_dryad_S2, $rd_phys_ptr(SL#_dryad_S2, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) == F#treap_reach(SL#_dryad_S3, $rd_phys_ptr(SL#_dryad_S3, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S2, treap_reach(*((leaf->right)))))), ==(old(_dryad_S2, treap_keys(*((leaf->right)))), old(_dryad_S3, treap_keys(*((leaf->right)))))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S2, $rd_phys_ptr(SL#_dryad_S2, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) ==> F#treap_keys(SL#_dryad_S2, $rd_phys_ptr(SL#_dryad_S2, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) == F#treap_keys(SL#_dryad_S3, $rd_phys_ptr(SL#_dryad_S3, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S2, treap_reach(*((leaf->right)))))), ==(old(_dryad_S2, treap_max_key(*((leaf->right)))), old(_dryad_S3, treap_max_key(*((leaf->right)))))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S2, $rd_phys_ptr(SL#_dryad_S2, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) ==> F#treap_max_key(SL#_dryad_S2, $rd_phys_ptr(SL#_dryad_S2, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) == F#treap_max_key(SL#_dryad_S3, $rd_phys_ptr(SL#_dryad_S3, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S2, treap_reach(*((leaf->right)))))), ==(old(_dryad_S2, treap_max_prio(*((leaf->right)))), old(_dryad_S3, treap_max_prio(*((leaf->right)))))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S2, $rd_phys_ptr(SL#_dryad_S2, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) ==> F#treap_max_prio(SL#_dryad_S2, $rd_phys_ptr(SL#_dryad_S2, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) == F#treap_max_prio(SL#_dryad_S3, $rd_phys_ptr(SL#_dryad_S3, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S2, treap_reach(*((leaf->right)))))), ==(old(_dryad_S2, treap_min_key(*((leaf->right)))), old(_dryad_S3, treap_min_key(*((leaf->right)))))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S2, $rd_phys_ptr(SL#_dryad_S2, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) ==> F#treap_min_key(SL#_dryad_S2, $rd_phys_ptr(SL#_dryad_S2, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) == F#treap_min_key(SL#_dryad_S3, $rd_phys_ptr(SL#_dryad_S3, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S2, treap_reach(*((leaf->right)))))), ==(old(_dryad_S2, treap_prios(*((leaf->right)))), old(_dryad_S3, treap_prios(*((leaf->right)))))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S2, $rd_phys_ptr(SL#_dryad_S2, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) ==> F#treap_prios(SL#_dryad_S2, $rd_phys_ptr(SL#_dryad_S2, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) == F#treap_prios(SL#_dryad_S3, $rd_phys_ptr(SL#_dryad_S3, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node));
        // assume ==(old(_dryad_S2, treap_reach(leaf)), old(_dryad_S3, treap_reach(leaf))); 
        assume F#treap_reach(SL#_dryad_S2, $phys_ptr_cast(L#leaf, ^b_node)) == F#treap_reach(SL#_dryad_S3, $phys_ptr_cast(L#leaf, ^b_node));
        // assume ==(old(_dryad_S2, treap_max_prio(leaf)), old(_dryad_S3, treap_max_prio(leaf))); 
        assume F#treap_max_prio(SL#_dryad_S2, $phys_ptr_cast(L#leaf, ^b_node)) == F#treap_max_prio(SL#_dryad_S3, $phys_ptr_cast(L#leaf, ^b_node));
        // assume ==(old(_dryad_S2, treap_prios(leaf)), old(_dryad_S3, treap_prios(leaf))); 
        assume F#treap_prios(SL#_dryad_S2, $phys_ptr_cast(L#leaf, ^b_node)) == F#treap_prios(SL#_dryad_S3, $phys_ptr_cast(L#leaf, ^b_node));
        // assume ==(old(_dryad_S2, treap_reach(x)), old(_dryad_S3, treap_reach(x))); 
        assume F#treap_reach(SL#_dryad_S2, $phys_ptr_cast(P#x, ^b_node)) == F#treap_reach(SL#_dryad_S3, $phys_ptr_cast(P#x, ^b_node));
        // assume ==(old(_dryad_S2, treap_max_prio(x)), old(_dryad_S3, treap_max_prio(x))); 
        assume F#treap_max_prio(SL#_dryad_S2, $phys_ptr_cast(P#x, ^b_node)) == F#treap_max_prio(SL#_dryad_S3, $phys_ptr_cast(P#x, ^b_node));
        // assume ==(old(_dryad_S2, treap_prios(x)), old(_dryad_S3, treap_prios(x))); 
        assume F#treap_prios(SL#_dryad_S2, $phys_ptr_cast(P#x, ^b_node)) == F#treap_prios(SL#_dryad_S3, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S2, treap_reach(x)))), ==(old(_dryad_S2, treap(x)), old(_dryad_S3, treap(x)))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S2, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap(SL#_dryad_S2, $phys_ptr_cast(P#x, ^b_node)) == F#treap(SL#_dryad_S3, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S2, treap_reach(x)))), ==(old(_dryad_S2, treap_reach(x)), old(_dryad_S3, treap_reach(x)))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S2, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_reach(SL#_dryad_S2, $phys_ptr_cast(P#x, ^b_node)) == F#treap_reach(SL#_dryad_S3, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S2, treap_reach(x)))), ==(old(_dryad_S2, treap_keys(x)), old(_dryad_S3, treap_keys(x)))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S2, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_keys(SL#_dryad_S2, $phys_ptr_cast(P#x, ^b_node)) == F#treap_keys(SL#_dryad_S3, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S2, treap_reach(x)))), ==(old(_dryad_S2, treap_max_key(x)), old(_dryad_S3, treap_max_key(x)))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S2, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_max_key(SL#_dryad_S2, $phys_ptr_cast(P#x, ^b_node)) == F#treap_max_key(SL#_dryad_S3, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S2, treap_reach(x)))), ==(old(_dryad_S2, treap_max_prio(x)), old(_dryad_S3, treap_max_prio(x)))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S2, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_max_prio(SL#_dryad_S2, $phys_ptr_cast(P#x, ^b_node)) == F#treap_max_prio(SL#_dryad_S3, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S2, treap_reach(x)))), ==(old(_dryad_S2, treap_min_key(x)), old(_dryad_S3, treap_min_key(x)))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S2, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_min_key(SL#_dryad_S2, $phys_ptr_cast(P#x, ^b_node)) == F#treap_min_key(SL#_dryad_S3, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S2, treap_reach(x)))), ==(old(_dryad_S2, treap_prios(x)), old(_dryad_S3, treap_prios(x)))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S2, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_prios(SL#_dryad_S2, $phys_ptr_cast(P#x, ^b_node)) == F#treap_prios(SL#_dryad_S3, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(!(@_vcc_ptr_eq_pure(leaf, x)), @_vcc_ptr_eq_pure(*((x->left)), old(_dryad_S2, *((x->left))))); 
        assume !($phys_ptr_cast(L#leaf, ^b_node) == $phys_ptr_cast(P#x, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node) == $rd_phys_ptr(SL#_dryad_S2, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node);
        // assume ==>(!(@_vcc_ptr_eq_pure(leaf, x)), @_vcc_ptr_eq_pure(*((x->right)), old(_dryad_S2, *((x->right))))); 
        assume !($phys_ptr_cast(L#leaf, ^b_node) == $phys_ptr_cast(P#x, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node) == $rd_phys_ptr(SL#_dryad_S2, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node);
        // assume ==>(!(@_vcc_ptr_eq_pure(leaf, x)), ==(*((x->key)), old(_dryad_S2, *((x->key))))); 
        assume !($phys_ptr_cast(L#leaf, ^b_node) == $phys_ptr_cast(P#x, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) == $rd_inv(SL#_dryad_S2, b_node.key, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(!(@_vcc_ptr_eq_pure(leaf, x)), ==(*((x->prio)), old(_dryad_S2, *((x->prio))))); 
        assume !($phys_ptr_cast(L#leaf, ^b_node) == $phys_ptr_cast(P#x, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)) == $rd_inv(SL#_dryad_S2, b_node.prio, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(@_vcc_ptr_neq_null(x), ==(treap(x), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x->left))), treap(*((x->right)))), unchecked!(@_vcc_oset_in(x, @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->key)), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->prio)), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))), @_vcc_oset_disjoint(treap_reach(*((x->left))), treap_reach(*((x->right))))), @_vcc_intset_disjoint(treap_keys(*((x->left))), treap_keys(*((x->right))))), @_vcc_intset_disjoint(treap_prios(*((x->left))), treap_prios(*((x->right))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_key(*((x->left))), *((x->key))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(*((x->key)), treap_min_key(*((x->right)))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_prio(*((x->left))), *((x->prio))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(treap_max_prio(*((x->right))), *((x->prio))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap($s, $phys_ptr_cast(P#x, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(P#x, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_reach(x), @_vcc_oset_union(@_vcc_oset_singleton(x), @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(P#x, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(P#x, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_keys(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->key))), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), @\int_max(treap_max_key(*((x->left))), treap_max_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->right)))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), @\int_max(treap_max_prio(*((x->left))), treap_max_prio(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->right)))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), @\int_min(treap_min_key(*((x->left))), treap_min_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->right)))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_prios(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->prio))), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(leaf), ==(treap(leaf), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((leaf->left))), treap(*((leaf->right)))), unchecked!(@_vcc_oset_in(leaf, @_vcc_oset_union(treap_reach(*((leaf->left))), treap_reach(*((leaf->right))))))), unchecked!(@_vcc_intset_in(*((leaf->key)), @_vcc_intset_union(treap_keys(*((leaf->left))), treap_keys(*((leaf->right))))))), unchecked!(@_vcc_intset_in(*((leaf->prio)), @_vcc_intset_union(treap_prios(*((leaf->left))), treap_prios(*((leaf->right))))))), @_vcc_oset_disjoint(treap_reach(*((leaf->left))), treap_reach(*((leaf->right))))), @_vcc_intset_disjoint(treap_keys(*((leaf->left))), treap_keys(*((leaf->right))))), @_vcc_intset_disjoint(treap_prios(*((leaf->left))), treap_prios(*((leaf->right))))), ==>(@_vcc_ptr_neq_null(*((leaf->left))), <(treap_max_key(*((leaf->left))), *((leaf->key))))), ==>(@_vcc_ptr_neq_null(*((leaf->right))), <(*((leaf->key)), treap_min_key(*((leaf->right)))))), ==>(@_vcc_ptr_neq_null(*((leaf->left))), <(treap_max_prio(*((leaf->left))), *((leaf->prio))))), ==>(@_vcc_ptr_neq_null(*((leaf->right))), <(treap_max_prio(*((leaf->right))), *((leaf->prio))))))); 
        assume $non_null($phys_ptr_cast(L#leaf, ^b_node)) ==> F#treap($s, $phys_ptr_cast(L#leaf, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(L#leaf, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(L#leaf, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(L#leaf, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(L#leaf, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#leaf, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#leaf, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#leaf, ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(leaf), ==(treap_keys(leaf), @_vcc_intset_union(@_vcc_intset_singleton(*((leaf->key))), @_vcc_intset_union(treap_keys(*((leaf->left))), treap_keys(*((leaf->right))))))); 
        assume $non_null($phys_ptr_cast(L#leaf, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(L#leaf, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(L#leaf, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(leaf), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((leaf->left))), @_vcc_ptr_neq_null(*((leaf->right)))), ==(treap_max_key(leaf), @\int_max(*((leaf->key)), @\int_max(treap_max_key(*((leaf->left))), treap_max_key(*((leaf->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((leaf->left))), @_vcc_ptr_eq_null(*((leaf->right)))), ==(treap_max_key(leaf), @\int_max(*((leaf->key)), treap_max_key(*((leaf->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((leaf->left))), @_vcc_ptr_neq_null(*((leaf->right)))), ==(treap_max_key(leaf), @\int_max(*((leaf->key)), treap_max_key(*((leaf->right)))))))); 
        assume $non_null($phys_ptr_cast(L#leaf, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#leaf, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#leaf, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#leaf, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#leaf, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#leaf, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#leaf, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(leaf), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((leaf->left))), @_vcc_ptr_neq_null(*((leaf->right)))), ==(treap_min_key(leaf), @\int_min(*((leaf->key)), @\int_min(treap_min_key(*((leaf->left))), treap_min_key(*((leaf->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((leaf->left))), @_vcc_ptr_eq_null(*((leaf->right)))), ==(treap_min_key(leaf), @\int_min(*((leaf->key)), treap_min_key(*((leaf->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((leaf->left))), @_vcc_ptr_neq_null(*((leaf->right)))), ==(treap_min_key(leaf), @\int_min(*((leaf->key)), treap_min_key(*((leaf->right)))))))); 
        assume $non_null($phys_ptr_cast(L#leaf, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#leaf, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#leaf, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#leaf, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#leaf, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#leaf, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#leaf, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))));
        // _math \state _dryad_S4; 
        // _dryad_S4 := @_vcc_current_state(@state); 
        SL#_dryad_S4 := $current_state($s);
        // _math \state stmtexpr5#8; 
        // stmtexpr5#8 := _dryad_S4; 
        stmtexpr5#8 := SL#_dryad_S4;
        // assert @prim_writes_check((leaf->prio)); 
        assert $writable_prim($s, #wrTime$3^5.3, $dot($phys_ptr_cast(L#leaf, ^b_node), b_node.prio));
        // *(leaf->prio) := p; 
        call $write_int(b_node.prio, $phys_ptr_cast(L#leaf, ^b_node), P#p);
        assume $full_stop_ext(#tok$3^39.5, $s);
        // _math \state _dryad_S5; 
        // _dryad_S5 := @_vcc_current_state(@state); 
        SL#_dryad_S5 := $current_state($s);
        // _math \state stmtexpr6#9; 
        // stmtexpr6#9 := _dryad_S5; 
        stmtexpr6#9 := SL#_dryad_S5;
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S4, treap_reach(*((leaf->left)))))), ==(old(_dryad_S4, treap(*((leaf->left)))), old(_dryad_S5, treap(*((leaf->left)))))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S4, $rd_phys_ptr(SL#_dryad_S4, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) ==> F#treap(SL#_dryad_S4, $rd_phys_ptr(SL#_dryad_S4, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) == F#treap(SL#_dryad_S5, $rd_phys_ptr(SL#_dryad_S5, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S4, treap_reach(*((leaf->left)))))), ==(old(_dryad_S4, treap_reach(*((leaf->left)))), old(_dryad_S5, treap_reach(*((leaf->left)))))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S4, $rd_phys_ptr(SL#_dryad_S4, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) ==> F#treap_reach(SL#_dryad_S4, $rd_phys_ptr(SL#_dryad_S4, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) == F#treap_reach(SL#_dryad_S5, $rd_phys_ptr(SL#_dryad_S5, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S4, treap_reach(*((leaf->left)))))), ==(old(_dryad_S4, treap_keys(*((leaf->left)))), old(_dryad_S5, treap_keys(*((leaf->left)))))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S4, $rd_phys_ptr(SL#_dryad_S4, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) ==> F#treap_keys(SL#_dryad_S4, $rd_phys_ptr(SL#_dryad_S4, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) == F#treap_keys(SL#_dryad_S5, $rd_phys_ptr(SL#_dryad_S5, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S4, treap_reach(*((leaf->left)))))), ==(old(_dryad_S4, treap_max_key(*((leaf->left)))), old(_dryad_S5, treap_max_key(*((leaf->left)))))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S4, $rd_phys_ptr(SL#_dryad_S4, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) ==> F#treap_max_key(SL#_dryad_S4, $rd_phys_ptr(SL#_dryad_S4, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) == F#treap_max_key(SL#_dryad_S5, $rd_phys_ptr(SL#_dryad_S5, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S4, treap_reach(*((leaf->left)))))), ==(old(_dryad_S4, treap_max_prio(*((leaf->left)))), old(_dryad_S5, treap_max_prio(*((leaf->left)))))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S4, $rd_phys_ptr(SL#_dryad_S4, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) ==> F#treap_max_prio(SL#_dryad_S4, $rd_phys_ptr(SL#_dryad_S4, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) == F#treap_max_prio(SL#_dryad_S5, $rd_phys_ptr(SL#_dryad_S5, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S4, treap_reach(*((leaf->left)))))), ==(old(_dryad_S4, treap_min_key(*((leaf->left)))), old(_dryad_S5, treap_min_key(*((leaf->left)))))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S4, $rd_phys_ptr(SL#_dryad_S4, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) ==> F#treap_min_key(SL#_dryad_S4, $rd_phys_ptr(SL#_dryad_S4, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) == F#treap_min_key(SL#_dryad_S5, $rd_phys_ptr(SL#_dryad_S5, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S4, treap_reach(*((leaf->left)))))), ==(old(_dryad_S4, treap_prios(*((leaf->left)))), old(_dryad_S5, treap_prios(*((leaf->left)))))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S4, $rd_phys_ptr(SL#_dryad_S4, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) ==> F#treap_prios(SL#_dryad_S4, $rd_phys_ptr(SL#_dryad_S4, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) == F#treap_prios(SL#_dryad_S5, $rd_phys_ptr(SL#_dryad_S5, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S4, treap_reach(*((leaf->right)))))), ==(old(_dryad_S4, treap(*((leaf->right)))), old(_dryad_S5, treap(*((leaf->right)))))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S4, $rd_phys_ptr(SL#_dryad_S4, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) ==> F#treap(SL#_dryad_S4, $rd_phys_ptr(SL#_dryad_S4, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) == F#treap(SL#_dryad_S5, $rd_phys_ptr(SL#_dryad_S5, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S4, treap_reach(*((leaf->right)))))), ==(old(_dryad_S4, treap_reach(*((leaf->right)))), old(_dryad_S5, treap_reach(*((leaf->right)))))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S4, $rd_phys_ptr(SL#_dryad_S4, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) ==> F#treap_reach(SL#_dryad_S4, $rd_phys_ptr(SL#_dryad_S4, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) == F#treap_reach(SL#_dryad_S5, $rd_phys_ptr(SL#_dryad_S5, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S4, treap_reach(*((leaf->right)))))), ==(old(_dryad_S4, treap_keys(*((leaf->right)))), old(_dryad_S5, treap_keys(*((leaf->right)))))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S4, $rd_phys_ptr(SL#_dryad_S4, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) ==> F#treap_keys(SL#_dryad_S4, $rd_phys_ptr(SL#_dryad_S4, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) == F#treap_keys(SL#_dryad_S5, $rd_phys_ptr(SL#_dryad_S5, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S4, treap_reach(*((leaf->right)))))), ==(old(_dryad_S4, treap_max_key(*((leaf->right)))), old(_dryad_S5, treap_max_key(*((leaf->right)))))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S4, $rd_phys_ptr(SL#_dryad_S4, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) ==> F#treap_max_key(SL#_dryad_S4, $rd_phys_ptr(SL#_dryad_S4, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) == F#treap_max_key(SL#_dryad_S5, $rd_phys_ptr(SL#_dryad_S5, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S4, treap_reach(*((leaf->right)))))), ==(old(_dryad_S4, treap_max_prio(*((leaf->right)))), old(_dryad_S5, treap_max_prio(*((leaf->right)))))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S4, $rd_phys_ptr(SL#_dryad_S4, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) ==> F#treap_max_prio(SL#_dryad_S4, $rd_phys_ptr(SL#_dryad_S4, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) == F#treap_max_prio(SL#_dryad_S5, $rd_phys_ptr(SL#_dryad_S5, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S4, treap_reach(*((leaf->right)))))), ==(old(_dryad_S4, treap_min_key(*((leaf->right)))), old(_dryad_S5, treap_min_key(*((leaf->right)))))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S4, $rd_phys_ptr(SL#_dryad_S4, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) ==> F#treap_min_key(SL#_dryad_S4, $rd_phys_ptr(SL#_dryad_S4, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) == F#treap_min_key(SL#_dryad_S5, $rd_phys_ptr(SL#_dryad_S5, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S4, treap_reach(*((leaf->right)))))), ==(old(_dryad_S4, treap_prios(*((leaf->right)))), old(_dryad_S5, treap_prios(*((leaf->right)))))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S4, $rd_phys_ptr(SL#_dryad_S4, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) ==> F#treap_prios(SL#_dryad_S4, $rd_phys_ptr(SL#_dryad_S4, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) == F#treap_prios(SL#_dryad_S5, $rd_phys_ptr(SL#_dryad_S5, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node));
        // assume ==(old(_dryad_S4, treap_reach(leaf)), old(_dryad_S5, treap_reach(leaf))); 
        assume F#treap_reach(SL#_dryad_S4, $phys_ptr_cast(L#leaf, ^b_node)) == F#treap_reach(SL#_dryad_S5, $phys_ptr_cast(L#leaf, ^b_node));
        // assume ==(old(_dryad_S4, treap_keys(leaf)), old(_dryad_S5, treap_keys(leaf))); 
        assume F#treap_keys(SL#_dryad_S4, $phys_ptr_cast(L#leaf, ^b_node)) == F#treap_keys(SL#_dryad_S5, $phys_ptr_cast(L#leaf, ^b_node));
        // assume ==(old(_dryad_S4, treap_max_key(leaf)), old(_dryad_S5, treap_max_key(leaf))); 
        assume F#treap_max_key(SL#_dryad_S4, $phys_ptr_cast(L#leaf, ^b_node)) == F#treap_max_key(SL#_dryad_S5, $phys_ptr_cast(L#leaf, ^b_node));
        // assume ==(old(_dryad_S4, treap_min_key(leaf)), old(_dryad_S5, treap_min_key(leaf))); 
        assume F#treap_min_key(SL#_dryad_S4, $phys_ptr_cast(L#leaf, ^b_node)) == F#treap_min_key(SL#_dryad_S5, $phys_ptr_cast(L#leaf, ^b_node));
        // assume ==(old(_dryad_S4, treap_reach(x)), old(_dryad_S5, treap_reach(x))); 
        assume F#treap_reach(SL#_dryad_S4, $phys_ptr_cast(P#x, ^b_node)) == F#treap_reach(SL#_dryad_S5, $phys_ptr_cast(P#x, ^b_node));
        // assume ==(old(_dryad_S4, treap_keys(x)), old(_dryad_S5, treap_keys(x))); 
        assume F#treap_keys(SL#_dryad_S4, $phys_ptr_cast(P#x, ^b_node)) == F#treap_keys(SL#_dryad_S5, $phys_ptr_cast(P#x, ^b_node));
        // assume ==(old(_dryad_S4, treap_max_key(x)), old(_dryad_S5, treap_max_key(x))); 
        assume F#treap_max_key(SL#_dryad_S4, $phys_ptr_cast(P#x, ^b_node)) == F#treap_max_key(SL#_dryad_S5, $phys_ptr_cast(P#x, ^b_node));
        // assume ==(old(_dryad_S4, treap_min_key(x)), old(_dryad_S5, treap_min_key(x))); 
        assume F#treap_min_key(SL#_dryad_S4, $phys_ptr_cast(P#x, ^b_node)) == F#treap_min_key(SL#_dryad_S5, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S4, treap_reach(x)))), ==(old(_dryad_S4, treap(x)), old(_dryad_S5, treap(x)))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S4, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap(SL#_dryad_S4, $phys_ptr_cast(P#x, ^b_node)) == F#treap(SL#_dryad_S5, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S4, treap_reach(x)))), ==(old(_dryad_S4, treap_reach(x)), old(_dryad_S5, treap_reach(x)))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S4, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_reach(SL#_dryad_S4, $phys_ptr_cast(P#x, ^b_node)) == F#treap_reach(SL#_dryad_S5, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S4, treap_reach(x)))), ==(old(_dryad_S4, treap_keys(x)), old(_dryad_S5, treap_keys(x)))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S4, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_keys(SL#_dryad_S4, $phys_ptr_cast(P#x, ^b_node)) == F#treap_keys(SL#_dryad_S5, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S4, treap_reach(x)))), ==(old(_dryad_S4, treap_max_key(x)), old(_dryad_S5, treap_max_key(x)))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S4, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_max_key(SL#_dryad_S4, $phys_ptr_cast(P#x, ^b_node)) == F#treap_max_key(SL#_dryad_S5, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S4, treap_reach(x)))), ==(old(_dryad_S4, treap_max_prio(x)), old(_dryad_S5, treap_max_prio(x)))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S4, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_max_prio(SL#_dryad_S4, $phys_ptr_cast(P#x, ^b_node)) == F#treap_max_prio(SL#_dryad_S5, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S4, treap_reach(x)))), ==(old(_dryad_S4, treap_min_key(x)), old(_dryad_S5, treap_min_key(x)))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S4, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_min_key(SL#_dryad_S4, $phys_ptr_cast(P#x, ^b_node)) == F#treap_min_key(SL#_dryad_S5, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S4, treap_reach(x)))), ==(old(_dryad_S4, treap_prios(x)), old(_dryad_S5, treap_prios(x)))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S4, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_prios(SL#_dryad_S4, $phys_ptr_cast(P#x, ^b_node)) == F#treap_prios(SL#_dryad_S5, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(!(@_vcc_ptr_eq_pure(leaf, x)), @_vcc_ptr_eq_pure(*((x->left)), old(_dryad_S4, *((x->left))))); 
        assume !($phys_ptr_cast(L#leaf, ^b_node) == $phys_ptr_cast(P#x, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node) == $rd_phys_ptr(SL#_dryad_S4, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node);
        // assume ==>(!(@_vcc_ptr_eq_pure(leaf, x)), @_vcc_ptr_eq_pure(*((x->right)), old(_dryad_S4, *((x->right))))); 
        assume !($phys_ptr_cast(L#leaf, ^b_node) == $phys_ptr_cast(P#x, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node) == $rd_phys_ptr(SL#_dryad_S4, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node);
        // assume ==>(!(@_vcc_ptr_eq_pure(leaf, x)), ==(*((x->key)), old(_dryad_S4, *((x->key))))); 
        assume !($phys_ptr_cast(L#leaf, ^b_node) == $phys_ptr_cast(P#x, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) == $rd_inv(SL#_dryad_S4, b_node.key, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(!(@_vcc_ptr_eq_pure(leaf, x)), ==(*((x->prio)), old(_dryad_S4, *((x->prio))))); 
        assume !($phys_ptr_cast(L#leaf, ^b_node) == $phys_ptr_cast(P#x, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)) == $rd_inv(SL#_dryad_S4, b_node.prio, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(@_vcc_ptr_neq_null(x), ==(treap(x), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x->left))), treap(*((x->right)))), unchecked!(@_vcc_oset_in(x, @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->key)), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->prio)), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))), @_vcc_oset_disjoint(treap_reach(*((x->left))), treap_reach(*((x->right))))), @_vcc_intset_disjoint(treap_keys(*((x->left))), treap_keys(*((x->right))))), @_vcc_intset_disjoint(treap_prios(*((x->left))), treap_prios(*((x->right))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_key(*((x->left))), *((x->key))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(*((x->key)), treap_min_key(*((x->right)))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_prio(*((x->left))), *((x->prio))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(treap_max_prio(*((x->right))), *((x->prio))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap($s, $phys_ptr_cast(P#x, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(P#x, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_reach(x), @_vcc_oset_union(@_vcc_oset_singleton(x), @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(P#x, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(P#x, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_keys(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->key))), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), @\int_max(treap_max_key(*((x->left))), treap_max_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->right)))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), @\int_max(treap_max_prio(*((x->left))), treap_max_prio(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->right)))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), @\int_min(treap_min_key(*((x->left))), treap_min_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->right)))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_prios(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->prio))), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(leaf), ==(treap(leaf), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((leaf->left))), treap(*((leaf->right)))), unchecked!(@_vcc_oset_in(leaf, @_vcc_oset_union(treap_reach(*((leaf->left))), treap_reach(*((leaf->right))))))), unchecked!(@_vcc_intset_in(*((leaf->key)), @_vcc_intset_union(treap_keys(*((leaf->left))), treap_keys(*((leaf->right))))))), unchecked!(@_vcc_intset_in(*((leaf->prio)), @_vcc_intset_union(treap_prios(*((leaf->left))), treap_prios(*((leaf->right))))))), @_vcc_oset_disjoint(treap_reach(*((leaf->left))), treap_reach(*((leaf->right))))), @_vcc_intset_disjoint(treap_keys(*((leaf->left))), treap_keys(*((leaf->right))))), @_vcc_intset_disjoint(treap_prios(*((leaf->left))), treap_prios(*((leaf->right))))), ==>(@_vcc_ptr_neq_null(*((leaf->left))), <(treap_max_key(*((leaf->left))), *((leaf->key))))), ==>(@_vcc_ptr_neq_null(*((leaf->right))), <(*((leaf->key)), treap_min_key(*((leaf->right)))))), ==>(@_vcc_ptr_neq_null(*((leaf->left))), <(treap_max_prio(*((leaf->left))), *((leaf->prio))))), ==>(@_vcc_ptr_neq_null(*((leaf->right))), <(treap_max_prio(*((leaf->right))), *((leaf->prio))))))); 
        assume $non_null($phys_ptr_cast(L#leaf, ^b_node)) ==> F#treap($s, $phys_ptr_cast(L#leaf, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(L#leaf, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(L#leaf, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(L#leaf, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(L#leaf, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#leaf, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#leaf, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#leaf, ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(leaf), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((leaf->left))), @_vcc_ptr_neq_null(*((leaf->right)))), ==(treap_max_prio(leaf), @\int_max(*((leaf->prio)), @\int_max(treap_max_prio(*((leaf->left))), treap_max_prio(*((leaf->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((leaf->left))), @_vcc_ptr_eq_null(*((leaf->right)))), ==(treap_max_prio(leaf), @\int_max(*((leaf->prio)), treap_max_prio(*((leaf->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((leaf->left))), @_vcc_ptr_neq_null(*((leaf->right)))), ==(treap_max_prio(leaf), @\int_max(*((leaf->prio)), treap_max_prio(*((leaf->right)))))))); 
        assume $non_null($phys_ptr_cast(L#leaf, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#leaf, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#leaf, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#leaf, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#leaf, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#leaf, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#leaf, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(leaf), ==(treap_prios(leaf), @_vcc_intset_union(@_vcc_intset_singleton(*((leaf->prio))), @_vcc_intset_union(treap_prios(*((leaf->left))), treap_prios(*((leaf->right))))))); 
        assume $non_null($phys_ptr_cast(L#leaf, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(L#leaf, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(L#leaf, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))));
        // _math \state _dryad_S6; 
        // _dryad_S6 := @_vcc_current_state(@state); 
        SL#_dryad_S6 := $current_state($s);
        // _math \state stmtexpr7#10; 
        // stmtexpr7#10 := _dryad_S6; 
        stmtexpr7#10 := SL#_dryad_S6;
        // assert @prim_writes_check((leaf->left)); 
        assert $writable_prim($s, #wrTime$3^5.3, $dot($phys_ptr_cast(L#leaf, ^b_node), b_node.left));
        // *(leaf->left) := (struct b_node*)@null; 
        call $write_int(b_node.left, $phys_ptr_cast(L#leaf, ^b_node), $ptr_to_int($phys_ptr_cast($null, ^b_node)));
        assume $full_stop_ext(#tok$3^40.5, $s);
        // _math \state _dryad_S7; 
        // _dryad_S7 := @_vcc_current_state(@state); 
        SL#_dryad_S7 := $current_state($s);
        // _math \state stmtexpr8#11; 
        // stmtexpr8#11 := _dryad_S7; 
        stmtexpr8#11 := SL#_dryad_S7;
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S6, treap_reach(*((leaf->right)))))), ==(old(_dryad_S6, treap(*((leaf->right)))), old(_dryad_S7, treap(*((leaf->right)))))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S6, $rd_phys_ptr(SL#_dryad_S6, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) ==> F#treap(SL#_dryad_S6, $rd_phys_ptr(SL#_dryad_S6, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) == F#treap(SL#_dryad_S7, $rd_phys_ptr(SL#_dryad_S7, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S6, treap_reach(*((leaf->right)))))), ==(old(_dryad_S6, treap_reach(*((leaf->right)))), old(_dryad_S7, treap_reach(*((leaf->right)))))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S6, $rd_phys_ptr(SL#_dryad_S6, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) ==> F#treap_reach(SL#_dryad_S6, $rd_phys_ptr(SL#_dryad_S6, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) == F#treap_reach(SL#_dryad_S7, $rd_phys_ptr(SL#_dryad_S7, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S6, treap_reach(*((leaf->right)))))), ==(old(_dryad_S6, treap_keys(*((leaf->right)))), old(_dryad_S7, treap_keys(*((leaf->right)))))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S6, $rd_phys_ptr(SL#_dryad_S6, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) ==> F#treap_keys(SL#_dryad_S6, $rd_phys_ptr(SL#_dryad_S6, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) == F#treap_keys(SL#_dryad_S7, $rd_phys_ptr(SL#_dryad_S7, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S6, treap_reach(*((leaf->right)))))), ==(old(_dryad_S6, treap_max_key(*((leaf->right)))), old(_dryad_S7, treap_max_key(*((leaf->right)))))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S6, $rd_phys_ptr(SL#_dryad_S6, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) ==> F#treap_max_key(SL#_dryad_S6, $rd_phys_ptr(SL#_dryad_S6, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) == F#treap_max_key(SL#_dryad_S7, $rd_phys_ptr(SL#_dryad_S7, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S6, treap_reach(*((leaf->right)))))), ==(old(_dryad_S6, treap_max_prio(*((leaf->right)))), old(_dryad_S7, treap_max_prio(*((leaf->right)))))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S6, $rd_phys_ptr(SL#_dryad_S6, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) ==> F#treap_max_prio(SL#_dryad_S6, $rd_phys_ptr(SL#_dryad_S6, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) == F#treap_max_prio(SL#_dryad_S7, $rd_phys_ptr(SL#_dryad_S7, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S6, treap_reach(*((leaf->right)))))), ==(old(_dryad_S6, treap_min_key(*((leaf->right)))), old(_dryad_S7, treap_min_key(*((leaf->right)))))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S6, $rd_phys_ptr(SL#_dryad_S6, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) ==> F#treap_min_key(SL#_dryad_S6, $rd_phys_ptr(SL#_dryad_S6, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) == F#treap_min_key(SL#_dryad_S7, $rd_phys_ptr(SL#_dryad_S7, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S6, treap_reach(*((leaf->right)))))), ==(old(_dryad_S6, treap_prios(*((leaf->right)))), old(_dryad_S7, treap_prios(*((leaf->right)))))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S6, $rd_phys_ptr(SL#_dryad_S6, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) ==> F#treap_prios(SL#_dryad_S6, $rd_phys_ptr(SL#_dryad_S6, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) == F#treap_prios(SL#_dryad_S7, $rd_phys_ptr(SL#_dryad_S7, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S6, treap_reach(x)))), ==(old(_dryad_S6, treap(x)), old(_dryad_S7, treap(x)))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S6, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap(SL#_dryad_S6, $phys_ptr_cast(P#x, ^b_node)) == F#treap(SL#_dryad_S7, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S6, treap_reach(x)))), ==(old(_dryad_S6, treap_reach(x)), old(_dryad_S7, treap_reach(x)))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S6, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_reach(SL#_dryad_S6, $phys_ptr_cast(P#x, ^b_node)) == F#treap_reach(SL#_dryad_S7, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S6, treap_reach(x)))), ==(old(_dryad_S6, treap_keys(x)), old(_dryad_S7, treap_keys(x)))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S6, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_keys(SL#_dryad_S6, $phys_ptr_cast(P#x, ^b_node)) == F#treap_keys(SL#_dryad_S7, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S6, treap_reach(x)))), ==(old(_dryad_S6, treap_max_key(x)), old(_dryad_S7, treap_max_key(x)))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S6, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_max_key(SL#_dryad_S6, $phys_ptr_cast(P#x, ^b_node)) == F#treap_max_key(SL#_dryad_S7, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S6, treap_reach(x)))), ==(old(_dryad_S6, treap_max_prio(x)), old(_dryad_S7, treap_max_prio(x)))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S6, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_max_prio(SL#_dryad_S6, $phys_ptr_cast(P#x, ^b_node)) == F#treap_max_prio(SL#_dryad_S7, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S6, treap_reach(x)))), ==(old(_dryad_S6, treap_min_key(x)), old(_dryad_S7, treap_min_key(x)))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S6, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_min_key(SL#_dryad_S6, $phys_ptr_cast(P#x, ^b_node)) == F#treap_min_key(SL#_dryad_S7, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S6, treap_reach(x)))), ==(old(_dryad_S6, treap_prios(x)), old(_dryad_S7, treap_prios(x)))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S6, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_prios(SL#_dryad_S6, $phys_ptr_cast(P#x, ^b_node)) == F#treap_prios(SL#_dryad_S7, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(!(@_vcc_ptr_eq_pure(leaf, x)), @_vcc_ptr_eq_pure(*((x->left)), old(_dryad_S6, *((x->left))))); 
        assume !($phys_ptr_cast(L#leaf, ^b_node) == $phys_ptr_cast(P#x, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node) == $rd_phys_ptr(SL#_dryad_S6, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node);
        // assume ==>(!(@_vcc_ptr_eq_pure(leaf, x)), @_vcc_ptr_eq_pure(*((x->right)), old(_dryad_S6, *((x->right))))); 
        assume !($phys_ptr_cast(L#leaf, ^b_node) == $phys_ptr_cast(P#x, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node) == $rd_phys_ptr(SL#_dryad_S6, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node);
        // assume ==>(!(@_vcc_ptr_eq_pure(leaf, x)), ==(*((x->key)), old(_dryad_S6, *((x->key))))); 
        assume !($phys_ptr_cast(L#leaf, ^b_node) == $phys_ptr_cast(P#x, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) == $rd_inv(SL#_dryad_S6, b_node.key, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(!(@_vcc_ptr_eq_pure(leaf, x)), ==(*((x->prio)), old(_dryad_S6, *((x->prio))))); 
        assume !($phys_ptr_cast(L#leaf, ^b_node) == $phys_ptr_cast(P#x, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)) == $rd_inv(SL#_dryad_S6, b_node.prio, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(@_vcc_ptr_neq_null(x), ==(treap(x), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x->left))), treap(*((x->right)))), unchecked!(@_vcc_oset_in(x, @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->key)), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->prio)), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))), @_vcc_oset_disjoint(treap_reach(*((x->left))), treap_reach(*((x->right))))), @_vcc_intset_disjoint(treap_keys(*((x->left))), treap_keys(*((x->right))))), @_vcc_intset_disjoint(treap_prios(*((x->left))), treap_prios(*((x->right))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_key(*((x->left))), *((x->key))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(*((x->key)), treap_min_key(*((x->right)))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_prio(*((x->left))), *((x->prio))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(treap_max_prio(*((x->right))), *((x->prio))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap($s, $phys_ptr_cast(P#x, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(P#x, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_reach(x), @_vcc_oset_union(@_vcc_oset_singleton(x), @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(P#x, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(P#x, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_keys(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->key))), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), @\int_max(treap_max_key(*((x->left))), treap_max_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->right)))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), @\int_max(treap_max_prio(*((x->left))), treap_max_prio(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->right)))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), @\int_min(treap_min_key(*((x->left))), treap_min_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->right)))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_prios(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->prio))), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(leaf), ==(treap(leaf), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((leaf->left))), treap(*((leaf->right)))), unchecked!(@_vcc_oset_in(leaf, @_vcc_oset_union(treap_reach(*((leaf->left))), treap_reach(*((leaf->right))))))), unchecked!(@_vcc_intset_in(*((leaf->key)), @_vcc_intset_union(treap_keys(*((leaf->left))), treap_keys(*((leaf->right))))))), unchecked!(@_vcc_intset_in(*((leaf->prio)), @_vcc_intset_union(treap_prios(*((leaf->left))), treap_prios(*((leaf->right))))))), @_vcc_oset_disjoint(treap_reach(*((leaf->left))), treap_reach(*((leaf->right))))), @_vcc_intset_disjoint(treap_keys(*((leaf->left))), treap_keys(*((leaf->right))))), @_vcc_intset_disjoint(treap_prios(*((leaf->left))), treap_prios(*((leaf->right))))), ==>(@_vcc_ptr_neq_null(*((leaf->left))), <(treap_max_key(*((leaf->left))), *((leaf->key))))), ==>(@_vcc_ptr_neq_null(*((leaf->right))), <(*((leaf->key)), treap_min_key(*((leaf->right)))))), ==>(@_vcc_ptr_neq_null(*((leaf->left))), <(treap_max_prio(*((leaf->left))), *((leaf->prio))))), ==>(@_vcc_ptr_neq_null(*((leaf->right))), <(treap_max_prio(*((leaf->right))), *((leaf->prio))))))); 
        assume $non_null($phys_ptr_cast(L#leaf, ^b_node)) ==> F#treap($s, $phys_ptr_cast(L#leaf, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(L#leaf, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(L#leaf, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(L#leaf, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(L#leaf, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#leaf, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#leaf, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#leaf, ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(leaf), ==(treap_reach(leaf), @_vcc_oset_union(@_vcc_oset_singleton(leaf), @_vcc_oset_union(treap_reach(*((leaf->left))), treap_reach(*((leaf->right))))))); 
        assume $non_null($phys_ptr_cast(L#leaf, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(L#leaf, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(L#leaf, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(leaf), ==(treap_keys(leaf), @_vcc_intset_union(@_vcc_intset_singleton(*((leaf->key))), @_vcc_intset_union(treap_keys(*((leaf->left))), treap_keys(*((leaf->right))))))); 
        assume $non_null($phys_ptr_cast(L#leaf, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(L#leaf, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(L#leaf, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(leaf), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((leaf->left))), @_vcc_ptr_neq_null(*((leaf->right)))), ==(treap_max_key(leaf), @\int_max(*((leaf->key)), @\int_max(treap_max_key(*((leaf->left))), treap_max_key(*((leaf->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((leaf->left))), @_vcc_ptr_eq_null(*((leaf->right)))), ==(treap_max_key(leaf), @\int_max(*((leaf->key)), treap_max_key(*((leaf->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((leaf->left))), @_vcc_ptr_neq_null(*((leaf->right)))), ==(treap_max_key(leaf), @\int_max(*((leaf->key)), treap_max_key(*((leaf->right)))))))); 
        assume $non_null($phys_ptr_cast(L#leaf, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#leaf, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#leaf, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#leaf, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#leaf, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#leaf, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#leaf, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(leaf), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((leaf->left))), @_vcc_ptr_neq_null(*((leaf->right)))), ==(treap_max_prio(leaf), @\int_max(*((leaf->prio)), @\int_max(treap_max_prio(*((leaf->left))), treap_max_prio(*((leaf->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((leaf->left))), @_vcc_ptr_eq_null(*((leaf->right)))), ==(treap_max_prio(leaf), @\int_max(*((leaf->prio)), treap_max_prio(*((leaf->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((leaf->left))), @_vcc_ptr_neq_null(*((leaf->right)))), ==(treap_max_prio(leaf), @\int_max(*((leaf->prio)), treap_max_prio(*((leaf->right)))))))); 
        assume $non_null($phys_ptr_cast(L#leaf, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#leaf, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#leaf, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#leaf, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#leaf, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#leaf, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#leaf, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(leaf), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((leaf->left))), @_vcc_ptr_neq_null(*((leaf->right)))), ==(treap_min_key(leaf), @\int_min(*((leaf->key)), @\int_min(treap_min_key(*((leaf->left))), treap_min_key(*((leaf->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((leaf->left))), @_vcc_ptr_eq_null(*((leaf->right)))), ==(treap_min_key(leaf), @\int_min(*((leaf->key)), treap_min_key(*((leaf->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((leaf->left))), @_vcc_ptr_neq_null(*((leaf->right)))), ==(treap_min_key(leaf), @\int_min(*((leaf->key)), treap_min_key(*((leaf->right)))))))); 
        assume $non_null($phys_ptr_cast(L#leaf, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#leaf, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#leaf, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#leaf, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#leaf, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#leaf, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#leaf, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(leaf), ==(treap_prios(leaf), @_vcc_intset_union(@_vcc_intset_singleton(*((leaf->prio))), @_vcc_intset_union(treap_prios(*((leaf->left))), treap_prios(*((leaf->right))))))); 
        assume $non_null($phys_ptr_cast(L#leaf, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(L#leaf, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(L#leaf, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))));
        // _math \state _dryad_S8; 
        // _dryad_S8 := @_vcc_current_state(@state); 
        SL#_dryad_S8 := $current_state($s);
        // _math \state stmtexpr9#12; 
        // stmtexpr9#12 := _dryad_S8; 
        stmtexpr9#12 := SL#_dryad_S8;
        // assert @prim_writes_check((leaf->right)); 
        assert $writable_prim($s, #wrTime$3^5.3, $dot($phys_ptr_cast(L#leaf, ^b_node), b_node.right));
        // *(leaf->right) := (struct b_node*)@null; 
        call $write_int(b_node.right, $phys_ptr_cast(L#leaf, ^b_node), $ptr_to_int($phys_ptr_cast($null, ^b_node)));
        assume $full_stop_ext(#tok$3^41.5, $s);
        // _math \state _dryad_S9; 
        // _dryad_S9 := @_vcc_current_state(@state); 
        SL#_dryad_S9 := $current_state($s);
        // _math \state stmtexpr10#13; 
        // stmtexpr10#13 := _dryad_S9; 
        stmtexpr10#13 := SL#_dryad_S9;
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S8, treap_reach(*((leaf->left)))))), ==(old(_dryad_S8, treap(*((leaf->left)))), old(_dryad_S9, treap(*((leaf->left)))))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S8, $rd_phys_ptr(SL#_dryad_S8, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) ==> F#treap(SL#_dryad_S8, $rd_phys_ptr(SL#_dryad_S8, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) == F#treap(SL#_dryad_S9, $rd_phys_ptr(SL#_dryad_S9, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S8, treap_reach(*((leaf->left)))))), ==(old(_dryad_S8, treap_reach(*((leaf->left)))), old(_dryad_S9, treap_reach(*((leaf->left)))))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S8, $rd_phys_ptr(SL#_dryad_S8, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) ==> F#treap_reach(SL#_dryad_S8, $rd_phys_ptr(SL#_dryad_S8, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) == F#treap_reach(SL#_dryad_S9, $rd_phys_ptr(SL#_dryad_S9, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S8, treap_reach(*((leaf->left)))))), ==(old(_dryad_S8, treap_keys(*((leaf->left)))), old(_dryad_S9, treap_keys(*((leaf->left)))))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S8, $rd_phys_ptr(SL#_dryad_S8, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) ==> F#treap_keys(SL#_dryad_S8, $rd_phys_ptr(SL#_dryad_S8, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) == F#treap_keys(SL#_dryad_S9, $rd_phys_ptr(SL#_dryad_S9, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S8, treap_reach(*((leaf->left)))))), ==(old(_dryad_S8, treap_max_key(*((leaf->left)))), old(_dryad_S9, treap_max_key(*((leaf->left)))))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S8, $rd_phys_ptr(SL#_dryad_S8, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) ==> F#treap_max_key(SL#_dryad_S8, $rd_phys_ptr(SL#_dryad_S8, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) == F#treap_max_key(SL#_dryad_S9, $rd_phys_ptr(SL#_dryad_S9, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S8, treap_reach(*((leaf->left)))))), ==(old(_dryad_S8, treap_max_prio(*((leaf->left)))), old(_dryad_S9, treap_max_prio(*((leaf->left)))))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S8, $rd_phys_ptr(SL#_dryad_S8, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) ==> F#treap_max_prio(SL#_dryad_S8, $rd_phys_ptr(SL#_dryad_S8, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) == F#treap_max_prio(SL#_dryad_S9, $rd_phys_ptr(SL#_dryad_S9, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S8, treap_reach(*((leaf->left)))))), ==(old(_dryad_S8, treap_min_key(*((leaf->left)))), old(_dryad_S9, treap_min_key(*((leaf->left)))))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S8, $rd_phys_ptr(SL#_dryad_S8, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) ==> F#treap_min_key(SL#_dryad_S8, $rd_phys_ptr(SL#_dryad_S8, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) == F#treap_min_key(SL#_dryad_S9, $rd_phys_ptr(SL#_dryad_S9, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S8, treap_reach(*((leaf->left)))))), ==(old(_dryad_S8, treap_prios(*((leaf->left)))), old(_dryad_S9, treap_prios(*((leaf->left)))))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S8, $rd_phys_ptr(SL#_dryad_S8, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) ==> F#treap_prios(SL#_dryad_S8, $rd_phys_ptr(SL#_dryad_S8, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) == F#treap_prios(SL#_dryad_S9, $rd_phys_ptr(SL#_dryad_S9, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S8, treap_reach(x)))), ==(old(_dryad_S8, treap(x)), old(_dryad_S9, treap(x)))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S8, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap(SL#_dryad_S8, $phys_ptr_cast(P#x, ^b_node)) == F#treap(SL#_dryad_S9, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S8, treap_reach(x)))), ==(old(_dryad_S8, treap_reach(x)), old(_dryad_S9, treap_reach(x)))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S8, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_reach(SL#_dryad_S8, $phys_ptr_cast(P#x, ^b_node)) == F#treap_reach(SL#_dryad_S9, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S8, treap_reach(x)))), ==(old(_dryad_S8, treap_keys(x)), old(_dryad_S9, treap_keys(x)))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S8, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_keys(SL#_dryad_S8, $phys_ptr_cast(P#x, ^b_node)) == F#treap_keys(SL#_dryad_S9, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S8, treap_reach(x)))), ==(old(_dryad_S8, treap_max_key(x)), old(_dryad_S9, treap_max_key(x)))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S8, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_max_key(SL#_dryad_S8, $phys_ptr_cast(P#x, ^b_node)) == F#treap_max_key(SL#_dryad_S9, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S8, treap_reach(x)))), ==(old(_dryad_S8, treap_max_prio(x)), old(_dryad_S9, treap_max_prio(x)))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S8, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_max_prio(SL#_dryad_S8, $phys_ptr_cast(P#x, ^b_node)) == F#treap_max_prio(SL#_dryad_S9, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S8, treap_reach(x)))), ==(old(_dryad_S8, treap_min_key(x)), old(_dryad_S9, treap_min_key(x)))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S8, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_min_key(SL#_dryad_S8, $phys_ptr_cast(P#x, ^b_node)) == F#treap_min_key(SL#_dryad_S9, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(unchecked!(@_vcc_oset_in(leaf, old(_dryad_S8, treap_reach(x)))), ==(old(_dryad_S8, treap_prios(x)), old(_dryad_S9, treap_prios(x)))); 
        assume !$oset_in($phys_ptr_cast(L#leaf, ^b_node), F#treap_reach(SL#_dryad_S8, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_prios(SL#_dryad_S8, $phys_ptr_cast(P#x, ^b_node)) == F#treap_prios(SL#_dryad_S9, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(!(@_vcc_ptr_eq_pure(leaf, x)), @_vcc_ptr_eq_pure(*((x->left)), old(_dryad_S8, *((x->left))))); 
        assume !($phys_ptr_cast(L#leaf, ^b_node) == $phys_ptr_cast(P#x, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node) == $rd_phys_ptr(SL#_dryad_S8, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node);
        // assume ==>(!(@_vcc_ptr_eq_pure(leaf, x)), @_vcc_ptr_eq_pure(*((x->right)), old(_dryad_S8, *((x->right))))); 
        assume !($phys_ptr_cast(L#leaf, ^b_node) == $phys_ptr_cast(P#x, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node) == $rd_phys_ptr(SL#_dryad_S8, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node);
        // assume ==>(!(@_vcc_ptr_eq_pure(leaf, x)), ==(*((x->key)), old(_dryad_S8, *((x->key))))); 
        assume !($phys_ptr_cast(L#leaf, ^b_node) == $phys_ptr_cast(P#x, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) == $rd_inv(SL#_dryad_S8, b_node.key, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(!(@_vcc_ptr_eq_pure(leaf, x)), ==(*((x->prio)), old(_dryad_S8, *((x->prio))))); 
        assume !($phys_ptr_cast(L#leaf, ^b_node) == $phys_ptr_cast(P#x, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)) == $rd_inv(SL#_dryad_S8, b_node.prio, $phys_ptr_cast(P#x, ^b_node));
        // assume ==>(@_vcc_ptr_neq_null(x), ==(treap(x), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x->left))), treap(*((x->right)))), unchecked!(@_vcc_oset_in(x, @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->key)), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->prio)), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))), @_vcc_oset_disjoint(treap_reach(*((x->left))), treap_reach(*((x->right))))), @_vcc_intset_disjoint(treap_keys(*((x->left))), treap_keys(*((x->right))))), @_vcc_intset_disjoint(treap_prios(*((x->left))), treap_prios(*((x->right))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_key(*((x->left))), *((x->key))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(*((x->key)), treap_min_key(*((x->right)))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_prio(*((x->left))), *((x->prio))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(treap_max_prio(*((x->right))), *((x->prio))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap($s, $phys_ptr_cast(P#x, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(P#x, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_reach(x), @_vcc_oset_union(@_vcc_oset_singleton(x), @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(P#x, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(P#x, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_keys(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->key))), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), @\int_max(treap_max_key(*((x->left))), treap_max_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->right)))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), @\int_max(treap_max_prio(*((x->left))), treap_max_prio(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->right)))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), @\int_min(treap_min_key(*((x->left))), treap_min_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->right)))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_prios(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->prio))), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(leaf), ==(treap(leaf), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((leaf->left))), treap(*((leaf->right)))), unchecked!(@_vcc_oset_in(leaf, @_vcc_oset_union(treap_reach(*((leaf->left))), treap_reach(*((leaf->right))))))), unchecked!(@_vcc_intset_in(*((leaf->key)), @_vcc_intset_union(treap_keys(*((leaf->left))), treap_keys(*((leaf->right))))))), unchecked!(@_vcc_intset_in(*((leaf->prio)), @_vcc_intset_union(treap_prios(*((leaf->left))), treap_prios(*((leaf->right))))))), @_vcc_oset_disjoint(treap_reach(*((leaf->left))), treap_reach(*((leaf->right))))), @_vcc_intset_disjoint(treap_keys(*((leaf->left))), treap_keys(*((leaf->right))))), @_vcc_intset_disjoint(treap_prios(*((leaf->left))), treap_prios(*((leaf->right))))), ==>(@_vcc_ptr_neq_null(*((leaf->left))), <(treap_max_key(*((leaf->left))), *((leaf->key))))), ==>(@_vcc_ptr_neq_null(*((leaf->right))), <(*((leaf->key)), treap_min_key(*((leaf->right)))))), ==>(@_vcc_ptr_neq_null(*((leaf->left))), <(treap_max_prio(*((leaf->left))), *((leaf->prio))))), ==>(@_vcc_ptr_neq_null(*((leaf->right))), <(treap_max_prio(*((leaf->right))), *((leaf->prio))))))); 
        assume $non_null($phys_ptr_cast(L#leaf, ^b_node)) ==> F#treap($s, $phys_ptr_cast(L#leaf, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(L#leaf, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(L#leaf, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(L#leaf, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(L#leaf, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#leaf, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#leaf, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#leaf, ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(leaf), ==(treap_reach(leaf), @_vcc_oset_union(@_vcc_oset_singleton(leaf), @_vcc_oset_union(treap_reach(*((leaf->left))), treap_reach(*((leaf->right))))))); 
        assume $non_null($phys_ptr_cast(L#leaf, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(L#leaf, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(L#leaf, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(leaf), ==(treap_keys(leaf), @_vcc_intset_union(@_vcc_intset_singleton(*((leaf->key))), @_vcc_intset_union(treap_keys(*((leaf->left))), treap_keys(*((leaf->right))))))); 
        assume $non_null($phys_ptr_cast(L#leaf, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(L#leaf, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(L#leaf, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(leaf), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((leaf->left))), @_vcc_ptr_neq_null(*((leaf->right)))), ==(treap_max_key(leaf), @\int_max(*((leaf->key)), @\int_max(treap_max_key(*((leaf->left))), treap_max_key(*((leaf->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((leaf->left))), @_vcc_ptr_eq_null(*((leaf->right)))), ==(treap_max_key(leaf), @\int_max(*((leaf->key)), treap_max_key(*((leaf->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((leaf->left))), @_vcc_ptr_neq_null(*((leaf->right)))), ==(treap_max_key(leaf), @\int_max(*((leaf->key)), treap_max_key(*((leaf->right)))))))); 
        assume $non_null($phys_ptr_cast(L#leaf, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#leaf, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#leaf, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#leaf, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#leaf, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#leaf, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#leaf, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(leaf), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((leaf->left))), @_vcc_ptr_neq_null(*((leaf->right)))), ==(treap_max_prio(leaf), @\int_max(*((leaf->prio)), @\int_max(treap_max_prio(*((leaf->left))), treap_max_prio(*((leaf->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((leaf->left))), @_vcc_ptr_eq_null(*((leaf->right)))), ==(treap_max_prio(leaf), @\int_max(*((leaf->prio)), treap_max_prio(*((leaf->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((leaf->left))), @_vcc_ptr_neq_null(*((leaf->right)))), ==(treap_max_prio(leaf), @\int_max(*((leaf->prio)), treap_max_prio(*((leaf->right)))))))); 
        assume $non_null($phys_ptr_cast(L#leaf, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#leaf, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#leaf, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#leaf, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#leaf, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#leaf, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#leaf, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(leaf), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((leaf->left))), @_vcc_ptr_neq_null(*((leaf->right)))), ==(treap_min_key(leaf), @\int_min(*((leaf->key)), @\int_min(treap_min_key(*((leaf->left))), treap_min_key(*((leaf->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((leaf->left))), @_vcc_ptr_eq_null(*((leaf->right)))), ==(treap_min_key(leaf), @\int_min(*((leaf->key)), treap_min_key(*((leaf->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((leaf->left))), @_vcc_ptr_neq_null(*((leaf->right)))), ==(treap_min_key(leaf), @\int_min(*((leaf->key)), treap_min_key(*((leaf->right)))))))); 
        assume $non_null($phys_ptr_cast(L#leaf, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#leaf, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#leaf, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#leaf, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#leaf, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#leaf, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#leaf, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(leaf), ==(treap_prios(leaf), @_vcc_intset_union(@_vcc_intset_singleton(*((leaf->prio))), @_vcc_intset_union(treap_prios(*((leaf->left))), treap_prios(*((leaf->right))))))); 
        assume $non_null($phys_ptr_cast(L#leaf, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(L#leaf, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(L#leaf, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#leaf, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#leaf, ^b_node), ^b_node))));
        // return leaf; 
        $result := $phys_ptr_cast(L#leaf, ^b_node);
        assume true;
        assert $position_marker();
        goto #exit;
    }
    else
    {
      anon8:
        // assume ==>(@_vcc_ptr_neq_null(x), ==(treap(x), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x->left))), treap(*((x->right)))), unchecked!(@_vcc_oset_in(x, @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->key)), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->prio)), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))), @_vcc_oset_disjoint(treap_reach(*((x->left))), treap_reach(*((x->right))))), @_vcc_intset_disjoint(treap_keys(*((x->left))), treap_keys(*((x->right))))), @_vcc_intset_disjoint(treap_prios(*((x->left))), treap_prios(*((x->right))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_key(*((x->left))), *((x->key))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(*((x->key)), treap_min_key(*((x->right)))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_prio(*((x->left))), *((x->prio))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(treap_max_prio(*((x->right))), *((x->prio))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap($s, $phys_ptr_cast(P#x, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(P#x, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_reach(x), @_vcc_oset_union(@_vcc_oset_singleton(x), @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(P#x, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(P#x, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_keys(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->key))), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), @\int_max(treap_max_key(*((x->left))), treap_max_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->right)))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), @\int_max(treap_max_prio(*((x->left))), treap_max_prio(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->right)))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), @\int_min(treap_min_key(*((x->left))), treap_min_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->right)))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_prios(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->prio))), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))); 
        assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
        // assert @reads_check_normal((x->key)); 
        assert $thread_local($s, $phys_ptr_cast(P#x, ^b_node));
        assume true;
        // if (<(k, *((x->key)))) ...
        if (P#k < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)))
        {
          anon4:
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap(x), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x->left))), treap(*((x->right)))), unchecked!(@_vcc_oset_in(x, @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->key)), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->prio)), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))), @_vcc_oset_disjoint(treap_reach(*((x->left))), treap_reach(*((x->right))))), @_vcc_intset_disjoint(treap_keys(*((x->left))), treap_keys(*((x->right))))), @_vcc_intset_disjoint(treap_prios(*((x->left))), treap_prios(*((x->right))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_key(*((x->left))), *((x->key))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(*((x->key)), treap_min_key(*((x->right)))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_prio(*((x->left))), *((x->prio))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(treap_max_prio(*((x->right))), *((x->prio))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap($s, $phys_ptr_cast(P#x, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(P#x, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_reach(x), @_vcc_oset_union(@_vcc_oset_singleton(x), @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(P#x, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(P#x, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_keys(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->key))), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), @\int_max(treap_max_key(*((x->left))), treap_max_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), @\int_max(treap_max_prio(*((x->left))), treap_max_prio(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), @\int_min(treap_min_key(*((x->left))), treap_min_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_prios(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->prio))), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // struct b_node* tmp; 
            // struct b_node* xl; 
            // struct b_node* xr; 
            // struct b_node* x0; 
            // x0 := x; 
            SL#x0 := $phys_ptr_cast(P#x, ^b_node);
            // struct b_node* stmtexpr0#14; 
            // stmtexpr0#14 := x0; 
            stmtexpr0#14 := $phys_ptr_cast(SL#x0, ^b_node);
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap(x), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x->left))), treap(*((x->right)))), unchecked!(@_vcc_oset_in(x, @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->key)), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->prio)), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))), @_vcc_oset_disjoint(treap_reach(*((x->left))), treap_reach(*((x->right))))), @_vcc_intset_disjoint(treap_keys(*((x->left))), treap_keys(*((x->right))))), @_vcc_intset_disjoint(treap_prios(*((x->left))), treap_prios(*((x->right))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_key(*((x->left))), *((x->key))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(*((x->key)), treap_min_key(*((x->right)))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_prio(*((x->left))), *((x->prio))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(treap_max_prio(*((x->right))), *((x->prio))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap($s, $phys_ptr_cast(P#x, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(P#x, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_reach(x), @_vcc_oset_union(@_vcc_oset_singleton(x), @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(P#x, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(P#x, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_keys(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->key))), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), @\int_max(treap_max_key(*((x->left))), treap_max_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), @\int_max(treap_max_prio(*((x->left))), treap_max_prio(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), @\int_min(treap_min_key(*((x->left))), treap_min_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_prios(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->prio))), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assert @reads_check_normal((x->right)); 
            assert $thread_local($s, $phys_ptr_cast(P#x, ^b_node));
            // xr := *((x->right)); 
            L#xr := $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node);
            // assume ==>(@_vcc_ptr_neq_null(xr), ==(treap(xr), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((xr->left))), treap(*((xr->right)))), unchecked!(@_vcc_oset_in(xr, @_vcc_oset_union(treap_reach(*((xr->left))), treap_reach(*((xr->right))))))), unchecked!(@_vcc_intset_in(*((xr->key)), @_vcc_intset_union(treap_keys(*((xr->left))), treap_keys(*((xr->right))))))), unchecked!(@_vcc_intset_in(*((xr->prio)), @_vcc_intset_union(treap_prios(*((xr->left))), treap_prios(*((xr->right))))))), @_vcc_oset_disjoint(treap_reach(*((xr->left))), treap_reach(*((xr->right))))), @_vcc_intset_disjoint(treap_keys(*((xr->left))), treap_keys(*((xr->right))))), @_vcc_intset_disjoint(treap_prios(*((xr->left))), treap_prios(*((xr->right))))), ==>(@_vcc_ptr_neq_null(*((xr->left))), <(treap_max_key(*((xr->left))), *((xr->key))))), ==>(@_vcc_ptr_neq_null(*((xr->right))), <(*((xr->key)), treap_min_key(*((xr->right)))))), ==>(@_vcc_ptr_neq_null(*((xr->left))), <(treap_max_prio(*((xr->left))), *((xr->prio))))), ==>(@_vcc_ptr_neq_null(*((xr->right))), <(treap_max_prio(*((xr->right))), *((xr->prio))))))); 
            assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> F#treap($s, $phys_ptr_cast(L#xr, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(L#xr, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr), ==(treap_reach(xr), @_vcc_oset_union(@_vcc_oset_singleton(xr), @_vcc_oset_union(treap_reach(*((xr->left))), treap_reach(*((xr->right))))))); 
            assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(L#xr, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(L#xr, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr), ==(treap_keys(xr), @_vcc_intset_union(@_vcc_intset_singleton(*((xr->key))), @_vcc_intset_union(treap_keys(*((xr->left))), treap_keys(*((xr->right))))))); 
            assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(L#xr, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_max_key(xr), @\int_max(*((xr->key)), @\int_max(treap_max_key(*((xr->left))), treap_max_key(*((xr->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_eq_null(*((xr->right)))), ==(treap_max_key(xr), @\int_max(*((xr->key)), treap_max_key(*((xr->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_max_key(xr), @\int_max(*((xr->key)), treap_max_key(*((xr->right)))))))); 
            assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_max_prio(xr), @\int_max(*((xr->prio)), @\int_max(treap_max_prio(*((xr->left))), treap_max_prio(*((xr->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_eq_null(*((xr->right)))), ==(treap_max_prio(xr), @\int_max(*((xr->prio)), treap_max_prio(*((xr->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_max_prio(xr), @\int_max(*((xr->prio)), treap_max_prio(*((xr->right)))))))); 
            assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_min_key(xr), @\int_min(*((xr->key)), @\int_min(treap_min_key(*((xr->left))), treap_min_key(*((xr->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_eq_null(*((xr->right)))), ==(treap_min_key(xr), @\int_min(*((xr->key)), treap_min_key(*((xr->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_min_key(xr), @\int_min(*((xr->key)), treap_min_key(*((xr->right)))))))); 
            assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr), ==(treap_prios(xr), @_vcc_intset_union(@_vcc_intset_singleton(*((xr->prio))), @_vcc_intset_union(treap_prios(*((xr->left))), treap_prios(*((xr->right))))))); 
            assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(L#xr, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap(x), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x->left))), treap(*((x->right)))), unchecked!(@_vcc_oset_in(x, @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->key)), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->prio)), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))), @_vcc_oset_disjoint(treap_reach(*((x->left))), treap_reach(*((x->right))))), @_vcc_intset_disjoint(treap_keys(*((x->left))), treap_keys(*((x->right))))), @_vcc_intset_disjoint(treap_prios(*((x->left))), treap_prios(*((x->right))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_key(*((x->left))), *((x->key))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(*((x->key)), treap_min_key(*((x->right)))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_prio(*((x->left))), *((x->prio))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(treap_max_prio(*((x->right))), *((x->prio))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap($s, $phys_ptr_cast(P#x, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(P#x, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_reach(x), @_vcc_oset_union(@_vcc_oset_singleton(x), @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(P#x, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(P#x, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_keys(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->key))), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), @\int_max(treap_max_key(*((x->left))), treap_max_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), @\int_max(treap_max_prio(*((x->left))), treap_max_prio(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), @\int_min(treap_min_key(*((x->left))), treap_min_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_prios(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->prio))), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // struct b_node* x1; 
            // x1 := x; 
            SL#x1 := $phys_ptr_cast(P#x, ^b_node);
            // struct b_node* stmtexpr1#15; 
            // stmtexpr1#15 := x1; 
            stmtexpr1#15 := $phys_ptr_cast(SL#x1, ^b_node);
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap(x), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x->left))), treap(*((x->right)))), unchecked!(@_vcc_oset_in(x, @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->key)), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->prio)), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))), @_vcc_oset_disjoint(treap_reach(*((x->left))), treap_reach(*((x->right))))), @_vcc_intset_disjoint(treap_keys(*((x->left))), treap_keys(*((x->right))))), @_vcc_intset_disjoint(treap_prios(*((x->left))), treap_prios(*((x->right))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_key(*((x->left))), *((x->key))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(*((x->key)), treap_min_key(*((x->right)))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_prio(*((x->left))), *((x->prio))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(treap_max_prio(*((x->right))), *((x->prio))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap($s, $phys_ptr_cast(P#x, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(P#x, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_reach(x), @_vcc_oset_union(@_vcc_oset_singleton(x), @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(P#x, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(P#x, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_keys(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->key))), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), @\int_max(treap_max_key(*((x->left))), treap_max_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), @\int_max(treap_max_prio(*((x->left))), treap_max_prio(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), @\int_min(treap_min_key(*((x->left))), treap_min_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_prios(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->prio))), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assert @reads_check_normal((x->left)); 
            assert $thread_local($s, $phys_ptr_cast(P#x, ^b_node));
            // xl := *((x->left)); 
            L#xl := $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node);
            // assume ==>(@_vcc_ptr_neq_null(xl), ==(treap(xl), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((xl->left))), treap(*((xl->right)))), unchecked!(@_vcc_oset_in(xl, @_vcc_oset_union(treap_reach(*((xl->left))), treap_reach(*((xl->right))))))), unchecked!(@_vcc_intset_in(*((xl->key)), @_vcc_intset_union(treap_keys(*((xl->left))), treap_keys(*((xl->right))))))), unchecked!(@_vcc_intset_in(*((xl->prio)), @_vcc_intset_union(treap_prios(*((xl->left))), treap_prios(*((xl->right))))))), @_vcc_oset_disjoint(treap_reach(*((xl->left))), treap_reach(*((xl->right))))), @_vcc_intset_disjoint(treap_keys(*((xl->left))), treap_keys(*((xl->right))))), @_vcc_intset_disjoint(treap_prios(*((xl->left))), treap_prios(*((xl->right))))), ==>(@_vcc_ptr_neq_null(*((xl->left))), <(treap_max_key(*((xl->left))), *((xl->key))))), ==>(@_vcc_ptr_neq_null(*((xl->right))), <(*((xl->key)), treap_min_key(*((xl->right)))))), ==>(@_vcc_ptr_neq_null(*((xl->left))), <(treap_max_prio(*((xl->left))), *((xl->prio))))), ==>(@_vcc_ptr_neq_null(*((xl->right))), <(treap_max_prio(*((xl->right))), *((xl->prio))))))); 
            assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> F#treap($s, $phys_ptr_cast(L#xl, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(L#xl, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl), ==(treap_reach(xl), @_vcc_oset_union(@_vcc_oset_singleton(xl), @_vcc_oset_union(treap_reach(*((xl->left))), treap_reach(*((xl->right))))))); 
            assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(L#xl, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(L#xl, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl), ==(treap_keys(xl), @_vcc_intset_union(@_vcc_intset_singleton(*((xl->key))), @_vcc_intset_union(treap_keys(*((xl->left))), treap_keys(*((xl->right))))))); 
            assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(L#xl, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_max_key(xl), @\int_max(*((xl->key)), @\int_max(treap_max_key(*((xl->left))), treap_max_key(*((xl->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_eq_null(*((xl->right)))), ==(treap_max_key(xl), @\int_max(*((xl->key)), treap_max_key(*((xl->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_max_key(xl), @\int_max(*((xl->key)), treap_max_key(*((xl->right)))))))); 
            assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_max_prio(xl), @\int_max(*((xl->prio)), @\int_max(treap_max_prio(*((xl->left))), treap_max_prio(*((xl->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_eq_null(*((xl->right)))), ==(treap_max_prio(xl), @\int_max(*((xl->prio)), treap_max_prio(*((xl->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_max_prio(xl), @\int_max(*((xl->prio)), treap_max_prio(*((xl->right)))))))); 
            assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_min_key(xl), @\int_min(*((xl->key)), @\int_min(treap_min_key(*((xl->left))), treap_min_key(*((xl->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_eq_null(*((xl->right)))), ==(treap_min_key(xl), @\int_min(*((xl->key)), treap_min_key(*((xl->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_min_key(xl), @\int_min(*((xl->key)), treap_min_key(*((xl->right)))))))); 
            assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl), ==(treap_prios(xl), @_vcc_intset_union(@_vcc_intset_singleton(*((xl->prio))), @_vcc_intset_union(treap_prios(*((xl->left))), treap_prios(*((xl->right))))))); 
            assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(L#xl, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap(x), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x->left))), treap(*((x->right)))), unchecked!(@_vcc_oset_in(x, @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->key)), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->prio)), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))), @_vcc_oset_disjoint(treap_reach(*((x->left))), treap_reach(*((x->right))))), @_vcc_intset_disjoint(treap_keys(*((x->left))), treap_keys(*((x->right))))), @_vcc_intset_disjoint(treap_prios(*((x->left))), treap_prios(*((x->right))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_key(*((x->left))), *((x->key))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(*((x->key)), treap_min_key(*((x->right)))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_prio(*((x->left))), *((x->prio))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(treap_max_prio(*((x->right))), *((x->prio))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap($s, $phys_ptr_cast(P#x, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(P#x, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_reach(x), @_vcc_oset_union(@_vcc_oset_singleton(x), @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(P#x, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(P#x, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_keys(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->key))), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), @\int_max(treap_max_key(*((x->left))), treap_max_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), @\int_max(treap_max_prio(*((x->left))), treap_max_prio(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), @\int_min(treap_min_key(*((x->left))), treap_min_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_prios(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->prio))), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // _math \state _dryad_S0#0; 
            // _dryad_S0#0 := @_vcc_current_state(@state); 
            _dryad_S0#0 := $current_state($s);
            // _math \state stmtexpr2#16; 
            // stmtexpr2#16 := _dryad_S0#0; 
            stmtexpr2#16 := _dryad_S0#0;
            // non-pure function
            // tmp := treap_insert_rec(xl, k, p); 
            call L#tmp := treap_insert_rec($phys_ptr_cast(L#xl, ^b_node), P#k, P#p);
            assume $full_stop_ext(#tok$3^48.21, $s);
            // _math \state _dryad_S1#1; 
            // _dryad_S1#1 := @_vcc_current_state(@state); 
            _dryad_S1#1 := $current_state($s);
            // _math \state stmtexpr3#17; 
            // stmtexpr3#17 := _dryad_S1#1; 
            stmtexpr3#17 := _dryad_S1#1;
            // assume @_vcc_oset_disjoint(treap_reach(tmp), @_vcc_oset_diff(_dryad_G1, old(_dryad_S0#0, treap_reach(xl)))); 
            assume $oset_disjoint(F#treap_reach($s, $phys_ptr_cast(L#tmp, ^b_node)), $oset_diff(SL#_dryad_G1, F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))));
            // _math \oset res_treap_reach#1; 
            // res_treap_reach#1 := treap_reach(tmp); 
            call res_treap_reach#1 := treap_reach($phys_ptr_cast(L#tmp, ^b_node));
            assume $full_stop_ext(#tok$4^0.0, $s);
            // _dryad_G1 := @_vcc_oset_union(res_treap_reach#1, @_vcc_oset_diff(_dryad_G1, pure(old(_dryad_S0#0, treap_reach(xl))))); 
            SL#_dryad_G1 := $oset_union(res_treap_reach#1, $oset_diff(SL#_dryad_G1, F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))));
            // _math \oset stmtexpr4#18; 
            // stmtexpr4#18 := _dryad_G1; 
            stmtexpr4#18 := SL#_dryad_G1;
            // assume ==(glob_reach(), _dryad_G1); 
            assume F#glob_reach() == SL#_dryad_G1;
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(x1))), ==(old(_dryad_S0#0, treap(x1)), old(_dryad_S1#1, treap(x1)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(SL#x1, ^b_node))) ==> F#treap(_dryad_S0#0, $phys_ptr_cast(SL#x1, ^b_node)) == F#treap(_dryad_S1#1, $phys_ptr_cast(SL#x1, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(x1))), ==(old(_dryad_S0#0, treap_reach(x1)), old(_dryad_S1#1, treap_reach(x1)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(SL#x1, ^b_node))) ==> F#treap_reach(_dryad_S0#0, $phys_ptr_cast(SL#x1, ^b_node)) == F#treap_reach(_dryad_S1#1, $phys_ptr_cast(SL#x1, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(x1))), ==(old(_dryad_S0#0, treap_keys(x1)), old(_dryad_S1#1, treap_keys(x1)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(SL#x1, ^b_node))) ==> F#treap_keys(_dryad_S0#0, $phys_ptr_cast(SL#x1, ^b_node)) == F#treap_keys(_dryad_S1#1, $phys_ptr_cast(SL#x1, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(x1))), ==(old(_dryad_S0#0, treap_max_key(x1)), old(_dryad_S1#1, treap_max_key(x1)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(SL#x1, ^b_node))) ==> F#treap_max_key(_dryad_S0#0, $phys_ptr_cast(SL#x1, ^b_node)) == F#treap_max_key(_dryad_S1#1, $phys_ptr_cast(SL#x1, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(x1))), ==(old(_dryad_S0#0, treap_max_prio(x1)), old(_dryad_S1#1, treap_max_prio(x1)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(SL#x1, ^b_node))) ==> F#treap_max_prio(_dryad_S0#0, $phys_ptr_cast(SL#x1, ^b_node)) == F#treap_max_prio(_dryad_S1#1, $phys_ptr_cast(SL#x1, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(x1))), ==(old(_dryad_S0#0, treap_min_key(x1)), old(_dryad_S1#1, treap_min_key(x1)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(SL#x1, ^b_node))) ==> F#treap_min_key(_dryad_S0#0, $phys_ptr_cast(SL#x1, ^b_node)) == F#treap_min_key(_dryad_S1#1, $phys_ptr_cast(SL#x1, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(x1))), ==(old(_dryad_S0#0, treap_prios(x1)), old(_dryad_S1#1, treap_prios(x1)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(SL#x1, ^b_node))) ==> F#treap_prios(_dryad_S0#0, $phys_ptr_cast(SL#x1, ^b_node)) == F#treap_prios(_dryad_S1#1, $phys_ptr_cast(SL#x1, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(x0))), ==(old(_dryad_S0#0, treap(x0)), old(_dryad_S1#1, treap(x0)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(SL#x0, ^b_node))) ==> F#treap(_dryad_S0#0, $phys_ptr_cast(SL#x0, ^b_node)) == F#treap(_dryad_S1#1, $phys_ptr_cast(SL#x0, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(x0))), ==(old(_dryad_S0#0, treap_reach(x0)), old(_dryad_S1#1, treap_reach(x0)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(SL#x0, ^b_node))) ==> F#treap_reach(_dryad_S0#0, $phys_ptr_cast(SL#x0, ^b_node)) == F#treap_reach(_dryad_S1#1, $phys_ptr_cast(SL#x0, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(x0))), ==(old(_dryad_S0#0, treap_keys(x0)), old(_dryad_S1#1, treap_keys(x0)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(SL#x0, ^b_node))) ==> F#treap_keys(_dryad_S0#0, $phys_ptr_cast(SL#x0, ^b_node)) == F#treap_keys(_dryad_S1#1, $phys_ptr_cast(SL#x0, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(x0))), ==(old(_dryad_S0#0, treap_max_key(x0)), old(_dryad_S1#1, treap_max_key(x0)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(SL#x0, ^b_node))) ==> F#treap_max_key(_dryad_S0#0, $phys_ptr_cast(SL#x0, ^b_node)) == F#treap_max_key(_dryad_S1#1, $phys_ptr_cast(SL#x0, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(x0))), ==(old(_dryad_S0#0, treap_max_prio(x0)), old(_dryad_S1#1, treap_max_prio(x0)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(SL#x0, ^b_node))) ==> F#treap_max_prio(_dryad_S0#0, $phys_ptr_cast(SL#x0, ^b_node)) == F#treap_max_prio(_dryad_S1#1, $phys_ptr_cast(SL#x0, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(x0))), ==(old(_dryad_S0#0, treap_min_key(x0)), old(_dryad_S1#1, treap_min_key(x0)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(SL#x0, ^b_node))) ==> F#treap_min_key(_dryad_S0#0, $phys_ptr_cast(SL#x0, ^b_node)) == F#treap_min_key(_dryad_S1#1, $phys_ptr_cast(SL#x0, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(x0))), ==(old(_dryad_S0#0, treap_prios(x0)), old(_dryad_S1#1, treap_prios(x0)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(SL#x0, ^b_node))) ==> F#treap_prios(_dryad_S0#0, $phys_ptr_cast(SL#x0, ^b_node)) == F#treap_prios(_dryad_S1#1, $phys_ptr_cast(SL#x0, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(xr))), ==(old(_dryad_S0#0, treap(xr)), old(_dryad_S1#1, treap(xr)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xr, ^b_node))) ==> F#treap(_dryad_S0#0, $phys_ptr_cast(L#xr, ^b_node)) == F#treap(_dryad_S1#1, $phys_ptr_cast(L#xr, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(xr))), ==(old(_dryad_S0#0, treap_reach(xr)), old(_dryad_S1#1, treap_reach(xr)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xr, ^b_node))) ==> F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xr, ^b_node)) == F#treap_reach(_dryad_S1#1, $phys_ptr_cast(L#xr, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(xr))), ==(old(_dryad_S0#0, treap_keys(xr)), old(_dryad_S1#1, treap_keys(xr)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xr, ^b_node))) ==> F#treap_keys(_dryad_S0#0, $phys_ptr_cast(L#xr, ^b_node)) == F#treap_keys(_dryad_S1#1, $phys_ptr_cast(L#xr, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(xr))), ==(old(_dryad_S0#0, treap_max_key(xr)), old(_dryad_S1#1, treap_max_key(xr)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xr, ^b_node))) ==> F#treap_max_key(_dryad_S0#0, $phys_ptr_cast(L#xr, ^b_node)) == F#treap_max_key(_dryad_S1#1, $phys_ptr_cast(L#xr, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(xr))), ==(old(_dryad_S0#0, treap_max_prio(xr)), old(_dryad_S1#1, treap_max_prio(xr)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xr, ^b_node))) ==> F#treap_max_prio(_dryad_S0#0, $phys_ptr_cast(L#xr, ^b_node)) == F#treap_max_prio(_dryad_S1#1, $phys_ptr_cast(L#xr, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(xr))), ==(old(_dryad_S0#0, treap_min_key(xr)), old(_dryad_S1#1, treap_min_key(xr)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xr, ^b_node))) ==> F#treap_min_key(_dryad_S0#0, $phys_ptr_cast(L#xr, ^b_node)) == F#treap_min_key(_dryad_S1#1, $phys_ptr_cast(L#xr, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(xr))), ==(old(_dryad_S0#0, treap_prios(xr)), old(_dryad_S1#1, treap_prios(xr)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xr, ^b_node))) ==> F#treap_prios(_dryad_S0#0, $phys_ptr_cast(L#xr, ^b_node)) == F#treap_prios(_dryad_S1#1, $phys_ptr_cast(L#xr, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(xl))), ==(old(_dryad_S0#0, treap(xl)), old(_dryad_S1#1, treap(xl)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> F#treap(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)) == F#treap(_dryad_S1#1, $phys_ptr_cast(L#xl, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(xl))), ==(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S1#1, treap_reach(xl)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)) == F#treap_reach(_dryad_S1#1, $phys_ptr_cast(L#xl, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(xl))), ==(old(_dryad_S0#0, treap_keys(xl)), old(_dryad_S1#1, treap_keys(xl)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> F#treap_keys(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)) == F#treap_keys(_dryad_S1#1, $phys_ptr_cast(L#xl, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(xl))), ==(old(_dryad_S0#0, treap_max_key(xl)), old(_dryad_S1#1, treap_max_key(xl)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> F#treap_max_key(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)) == F#treap_max_key(_dryad_S1#1, $phys_ptr_cast(L#xl, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(xl))), ==(old(_dryad_S0#0, treap_max_prio(xl)), old(_dryad_S1#1, treap_max_prio(xl)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> F#treap_max_prio(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)) == F#treap_max_prio(_dryad_S1#1, $phys_ptr_cast(L#xl, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(xl))), ==(old(_dryad_S0#0, treap_min_key(xl)), old(_dryad_S1#1, treap_min_key(xl)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> F#treap_min_key(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)) == F#treap_min_key(_dryad_S1#1, $phys_ptr_cast(L#xl, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(xl))), ==(old(_dryad_S0#0, treap_prios(xl)), old(_dryad_S1#1, treap_prios(xl)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> F#treap_prios(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)) == F#treap_prios(_dryad_S1#1, $phys_ptr_cast(L#xl, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(x))), ==(old(_dryad_S0#0, treap(x)), old(_dryad_S1#1, treap(x)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap(_dryad_S0#0, $phys_ptr_cast(P#x, ^b_node)) == F#treap(_dryad_S1#1, $phys_ptr_cast(P#x, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(x))), ==(old(_dryad_S0#0, treap_reach(x)), old(_dryad_S1#1, treap_reach(x)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_reach(_dryad_S0#0, $phys_ptr_cast(P#x, ^b_node)) == F#treap_reach(_dryad_S1#1, $phys_ptr_cast(P#x, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(x))), ==(old(_dryad_S0#0, treap_keys(x)), old(_dryad_S1#1, treap_keys(x)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_keys(_dryad_S0#0, $phys_ptr_cast(P#x, ^b_node)) == F#treap_keys(_dryad_S1#1, $phys_ptr_cast(P#x, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(x))), ==(old(_dryad_S0#0, treap_max_key(x)), old(_dryad_S1#1, treap_max_key(x)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_max_key(_dryad_S0#0, $phys_ptr_cast(P#x, ^b_node)) == F#treap_max_key(_dryad_S1#1, $phys_ptr_cast(P#x, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(x))), ==(old(_dryad_S0#0, treap_max_prio(x)), old(_dryad_S1#1, treap_max_prio(x)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_max_prio(_dryad_S0#0, $phys_ptr_cast(P#x, ^b_node)) == F#treap_max_prio(_dryad_S1#1, $phys_ptr_cast(P#x, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(x))), ==(old(_dryad_S0#0, treap_min_key(x)), old(_dryad_S1#1, treap_min_key(x)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_min_key(_dryad_S0#0, $phys_ptr_cast(P#x, ^b_node)) == F#treap_min_key(_dryad_S1#1, $phys_ptr_cast(P#x, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#0, treap_reach(xl)), old(_dryad_S0#0, treap_reach(x))), ==(old(_dryad_S0#0, treap_prios(x)), old(_dryad_S1#1, treap_prios(x)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node)), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_prios(_dryad_S0#0, $phys_ptr_cast(P#x, ^b_node)) == F#treap_prios(_dryad_S1#1, $phys_ptr_cast(P#x, ^b_node));
            // assume ==>(@_vcc_ptr_neq_null(x1), ==(treap(x1), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x1->left))), treap(*((x1->right)))), unchecked!(@_vcc_oset_in(x1, @_vcc_oset_union(treap_reach(*((x1->left))), treap_reach(*((x1->right))))))), unchecked!(@_vcc_intset_in(*((x1->key)), @_vcc_intset_union(treap_keys(*((x1->left))), treap_keys(*((x1->right))))))), unchecked!(@_vcc_intset_in(*((x1->prio)), @_vcc_intset_union(treap_prios(*((x1->left))), treap_prios(*((x1->right))))))), @_vcc_oset_disjoint(treap_reach(*((x1->left))), treap_reach(*((x1->right))))), @_vcc_intset_disjoint(treap_keys(*((x1->left))), treap_keys(*((x1->right))))), @_vcc_intset_disjoint(treap_prios(*((x1->left))), treap_prios(*((x1->right))))), ==>(@_vcc_ptr_neq_null(*((x1->left))), <(treap_max_key(*((x1->left))), *((x1->key))))), ==>(@_vcc_ptr_neq_null(*((x1->right))), <(*((x1->key)), treap_min_key(*((x1->right)))))), ==>(@_vcc_ptr_neq_null(*((x1->left))), <(treap_max_prio(*((x1->left))), *((x1->prio))))), ==>(@_vcc_ptr_neq_null(*((x1->right))), <(treap_max_prio(*((x1->right))), *((x1->prio))))))); 
            assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> F#treap($s, $phys_ptr_cast(SL#x1, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(SL#x1, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x1), ==(treap_reach(x1), @_vcc_oset_union(@_vcc_oset_singleton(x1), @_vcc_oset_union(treap_reach(*((x1->left))), treap_reach(*((x1->right))))))); 
            assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(SL#x1, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(SL#x1, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x1), ==(treap_keys(x1), @_vcc_intset_union(@_vcc_intset_singleton(*((x1->key))), @_vcc_intset_union(treap_keys(*((x1->left))), treap_keys(*((x1->right))))))); 
            assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(SL#x1, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x1), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x1->left))), @_vcc_ptr_neq_null(*((x1->right)))), ==(treap_max_key(x1), @\int_max(*((x1->key)), @\int_max(treap_max_key(*((x1->left))), treap_max_key(*((x1->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x1->left))), @_vcc_ptr_eq_null(*((x1->right)))), ==(treap_max_key(x1), @\int_max(*((x1->key)), treap_max_key(*((x1->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x1->left))), @_vcc_ptr_neq_null(*((x1->right)))), ==(treap_max_key(x1), @\int_max(*((x1->key)), treap_max_key(*((x1->right)))))))); 
            assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x1), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x1->left))), @_vcc_ptr_neq_null(*((x1->right)))), ==(treap_max_prio(x1), @\int_max(*((x1->prio)), @\int_max(treap_max_prio(*((x1->left))), treap_max_prio(*((x1->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x1->left))), @_vcc_ptr_eq_null(*((x1->right)))), ==(treap_max_prio(x1), @\int_max(*((x1->prio)), treap_max_prio(*((x1->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x1->left))), @_vcc_ptr_neq_null(*((x1->right)))), ==(treap_max_prio(x1), @\int_max(*((x1->prio)), treap_max_prio(*((x1->right)))))))); 
            assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x1), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x1->left))), @_vcc_ptr_neq_null(*((x1->right)))), ==(treap_min_key(x1), @\int_min(*((x1->key)), @\int_min(treap_min_key(*((x1->left))), treap_min_key(*((x1->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x1->left))), @_vcc_ptr_eq_null(*((x1->right)))), ==(treap_min_key(x1), @\int_min(*((x1->key)), treap_min_key(*((x1->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x1->left))), @_vcc_ptr_neq_null(*((x1->right)))), ==(treap_min_key(x1), @\int_min(*((x1->key)), treap_min_key(*((x1->right)))))))); 
            assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x1), ==(treap_prios(x1), @_vcc_intset_union(@_vcc_intset_singleton(*((x1->prio))), @_vcc_intset_union(treap_prios(*((x1->left))), treap_prios(*((x1->right))))))); 
            assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(SL#x1, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x0), ==(treap(x0), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x0->left))), treap(*((x0->right)))), unchecked!(@_vcc_oset_in(x0, @_vcc_oset_union(treap_reach(*((x0->left))), treap_reach(*((x0->right))))))), unchecked!(@_vcc_intset_in(*((x0->key)), @_vcc_intset_union(treap_keys(*((x0->left))), treap_keys(*((x0->right))))))), unchecked!(@_vcc_intset_in(*((x0->prio)), @_vcc_intset_union(treap_prios(*((x0->left))), treap_prios(*((x0->right))))))), @_vcc_oset_disjoint(treap_reach(*((x0->left))), treap_reach(*((x0->right))))), @_vcc_intset_disjoint(treap_keys(*((x0->left))), treap_keys(*((x0->right))))), @_vcc_intset_disjoint(treap_prios(*((x0->left))), treap_prios(*((x0->right))))), ==>(@_vcc_ptr_neq_null(*((x0->left))), <(treap_max_key(*((x0->left))), *((x0->key))))), ==>(@_vcc_ptr_neq_null(*((x0->right))), <(*((x0->key)), treap_min_key(*((x0->right)))))), ==>(@_vcc_ptr_neq_null(*((x0->left))), <(treap_max_prio(*((x0->left))), *((x0->prio))))), ==>(@_vcc_ptr_neq_null(*((x0->right))), <(treap_max_prio(*((x0->right))), *((x0->prio))))))); 
            assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> F#treap($s, $phys_ptr_cast(SL#x0, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(SL#x0, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x0), ==(treap_reach(x0), @_vcc_oset_union(@_vcc_oset_singleton(x0), @_vcc_oset_union(treap_reach(*((x0->left))), treap_reach(*((x0->right))))))); 
            assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(SL#x0, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(SL#x0, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x0), ==(treap_keys(x0), @_vcc_intset_union(@_vcc_intset_singleton(*((x0->key))), @_vcc_intset_union(treap_keys(*((x0->left))), treap_keys(*((x0->right))))))); 
            assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(SL#x0, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x0), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x0->left))), @_vcc_ptr_neq_null(*((x0->right)))), ==(treap_max_key(x0), @\int_max(*((x0->key)), @\int_max(treap_max_key(*((x0->left))), treap_max_key(*((x0->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x0->left))), @_vcc_ptr_eq_null(*((x0->right)))), ==(treap_max_key(x0), @\int_max(*((x0->key)), treap_max_key(*((x0->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x0->left))), @_vcc_ptr_neq_null(*((x0->right)))), ==(treap_max_key(x0), @\int_max(*((x0->key)), treap_max_key(*((x0->right)))))))); 
            assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x0), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x0->left))), @_vcc_ptr_neq_null(*((x0->right)))), ==(treap_max_prio(x0), @\int_max(*((x0->prio)), @\int_max(treap_max_prio(*((x0->left))), treap_max_prio(*((x0->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x0->left))), @_vcc_ptr_eq_null(*((x0->right)))), ==(treap_max_prio(x0), @\int_max(*((x0->prio)), treap_max_prio(*((x0->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x0->left))), @_vcc_ptr_neq_null(*((x0->right)))), ==(treap_max_prio(x0), @\int_max(*((x0->prio)), treap_max_prio(*((x0->right)))))))); 
            assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x0), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x0->left))), @_vcc_ptr_neq_null(*((x0->right)))), ==(treap_min_key(x0), @\int_min(*((x0->key)), @\int_min(treap_min_key(*((x0->left))), treap_min_key(*((x0->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x0->left))), @_vcc_ptr_eq_null(*((x0->right)))), ==(treap_min_key(x0), @\int_min(*((x0->key)), treap_min_key(*((x0->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x0->left))), @_vcc_ptr_neq_null(*((x0->right)))), ==(treap_min_key(x0), @\int_min(*((x0->key)), treap_min_key(*((x0->right)))))))); 
            assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x0), ==(treap_prios(x0), @_vcc_intset_union(@_vcc_intset_singleton(*((x0->prio))), @_vcc_intset_union(treap_prios(*((x0->left))), treap_prios(*((x0->right))))))); 
            assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(SL#x0, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr), ==(treap(xr), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((xr->left))), treap(*((xr->right)))), unchecked!(@_vcc_oset_in(xr, @_vcc_oset_union(treap_reach(*((xr->left))), treap_reach(*((xr->right))))))), unchecked!(@_vcc_intset_in(*((xr->key)), @_vcc_intset_union(treap_keys(*((xr->left))), treap_keys(*((xr->right))))))), unchecked!(@_vcc_intset_in(*((xr->prio)), @_vcc_intset_union(treap_prios(*((xr->left))), treap_prios(*((xr->right))))))), @_vcc_oset_disjoint(treap_reach(*((xr->left))), treap_reach(*((xr->right))))), @_vcc_intset_disjoint(treap_keys(*((xr->left))), treap_keys(*((xr->right))))), @_vcc_intset_disjoint(treap_prios(*((xr->left))), treap_prios(*((xr->right))))), ==>(@_vcc_ptr_neq_null(*((xr->left))), <(treap_max_key(*((xr->left))), *((xr->key))))), ==>(@_vcc_ptr_neq_null(*((xr->right))), <(*((xr->key)), treap_min_key(*((xr->right)))))), ==>(@_vcc_ptr_neq_null(*((xr->left))), <(treap_max_prio(*((xr->left))), *((xr->prio))))), ==>(@_vcc_ptr_neq_null(*((xr->right))), <(treap_max_prio(*((xr->right))), *((xr->prio))))))); 
            assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> F#treap($s, $phys_ptr_cast(L#xr, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(L#xr, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr), ==(treap_reach(xr), @_vcc_oset_union(@_vcc_oset_singleton(xr), @_vcc_oset_union(treap_reach(*((xr->left))), treap_reach(*((xr->right))))))); 
            assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(L#xr, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(L#xr, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr), ==(treap_keys(xr), @_vcc_intset_union(@_vcc_intset_singleton(*((xr->key))), @_vcc_intset_union(treap_keys(*((xr->left))), treap_keys(*((xr->right))))))); 
            assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(L#xr, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_max_key(xr), @\int_max(*((xr->key)), @\int_max(treap_max_key(*((xr->left))), treap_max_key(*((xr->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_eq_null(*((xr->right)))), ==(treap_max_key(xr), @\int_max(*((xr->key)), treap_max_key(*((xr->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_max_key(xr), @\int_max(*((xr->key)), treap_max_key(*((xr->right)))))))); 
            assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_max_prio(xr), @\int_max(*((xr->prio)), @\int_max(treap_max_prio(*((xr->left))), treap_max_prio(*((xr->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_eq_null(*((xr->right)))), ==(treap_max_prio(xr), @\int_max(*((xr->prio)), treap_max_prio(*((xr->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_max_prio(xr), @\int_max(*((xr->prio)), treap_max_prio(*((xr->right)))))))); 
            assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_min_key(xr), @\int_min(*((xr->key)), @\int_min(treap_min_key(*((xr->left))), treap_min_key(*((xr->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_eq_null(*((xr->right)))), ==(treap_min_key(xr), @\int_min(*((xr->key)), treap_min_key(*((xr->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_min_key(xr), @\int_min(*((xr->key)), treap_min_key(*((xr->right)))))))); 
            assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr), ==(treap_prios(xr), @_vcc_intset_union(@_vcc_intset_singleton(*((xr->prio))), @_vcc_intset_union(treap_prios(*((xr->left))), treap_prios(*((xr->right))))))); 
            assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(L#xr, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl), ==(treap(xl), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((xl->left))), treap(*((xl->right)))), unchecked!(@_vcc_oset_in(xl, @_vcc_oset_union(treap_reach(*((xl->left))), treap_reach(*((xl->right))))))), unchecked!(@_vcc_intset_in(*((xl->key)), @_vcc_intset_union(treap_keys(*((xl->left))), treap_keys(*((xl->right))))))), unchecked!(@_vcc_intset_in(*((xl->prio)), @_vcc_intset_union(treap_prios(*((xl->left))), treap_prios(*((xl->right))))))), @_vcc_oset_disjoint(treap_reach(*((xl->left))), treap_reach(*((xl->right))))), @_vcc_intset_disjoint(treap_keys(*((xl->left))), treap_keys(*((xl->right))))), @_vcc_intset_disjoint(treap_prios(*((xl->left))), treap_prios(*((xl->right))))), ==>(@_vcc_ptr_neq_null(*((xl->left))), <(treap_max_key(*((xl->left))), *((xl->key))))), ==>(@_vcc_ptr_neq_null(*((xl->right))), <(*((xl->key)), treap_min_key(*((xl->right)))))), ==>(@_vcc_ptr_neq_null(*((xl->left))), <(treap_max_prio(*((xl->left))), *((xl->prio))))), ==>(@_vcc_ptr_neq_null(*((xl->right))), <(treap_max_prio(*((xl->right))), *((xl->prio))))))); 
            assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> F#treap($s, $phys_ptr_cast(L#xl, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(L#xl, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl), ==(treap_reach(xl), @_vcc_oset_union(@_vcc_oset_singleton(xl), @_vcc_oset_union(treap_reach(*((xl->left))), treap_reach(*((xl->right))))))); 
            assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(L#xl, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(L#xl, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl), ==(treap_keys(xl), @_vcc_intset_union(@_vcc_intset_singleton(*((xl->key))), @_vcc_intset_union(treap_keys(*((xl->left))), treap_keys(*((xl->right))))))); 
            assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(L#xl, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_max_key(xl), @\int_max(*((xl->key)), @\int_max(treap_max_key(*((xl->left))), treap_max_key(*((xl->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_eq_null(*((xl->right)))), ==(treap_max_key(xl), @\int_max(*((xl->key)), treap_max_key(*((xl->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_max_key(xl), @\int_max(*((xl->key)), treap_max_key(*((xl->right)))))))); 
            assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_max_prio(xl), @\int_max(*((xl->prio)), @\int_max(treap_max_prio(*((xl->left))), treap_max_prio(*((xl->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_eq_null(*((xl->right)))), ==(treap_max_prio(xl), @\int_max(*((xl->prio)), treap_max_prio(*((xl->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_max_prio(xl), @\int_max(*((xl->prio)), treap_max_prio(*((xl->right)))))))); 
            assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_min_key(xl), @\int_min(*((xl->key)), @\int_min(treap_min_key(*((xl->left))), treap_min_key(*((xl->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_eq_null(*((xl->right)))), ==(treap_min_key(xl), @\int_min(*((xl->key)), treap_min_key(*((xl->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_min_key(xl), @\int_min(*((xl->key)), treap_min_key(*((xl->right)))))))); 
            assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl), ==(treap_prios(xl), @_vcc_intset_union(@_vcc_intset_singleton(*((xl->prio))), @_vcc_intset_union(treap_prios(*((xl->left))), treap_prios(*((xl->right))))))); 
            assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(L#xl, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(tmp), ==(treap(tmp), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((tmp->left))), treap(*((tmp->right)))), unchecked!(@_vcc_oset_in(tmp, @_vcc_oset_union(treap_reach(*((tmp->left))), treap_reach(*((tmp->right))))))), unchecked!(@_vcc_intset_in(*((tmp->key)), @_vcc_intset_union(treap_keys(*((tmp->left))), treap_keys(*((tmp->right))))))), unchecked!(@_vcc_intset_in(*((tmp->prio)), @_vcc_intset_union(treap_prios(*((tmp->left))), treap_prios(*((tmp->right))))))), @_vcc_oset_disjoint(treap_reach(*((tmp->left))), treap_reach(*((tmp->right))))), @_vcc_intset_disjoint(treap_keys(*((tmp->left))), treap_keys(*((tmp->right))))), @_vcc_intset_disjoint(treap_prios(*((tmp->left))), treap_prios(*((tmp->right))))), ==>(@_vcc_ptr_neq_null(*((tmp->left))), <(treap_max_key(*((tmp->left))), *((tmp->key))))), ==>(@_vcc_ptr_neq_null(*((tmp->right))), <(*((tmp->key)), treap_min_key(*((tmp->right)))))), ==>(@_vcc_ptr_neq_null(*((tmp->left))), <(treap_max_prio(*((tmp->left))), *((tmp->prio))))), ==>(@_vcc_ptr_neq_null(*((tmp->right))), <(treap_max_prio(*((tmp->right))), *((tmp->prio))))))); 
            assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> F#treap($s, $phys_ptr_cast(L#tmp, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(L#tmp, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(tmp), ==(treap_reach(tmp), @_vcc_oset_union(@_vcc_oset_singleton(tmp), @_vcc_oset_union(treap_reach(*((tmp->left))), treap_reach(*((tmp->right))))))); 
            assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(L#tmp, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(L#tmp, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(tmp), ==(treap_keys(tmp), @_vcc_intset_union(@_vcc_intset_singleton(*((tmp->key))), @_vcc_intset_union(treap_keys(*((tmp->left))), treap_keys(*((tmp->right))))))); 
            assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(L#tmp, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(tmp), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_max_key(tmp), @\int_max(*((tmp->key)), @\int_max(treap_max_key(*((tmp->left))), treap_max_key(*((tmp->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_eq_null(*((tmp->right)))), ==(treap_max_key(tmp), @\int_max(*((tmp->key)), treap_max_key(*((tmp->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_max_key(tmp), @\int_max(*((tmp->key)), treap_max_key(*((tmp->right)))))))); 
            assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(tmp), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_max_prio(tmp), @\int_max(*((tmp->prio)), @\int_max(treap_max_prio(*((tmp->left))), treap_max_prio(*((tmp->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_eq_null(*((tmp->right)))), ==(treap_max_prio(tmp), @\int_max(*((tmp->prio)), treap_max_prio(*((tmp->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_max_prio(tmp), @\int_max(*((tmp->prio)), treap_max_prio(*((tmp->right)))))))); 
            assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(tmp), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_min_key(tmp), @\int_min(*((tmp->key)), @\int_min(treap_min_key(*((tmp->left))), treap_min_key(*((tmp->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_eq_null(*((tmp->right)))), ==(treap_min_key(tmp), @\int_min(*((tmp->key)), treap_min_key(*((tmp->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_min_key(tmp), @\int_min(*((tmp->key)), treap_min_key(*((tmp->right)))))))); 
            assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(tmp), ==(treap_prios(tmp), @_vcc_intset_union(@_vcc_intset_singleton(*((tmp->prio))), @_vcc_intset_union(treap_prios(*((tmp->left))), treap_prios(*((tmp->right))))))); 
            assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(L#tmp, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap(x), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x->left))), treap(*((x->right)))), unchecked!(@_vcc_oset_in(x, @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->key)), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->prio)), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))), @_vcc_oset_disjoint(treap_reach(*((x->left))), treap_reach(*((x->right))))), @_vcc_intset_disjoint(treap_keys(*((x->left))), treap_keys(*((x->right))))), @_vcc_intset_disjoint(treap_prios(*((x->left))), treap_prios(*((x->right))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_key(*((x->left))), *((x->key))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(*((x->key)), treap_min_key(*((x->right)))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_prio(*((x->left))), *((x->prio))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(treap_max_prio(*((x->right))), *((x->prio))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap($s, $phys_ptr_cast(P#x, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(P#x, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_reach(x), @_vcc_oset_union(@_vcc_oset_singleton(x), @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(P#x, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(P#x, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_keys(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->key))), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), @\int_max(treap_max_key(*((x->left))), treap_max_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), @\int_max(treap_max_prio(*((x->left))), treap_max_prio(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), @\int_min(treap_min_key(*((x->left))), treap_min_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_prios(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->prio))), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(!(@_vcc_oset_in(x1, old(_dryad_S0#0, treap_reach(xl)))), @_vcc_ptr_eq_pure(*((x1->left)), old(_dryad_S0#0, *((x1->left))))); 
            assume !$oset_in($phys_ptr_cast(SL#x1, ^b_node), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S0#0, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_oset_in(x1, old(_dryad_S0#0, treap_reach(xl)))), @_vcc_ptr_eq_pure(*((x1->right)), old(_dryad_S0#0, *((x1->right))))); 
            assume !$oset_in($phys_ptr_cast(SL#x1, ^b_node), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S0#0, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_oset_in(x1, old(_dryad_S0#0, treap_reach(xl)))), ==(*((x1->key)), old(_dryad_S0#0, *((x1->key))))); 
            assume !$oset_in($phys_ptr_cast(SL#x1, ^b_node), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)) == $rd_inv(_dryad_S0#0, b_node.key, $phys_ptr_cast(SL#x1, ^b_node));
            // assume ==>(!(@_vcc_oset_in(x1, old(_dryad_S0#0, treap_reach(xl)))), ==(*((x1->prio)), old(_dryad_S0#0, *((x1->prio))))); 
            assume !$oset_in($phys_ptr_cast(SL#x1, ^b_node), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node)) == $rd_inv(_dryad_S0#0, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node));
            // assume ==>(!(@_vcc_oset_in(x0, old(_dryad_S0#0, treap_reach(xl)))), @_vcc_ptr_eq_pure(*((x0->left)), old(_dryad_S0#0, *((x0->left))))); 
            assume !$oset_in($phys_ptr_cast(SL#x0, ^b_node), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S0#0, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_oset_in(x0, old(_dryad_S0#0, treap_reach(xl)))), @_vcc_ptr_eq_pure(*((x0->right)), old(_dryad_S0#0, *((x0->right))))); 
            assume !$oset_in($phys_ptr_cast(SL#x0, ^b_node), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S0#0, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_oset_in(x0, old(_dryad_S0#0, treap_reach(xl)))), ==(*((x0->key)), old(_dryad_S0#0, *((x0->key))))); 
            assume !$oset_in($phys_ptr_cast(SL#x0, ^b_node), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)) == $rd_inv(_dryad_S0#0, b_node.key, $phys_ptr_cast(SL#x0, ^b_node));
            // assume ==>(!(@_vcc_oset_in(x0, old(_dryad_S0#0, treap_reach(xl)))), ==(*((x0->prio)), old(_dryad_S0#0, *((x0->prio))))); 
            assume !$oset_in($phys_ptr_cast(SL#x0, ^b_node), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node)) == $rd_inv(_dryad_S0#0, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node));
            // assume ==>(!(@_vcc_oset_in(xr, old(_dryad_S0#0, treap_reach(xl)))), @_vcc_ptr_eq_pure(*((xr->left)), old(_dryad_S0#0, *((xr->left))))); 
            assume !$oset_in($phys_ptr_cast(L#xr, ^b_node), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S0#0, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_oset_in(xr, old(_dryad_S0#0, treap_reach(xl)))), @_vcc_ptr_eq_pure(*((xr->right)), old(_dryad_S0#0, *((xr->right))))); 
            assume !$oset_in($phys_ptr_cast(L#xr, ^b_node), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S0#0, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_oset_in(xr, old(_dryad_S0#0, treap_reach(xl)))), ==(*((xr->key)), old(_dryad_S0#0, *((xr->key))))); 
            assume !$oset_in($phys_ptr_cast(L#xr, ^b_node), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)) == $rd_inv(_dryad_S0#0, b_node.key, $phys_ptr_cast(L#xr, ^b_node));
            // assume ==>(!(@_vcc_oset_in(xr, old(_dryad_S0#0, treap_reach(xl)))), ==(*((xr->prio)), old(_dryad_S0#0, *((xr->prio))))); 
            assume !$oset_in($phys_ptr_cast(L#xr, ^b_node), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node)) == $rd_inv(_dryad_S0#0, b_node.prio, $phys_ptr_cast(L#xr, ^b_node));
            // assume ==>(!(@_vcc_oset_in(xl, old(_dryad_S0#0, treap_reach(xl)))), @_vcc_ptr_eq_pure(*((xl->left)), old(_dryad_S0#0, *((xl->left))))); 
            assume !$oset_in($phys_ptr_cast(L#xl, ^b_node), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S0#0, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_oset_in(xl, old(_dryad_S0#0, treap_reach(xl)))), @_vcc_ptr_eq_pure(*((xl->right)), old(_dryad_S0#0, *((xl->right))))); 
            assume !$oset_in($phys_ptr_cast(L#xl, ^b_node), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S0#0, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_oset_in(xl, old(_dryad_S0#0, treap_reach(xl)))), ==(*((xl->key)), old(_dryad_S0#0, *((xl->key))))); 
            assume !$oset_in($phys_ptr_cast(L#xl, ^b_node), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)) == $rd_inv(_dryad_S0#0, b_node.key, $phys_ptr_cast(L#xl, ^b_node));
            // assume ==>(!(@_vcc_oset_in(xl, old(_dryad_S0#0, treap_reach(xl)))), ==(*((xl->prio)), old(_dryad_S0#0, *((xl->prio))))); 
            assume !$oset_in($phys_ptr_cast(L#xl, ^b_node), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node)) == $rd_inv(_dryad_S0#0, b_node.prio, $phys_ptr_cast(L#xl, ^b_node));
            // assume ==>(!(@_vcc_oset_in(x, old(_dryad_S0#0, treap_reach(xl)))), @_vcc_ptr_eq_pure(*((x->left)), old(_dryad_S0#0, *((x->left))))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S0#0, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_oset_in(x, old(_dryad_S0#0, treap_reach(xl)))), @_vcc_ptr_eq_pure(*((x->right)), old(_dryad_S0#0, *((x->right))))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S0#0, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_oset_in(x, old(_dryad_S0#0, treap_reach(xl)))), ==(*((x->key)), old(_dryad_S0#0, *((x->key))))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) == $rd_inv(_dryad_S0#0, b_node.key, $phys_ptr_cast(P#x, ^b_node));
            // assume ==>(!(@_vcc_oset_in(x, old(_dryad_S0#0, treap_reach(xl)))), ==(*((x->prio)), old(_dryad_S0#0, *((x->prio))))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S0#0, $phys_ptr_cast(L#xl, ^b_node))) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)) == $rd_inv(_dryad_S0#0, b_node.prio, $phys_ptr_cast(P#x, ^b_node));
            // assume ==>(@_vcc_ptr_neq_null(tmp), &&(@_vcc_mutable(@state, tmp), @writes_check(tmp))); 
            assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> $mutable($s, $phys_ptr_cast(L#tmp, ^b_node)) && $top_writable($s, #wrTime$3^5.3, $phys_ptr_cast(L#tmp, ^b_node));
            // assert @reads_check_normal((tmp->prio)); 
            assert $thread_local($s, $phys_ptr_cast(L#tmp, ^b_node));
            // assert @reads_check_normal((x->prio)); 
            assert $thread_local($s, $phys_ptr_cast(P#x, ^b_node));
            assume true;
            // if (<=(*((tmp->prio)), *((x->prio)))) ...
            if ($rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node)) <= $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)))
            {
              anon2:
                // assume ==>(@_vcc_ptr_neq_null(x1), ==(treap(x1), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x1->left))), treap(*((x1->right)))), unchecked!(@_vcc_oset_in(x1, @_vcc_oset_union(treap_reach(*((x1->left))), treap_reach(*((x1->right))))))), unchecked!(@_vcc_intset_in(*((x1->key)), @_vcc_intset_union(treap_keys(*((x1->left))), treap_keys(*((x1->right))))))), unchecked!(@_vcc_intset_in(*((x1->prio)), @_vcc_intset_union(treap_prios(*((x1->left))), treap_prios(*((x1->right))))))), @_vcc_oset_disjoint(treap_reach(*((x1->left))), treap_reach(*((x1->right))))), @_vcc_intset_disjoint(treap_keys(*((x1->left))), treap_keys(*((x1->right))))), @_vcc_intset_disjoint(treap_prios(*((x1->left))), treap_prios(*((x1->right))))), ==>(@_vcc_ptr_neq_null(*((x1->left))), <(treap_max_key(*((x1->left))), *((x1->key))))), ==>(@_vcc_ptr_neq_null(*((x1->right))), <(*((x1->key)), treap_min_key(*((x1->right)))))), ==>(@_vcc_ptr_neq_null(*((x1->left))), <(treap_max_prio(*((x1->left))), *((x1->prio))))), ==>(@_vcc_ptr_neq_null(*((x1->right))), <(treap_max_prio(*((x1->right))), *((x1->prio))))))); 
                assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> F#treap($s, $phys_ptr_cast(SL#x1, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(SL#x1, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1), ==(treap_reach(x1), @_vcc_oset_union(@_vcc_oset_singleton(x1), @_vcc_oset_union(treap_reach(*((x1->left))), treap_reach(*((x1->right))))))); 
                assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(SL#x1, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(SL#x1, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1), ==(treap_keys(x1), @_vcc_intset_union(@_vcc_intset_singleton(*((x1->key))), @_vcc_intset_union(treap_keys(*((x1->left))), treap_keys(*((x1->right))))))); 
                assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(SL#x1, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x1->left))), @_vcc_ptr_neq_null(*((x1->right)))), ==(treap_max_key(x1), @\int_max(*((x1->key)), @\int_max(treap_max_key(*((x1->left))), treap_max_key(*((x1->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x1->left))), @_vcc_ptr_eq_null(*((x1->right)))), ==(treap_max_key(x1), @\int_max(*((x1->key)), treap_max_key(*((x1->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x1->left))), @_vcc_ptr_neq_null(*((x1->right)))), ==(treap_max_key(x1), @\int_max(*((x1->key)), treap_max_key(*((x1->right)))))))); 
                assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x1->left))), @_vcc_ptr_neq_null(*((x1->right)))), ==(treap_max_prio(x1), @\int_max(*((x1->prio)), @\int_max(treap_max_prio(*((x1->left))), treap_max_prio(*((x1->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x1->left))), @_vcc_ptr_eq_null(*((x1->right)))), ==(treap_max_prio(x1), @\int_max(*((x1->prio)), treap_max_prio(*((x1->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x1->left))), @_vcc_ptr_neq_null(*((x1->right)))), ==(treap_max_prio(x1), @\int_max(*((x1->prio)), treap_max_prio(*((x1->right)))))))); 
                assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x1->left))), @_vcc_ptr_neq_null(*((x1->right)))), ==(treap_min_key(x1), @\int_min(*((x1->key)), @\int_min(treap_min_key(*((x1->left))), treap_min_key(*((x1->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x1->left))), @_vcc_ptr_eq_null(*((x1->right)))), ==(treap_min_key(x1), @\int_min(*((x1->key)), treap_min_key(*((x1->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x1->left))), @_vcc_ptr_neq_null(*((x1->right)))), ==(treap_min_key(x1), @\int_min(*((x1->key)), treap_min_key(*((x1->right)))))))); 
                assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1), ==(treap_prios(x1), @_vcc_intset_union(@_vcc_intset_singleton(*((x1->prio))), @_vcc_intset_union(treap_prios(*((x1->left))), treap_prios(*((x1->right))))))); 
                assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(SL#x1, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0), ==(treap(x0), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x0->left))), treap(*((x0->right)))), unchecked!(@_vcc_oset_in(x0, @_vcc_oset_union(treap_reach(*((x0->left))), treap_reach(*((x0->right))))))), unchecked!(@_vcc_intset_in(*((x0->key)), @_vcc_intset_union(treap_keys(*((x0->left))), treap_keys(*((x0->right))))))), unchecked!(@_vcc_intset_in(*((x0->prio)), @_vcc_intset_union(treap_prios(*((x0->left))), treap_prios(*((x0->right))))))), @_vcc_oset_disjoint(treap_reach(*((x0->left))), treap_reach(*((x0->right))))), @_vcc_intset_disjoint(treap_keys(*((x0->left))), treap_keys(*((x0->right))))), @_vcc_intset_disjoint(treap_prios(*((x0->left))), treap_prios(*((x0->right))))), ==>(@_vcc_ptr_neq_null(*((x0->left))), <(treap_max_key(*((x0->left))), *((x0->key))))), ==>(@_vcc_ptr_neq_null(*((x0->right))), <(*((x0->key)), treap_min_key(*((x0->right)))))), ==>(@_vcc_ptr_neq_null(*((x0->left))), <(treap_max_prio(*((x0->left))), *((x0->prio))))), ==>(@_vcc_ptr_neq_null(*((x0->right))), <(treap_max_prio(*((x0->right))), *((x0->prio))))))); 
                assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> F#treap($s, $phys_ptr_cast(SL#x0, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(SL#x0, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0), ==(treap_reach(x0), @_vcc_oset_union(@_vcc_oset_singleton(x0), @_vcc_oset_union(treap_reach(*((x0->left))), treap_reach(*((x0->right))))))); 
                assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(SL#x0, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(SL#x0, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0), ==(treap_keys(x0), @_vcc_intset_union(@_vcc_intset_singleton(*((x0->key))), @_vcc_intset_union(treap_keys(*((x0->left))), treap_keys(*((x0->right))))))); 
                assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(SL#x0, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x0->left))), @_vcc_ptr_neq_null(*((x0->right)))), ==(treap_max_key(x0), @\int_max(*((x0->key)), @\int_max(treap_max_key(*((x0->left))), treap_max_key(*((x0->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x0->left))), @_vcc_ptr_eq_null(*((x0->right)))), ==(treap_max_key(x0), @\int_max(*((x0->key)), treap_max_key(*((x0->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x0->left))), @_vcc_ptr_neq_null(*((x0->right)))), ==(treap_max_key(x0), @\int_max(*((x0->key)), treap_max_key(*((x0->right)))))))); 
                assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x0->left))), @_vcc_ptr_neq_null(*((x0->right)))), ==(treap_max_prio(x0), @\int_max(*((x0->prio)), @\int_max(treap_max_prio(*((x0->left))), treap_max_prio(*((x0->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x0->left))), @_vcc_ptr_eq_null(*((x0->right)))), ==(treap_max_prio(x0), @\int_max(*((x0->prio)), treap_max_prio(*((x0->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x0->left))), @_vcc_ptr_neq_null(*((x0->right)))), ==(treap_max_prio(x0), @\int_max(*((x0->prio)), treap_max_prio(*((x0->right)))))))); 
                assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x0->left))), @_vcc_ptr_neq_null(*((x0->right)))), ==(treap_min_key(x0), @\int_min(*((x0->key)), @\int_min(treap_min_key(*((x0->left))), treap_min_key(*((x0->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x0->left))), @_vcc_ptr_eq_null(*((x0->right)))), ==(treap_min_key(x0), @\int_min(*((x0->key)), treap_min_key(*((x0->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x0->left))), @_vcc_ptr_neq_null(*((x0->right)))), ==(treap_min_key(x0), @\int_min(*((x0->key)), treap_min_key(*((x0->right)))))))); 
                assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0), ==(treap_prios(x0), @_vcc_intset_union(@_vcc_intset_singleton(*((x0->prio))), @_vcc_intset_union(treap_prios(*((x0->left))), treap_prios(*((x0->right))))))); 
                assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(SL#x0, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr), ==(treap(xr), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((xr->left))), treap(*((xr->right)))), unchecked!(@_vcc_oset_in(xr, @_vcc_oset_union(treap_reach(*((xr->left))), treap_reach(*((xr->right))))))), unchecked!(@_vcc_intset_in(*((xr->key)), @_vcc_intset_union(treap_keys(*((xr->left))), treap_keys(*((xr->right))))))), unchecked!(@_vcc_intset_in(*((xr->prio)), @_vcc_intset_union(treap_prios(*((xr->left))), treap_prios(*((xr->right))))))), @_vcc_oset_disjoint(treap_reach(*((xr->left))), treap_reach(*((xr->right))))), @_vcc_intset_disjoint(treap_keys(*((xr->left))), treap_keys(*((xr->right))))), @_vcc_intset_disjoint(treap_prios(*((xr->left))), treap_prios(*((xr->right))))), ==>(@_vcc_ptr_neq_null(*((xr->left))), <(treap_max_key(*((xr->left))), *((xr->key))))), ==>(@_vcc_ptr_neq_null(*((xr->right))), <(*((xr->key)), treap_min_key(*((xr->right)))))), ==>(@_vcc_ptr_neq_null(*((xr->left))), <(treap_max_prio(*((xr->left))), *((xr->prio))))), ==>(@_vcc_ptr_neq_null(*((xr->right))), <(treap_max_prio(*((xr->right))), *((xr->prio))))))); 
                assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> F#treap($s, $phys_ptr_cast(L#xr, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(L#xr, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr), ==(treap_reach(xr), @_vcc_oset_union(@_vcc_oset_singleton(xr), @_vcc_oset_union(treap_reach(*((xr->left))), treap_reach(*((xr->right))))))); 
                assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(L#xr, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(L#xr, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr), ==(treap_keys(xr), @_vcc_intset_union(@_vcc_intset_singleton(*((xr->key))), @_vcc_intset_union(treap_keys(*((xr->left))), treap_keys(*((xr->right))))))); 
                assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(L#xr, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_max_key(xr), @\int_max(*((xr->key)), @\int_max(treap_max_key(*((xr->left))), treap_max_key(*((xr->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_eq_null(*((xr->right)))), ==(treap_max_key(xr), @\int_max(*((xr->key)), treap_max_key(*((xr->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_max_key(xr), @\int_max(*((xr->key)), treap_max_key(*((xr->right)))))))); 
                assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_max_prio(xr), @\int_max(*((xr->prio)), @\int_max(treap_max_prio(*((xr->left))), treap_max_prio(*((xr->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_eq_null(*((xr->right)))), ==(treap_max_prio(xr), @\int_max(*((xr->prio)), treap_max_prio(*((xr->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_max_prio(xr), @\int_max(*((xr->prio)), treap_max_prio(*((xr->right)))))))); 
                assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_min_key(xr), @\int_min(*((xr->key)), @\int_min(treap_min_key(*((xr->left))), treap_min_key(*((xr->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_eq_null(*((xr->right)))), ==(treap_min_key(xr), @\int_min(*((xr->key)), treap_min_key(*((xr->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_min_key(xr), @\int_min(*((xr->key)), treap_min_key(*((xr->right)))))))); 
                assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr), ==(treap_prios(xr), @_vcc_intset_union(@_vcc_intset_singleton(*((xr->prio))), @_vcc_intset_union(treap_prios(*((xr->left))), treap_prios(*((xr->right))))))); 
                assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(L#xr, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl), ==(treap(xl), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((xl->left))), treap(*((xl->right)))), unchecked!(@_vcc_oset_in(xl, @_vcc_oset_union(treap_reach(*((xl->left))), treap_reach(*((xl->right))))))), unchecked!(@_vcc_intset_in(*((xl->key)), @_vcc_intset_union(treap_keys(*((xl->left))), treap_keys(*((xl->right))))))), unchecked!(@_vcc_intset_in(*((xl->prio)), @_vcc_intset_union(treap_prios(*((xl->left))), treap_prios(*((xl->right))))))), @_vcc_oset_disjoint(treap_reach(*((xl->left))), treap_reach(*((xl->right))))), @_vcc_intset_disjoint(treap_keys(*((xl->left))), treap_keys(*((xl->right))))), @_vcc_intset_disjoint(treap_prios(*((xl->left))), treap_prios(*((xl->right))))), ==>(@_vcc_ptr_neq_null(*((xl->left))), <(treap_max_key(*((xl->left))), *((xl->key))))), ==>(@_vcc_ptr_neq_null(*((xl->right))), <(*((xl->key)), treap_min_key(*((xl->right)))))), ==>(@_vcc_ptr_neq_null(*((xl->left))), <(treap_max_prio(*((xl->left))), *((xl->prio))))), ==>(@_vcc_ptr_neq_null(*((xl->right))), <(treap_max_prio(*((xl->right))), *((xl->prio))))))); 
                assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> F#treap($s, $phys_ptr_cast(L#xl, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(L#xl, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl), ==(treap_reach(xl), @_vcc_oset_union(@_vcc_oset_singleton(xl), @_vcc_oset_union(treap_reach(*((xl->left))), treap_reach(*((xl->right))))))); 
                assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(L#xl, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(L#xl, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl), ==(treap_keys(xl), @_vcc_intset_union(@_vcc_intset_singleton(*((xl->key))), @_vcc_intset_union(treap_keys(*((xl->left))), treap_keys(*((xl->right))))))); 
                assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(L#xl, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_max_key(xl), @\int_max(*((xl->key)), @\int_max(treap_max_key(*((xl->left))), treap_max_key(*((xl->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_eq_null(*((xl->right)))), ==(treap_max_key(xl), @\int_max(*((xl->key)), treap_max_key(*((xl->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_max_key(xl), @\int_max(*((xl->key)), treap_max_key(*((xl->right)))))))); 
                assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_max_prio(xl), @\int_max(*((xl->prio)), @\int_max(treap_max_prio(*((xl->left))), treap_max_prio(*((xl->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_eq_null(*((xl->right)))), ==(treap_max_prio(xl), @\int_max(*((xl->prio)), treap_max_prio(*((xl->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_max_prio(xl), @\int_max(*((xl->prio)), treap_max_prio(*((xl->right)))))))); 
                assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_min_key(xl), @\int_min(*((xl->key)), @\int_min(treap_min_key(*((xl->left))), treap_min_key(*((xl->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_eq_null(*((xl->right)))), ==(treap_min_key(xl), @\int_min(*((xl->key)), treap_min_key(*((xl->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_min_key(xl), @\int_min(*((xl->key)), treap_min_key(*((xl->right)))))))); 
                assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl), ==(treap_prios(xl), @_vcc_intset_union(@_vcc_intset_singleton(*((xl->prio))), @_vcc_intset_union(treap_prios(*((xl->left))), treap_prios(*((xl->right))))))); 
                assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(L#xl, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), ==(treap(tmp), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((tmp->left))), treap(*((tmp->right)))), unchecked!(@_vcc_oset_in(tmp, @_vcc_oset_union(treap_reach(*((tmp->left))), treap_reach(*((tmp->right))))))), unchecked!(@_vcc_intset_in(*((tmp->key)), @_vcc_intset_union(treap_keys(*((tmp->left))), treap_keys(*((tmp->right))))))), unchecked!(@_vcc_intset_in(*((tmp->prio)), @_vcc_intset_union(treap_prios(*((tmp->left))), treap_prios(*((tmp->right))))))), @_vcc_oset_disjoint(treap_reach(*((tmp->left))), treap_reach(*((tmp->right))))), @_vcc_intset_disjoint(treap_keys(*((tmp->left))), treap_keys(*((tmp->right))))), @_vcc_intset_disjoint(treap_prios(*((tmp->left))), treap_prios(*((tmp->right))))), ==>(@_vcc_ptr_neq_null(*((tmp->left))), <(treap_max_key(*((tmp->left))), *((tmp->key))))), ==>(@_vcc_ptr_neq_null(*((tmp->right))), <(*((tmp->key)), treap_min_key(*((tmp->right)))))), ==>(@_vcc_ptr_neq_null(*((tmp->left))), <(treap_max_prio(*((tmp->left))), *((tmp->prio))))), ==>(@_vcc_ptr_neq_null(*((tmp->right))), <(treap_max_prio(*((tmp->right))), *((tmp->prio))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> F#treap($s, $phys_ptr_cast(L#tmp, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(L#tmp, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), ==(treap_reach(tmp), @_vcc_oset_union(@_vcc_oset_singleton(tmp), @_vcc_oset_union(treap_reach(*((tmp->left))), treap_reach(*((tmp->right))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(L#tmp, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(L#tmp, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), ==(treap_keys(tmp), @_vcc_intset_union(@_vcc_intset_singleton(*((tmp->key))), @_vcc_intset_union(treap_keys(*((tmp->left))), treap_keys(*((tmp->right))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(L#tmp, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_max_key(tmp), @\int_max(*((tmp->key)), @\int_max(treap_max_key(*((tmp->left))), treap_max_key(*((tmp->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_eq_null(*((tmp->right)))), ==(treap_max_key(tmp), @\int_max(*((tmp->key)), treap_max_key(*((tmp->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_max_key(tmp), @\int_max(*((tmp->key)), treap_max_key(*((tmp->right)))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_max_prio(tmp), @\int_max(*((tmp->prio)), @\int_max(treap_max_prio(*((tmp->left))), treap_max_prio(*((tmp->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_eq_null(*((tmp->right)))), ==(treap_max_prio(tmp), @\int_max(*((tmp->prio)), treap_max_prio(*((tmp->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_max_prio(tmp), @\int_max(*((tmp->prio)), treap_max_prio(*((tmp->right)))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_min_key(tmp), @\int_min(*((tmp->key)), @\int_min(treap_min_key(*((tmp->left))), treap_min_key(*((tmp->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_eq_null(*((tmp->right)))), ==(treap_min_key(tmp), @\int_min(*((tmp->key)), treap_min_key(*((tmp->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_min_key(tmp), @\int_min(*((tmp->key)), treap_min_key(*((tmp->right)))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), ==(treap_prios(tmp), @_vcc_intset_union(@_vcc_intset_singleton(*((tmp->prio))), @_vcc_intset_union(treap_prios(*((tmp->left))), treap_prios(*((tmp->right))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(L#tmp, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), ==(treap(x), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x->left))), treap(*((x->right)))), unchecked!(@_vcc_oset_in(x, @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->key)), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->prio)), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))), @_vcc_oset_disjoint(treap_reach(*((x->left))), treap_reach(*((x->right))))), @_vcc_intset_disjoint(treap_keys(*((x->left))), treap_keys(*((x->right))))), @_vcc_intset_disjoint(treap_prios(*((x->left))), treap_prios(*((x->right))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_key(*((x->left))), *((x->key))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(*((x->key)), treap_min_key(*((x->right)))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_prio(*((x->left))), *((x->prio))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(treap_max_prio(*((x->right))), *((x->prio))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap($s, $phys_ptr_cast(P#x, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(P#x, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_reach(x), @_vcc_oset_union(@_vcc_oset_singleton(x), @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(P#x, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(P#x, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_keys(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->key))), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), @\int_max(treap_max_key(*((x->left))), treap_max_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->right)))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), @\int_max(treap_max_prio(*((x->left))), treap_max_prio(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->right)))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), @\int_min(treap_min_key(*((x->left))), treap_min_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->right)))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_prios(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->prio))), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // _math \state _dryad_S2#2; 
                // _dryad_S2#2 := @_vcc_current_state(@state); 
                _dryad_S2#2 := $current_state($s);
                // _math \state stmtexpr0#19; 
                // stmtexpr0#19 := _dryad_S2#2; 
                stmtexpr0#19 := _dryad_S2#2;
                // assert @prim_writes_check((x->left)); 
                assert $writable_prim($s, #wrTime$3^5.3, $dot($phys_ptr_cast(P#x, ^b_node), b_node.left));
                // *(x->left) := tmp; 
                call $write_int(b_node.left, $phys_ptr_cast(P#x, ^b_node), $ptr_to_int($phys_ptr_cast(L#tmp, ^b_node)));
                assume $full_stop_ext(#tok$3^54.9, $s);
                // _math \state _dryad_S3#3; 
                // _dryad_S3#3 := @_vcc_current_state(@state); 
                _dryad_S3#3 := $current_state($s);
                // _math \state stmtexpr1#20; 
                // stmtexpr1#20 := _dryad_S3#3; 
                stmtexpr1#20 := _dryad_S3#3;
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#2, treap_reach(*((x->right)))))), ==(old(_dryad_S2#2, treap(*((x->right)))), old(_dryad_S3#3, treap(*((x->right)))))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#2, $rd_phys_ptr(_dryad_S2#2, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) ==> F#treap(_dryad_S2#2, $rd_phys_ptr(_dryad_S2#2, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) == F#treap(_dryad_S3#3, $rd_phys_ptr(_dryad_S3#3, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#2, treap_reach(*((x->right)))))), ==(old(_dryad_S2#2, treap_reach(*((x->right)))), old(_dryad_S3#3, treap_reach(*((x->right)))))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#2, $rd_phys_ptr(_dryad_S2#2, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) ==> F#treap_reach(_dryad_S2#2, $rd_phys_ptr(_dryad_S2#2, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) == F#treap_reach(_dryad_S3#3, $rd_phys_ptr(_dryad_S3#3, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#2, treap_reach(*((x->right)))))), ==(old(_dryad_S2#2, treap_keys(*((x->right)))), old(_dryad_S3#3, treap_keys(*((x->right)))))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#2, $rd_phys_ptr(_dryad_S2#2, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) ==> F#treap_keys(_dryad_S2#2, $rd_phys_ptr(_dryad_S2#2, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) == F#treap_keys(_dryad_S3#3, $rd_phys_ptr(_dryad_S3#3, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#2, treap_reach(*((x->right)))))), ==(old(_dryad_S2#2, treap_max_key(*((x->right)))), old(_dryad_S3#3, treap_max_key(*((x->right)))))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#2, $rd_phys_ptr(_dryad_S2#2, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) ==> F#treap_max_key(_dryad_S2#2, $rd_phys_ptr(_dryad_S2#2, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) == F#treap_max_key(_dryad_S3#3, $rd_phys_ptr(_dryad_S3#3, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#2, treap_reach(*((x->right)))))), ==(old(_dryad_S2#2, treap_max_prio(*((x->right)))), old(_dryad_S3#3, treap_max_prio(*((x->right)))))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#2, $rd_phys_ptr(_dryad_S2#2, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) ==> F#treap_max_prio(_dryad_S2#2, $rd_phys_ptr(_dryad_S2#2, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) == F#treap_max_prio(_dryad_S3#3, $rd_phys_ptr(_dryad_S3#3, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#2, treap_reach(*((x->right)))))), ==(old(_dryad_S2#2, treap_min_key(*((x->right)))), old(_dryad_S3#3, treap_min_key(*((x->right)))))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#2, $rd_phys_ptr(_dryad_S2#2, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) ==> F#treap_min_key(_dryad_S2#2, $rd_phys_ptr(_dryad_S2#2, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) == F#treap_min_key(_dryad_S3#3, $rd_phys_ptr(_dryad_S3#3, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#2, treap_reach(*((x->right)))))), ==(old(_dryad_S2#2, treap_prios(*((x->right)))), old(_dryad_S3#3, treap_prios(*((x->right)))))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#2, $rd_phys_ptr(_dryad_S2#2, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) ==> F#treap_prios(_dryad_S2#2, $rd_phys_ptr(_dryad_S2#2, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) == F#treap_prios(_dryad_S3#3, $rd_phys_ptr(_dryad_S3#3, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#2, treap_reach(x1)))), ==(old(_dryad_S2#2, treap(x1)), old(_dryad_S3#3, treap(x1)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#2, $phys_ptr_cast(SL#x1, ^b_node))) ==> F#treap(_dryad_S2#2, $phys_ptr_cast(SL#x1, ^b_node)) == F#treap(_dryad_S3#3, $phys_ptr_cast(SL#x1, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#2, treap_reach(x1)))), ==(old(_dryad_S2#2, treap_reach(x1)), old(_dryad_S3#3, treap_reach(x1)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#2, $phys_ptr_cast(SL#x1, ^b_node))) ==> F#treap_reach(_dryad_S2#2, $phys_ptr_cast(SL#x1, ^b_node)) == F#treap_reach(_dryad_S3#3, $phys_ptr_cast(SL#x1, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#2, treap_reach(x1)))), ==(old(_dryad_S2#2, treap_keys(x1)), old(_dryad_S3#3, treap_keys(x1)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#2, $phys_ptr_cast(SL#x1, ^b_node))) ==> F#treap_keys(_dryad_S2#2, $phys_ptr_cast(SL#x1, ^b_node)) == F#treap_keys(_dryad_S3#3, $phys_ptr_cast(SL#x1, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#2, treap_reach(x1)))), ==(old(_dryad_S2#2, treap_max_key(x1)), old(_dryad_S3#3, treap_max_key(x1)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#2, $phys_ptr_cast(SL#x1, ^b_node))) ==> F#treap_max_key(_dryad_S2#2, $phys_ptr_cast(SL#x1, ^b_node)) == F#treap_max_key(_dryad_S3#3, $phys_ptr_cast(SL#x1, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#2, treap_reach(x1)))), ==(old(_dryad_S2#2, treap_max_prio(x1)), old(_dryad_S3#3, treap_max_prio(x1)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#2, $phys_ptr_cast(SL#x1, ^b_node))) ==> F#treap_max_prio(_dryad_S2#2, $phys_ptr_cast(SL#x1, ^b_node)) == F#treap_max_prio(_dryad_S3#3, $phys_ptr_cast(SL#x1, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#2, treap_reach(x1)))), ==(old(_dryad_S2#2, treap_min_key(x1)), old(_dryad_S3#3, treap_min_key(x1)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#2, $phys_ptr_cast(SL#x1, ^b_node))) ==> F#treap_min_key(_dryad_S2#2, $phys_ptr_cast(SL#x1, ^b_node)) == F#treap_min_key(_dryad_S3#3, $phys_ptr_cast(SL#x1, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#2, treap_reach(x1)))), ==(old(_dryad_S2#2, treap_prios(x1)), old(_dryad_S3#3, treap_prios(x1)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#2, $phys_ptr_cast(SL#x1, ^b_node))) ==> F#treap_prios(_dryad_S2#2, $phys_ptr_cast(SL#x1, ^b_node)) == F#treap_prios(_dryad_S3#3, $phys_ptr_cast(SL#x1, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#2, treap_reach(x0)))), ==(old(_dryad_S2#2, treap(x0)), old(_dryad_S3#3, treap(x0)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#2, $phys_ptr_cast(SL#x0, ^b_node))) ==> F#treap(_dryad_S2#2, $phys_ptr_cast(SL#x0, ^b_node)) == F#treap(_dryad_S3#3, $phys_ptr_cast(SL#x0, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#2, treap_reach(x0)))), ==(old(_dryad_S2#2, treap_reach(x0)), old(_dryad_S3#3, treap_reach(x0)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#2, $phys_ptr_cast(SL#x0, ^b_node))) ==> F#treap_reach(_dryad_S2#2, $phys_ptr_cast(SL#x0, ^b_node)) == F#treap_reach(_dryad_S3#3, $phys_ptr_cast(SL#x0, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#2, treap_reach(x0)))), ==(old(_dryad_S2#2, treap_keys(x0)), old(_dryad_S3#3, treap_keys(x0)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#2, $phys_ptr_cast(SL#x0, ^b_node))) ==> F#treap_keys(_dryad_S2#2, $phys_ptr_cast(SL#x0, ^b_node)) == F#treap_keys(_dryad_S3#3, $phys_ptr_cast(SL#x0, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#2, treap_reach(x0)))), ==(old(_dryad_S2#2, treap_max_key(x0)), old(_dryad_S3#3, treap_max_key(x0)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#2, $phys_ptr_cast(SL#x0, ^b_node))) ==> F#treap_max_key(_dryad_S2#2, $phys_ptr_cast(SL#x0, ^b_node)) == F#treap_max_key(_dryad_S3#3, $phys_ptr_cast(SL#x0, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#2, treap_reach(x0)))), ==(old(_dryad_S2#2, treap_max_prio(x0)), old(_dryad_S3#3, treap_max_prio(x0)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#2, $phys_ptr_cast(SL#x0, ^b_node))) ==> F#treap_max_prio(_dryad_S2#2, $phys_ptr_cast(SL#x0, ^b_node)) == F#treap_max_prio(_dryad_S3#3, $phys_ptr_cast(SL#x0, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#2, treap_reach(x0)))), ==(old(_dryad_S2#2, treap_min_key(x0)), old(_dryad_S3#3, treap_min_key(x0)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#2, $phys_ptr_cast(SL#x0, ^b_node))) ==> F#treap_min_key(_dryad_S2#2, $phys_ptr_cast(SL#x0, ^b_node)) == F#treap_min_key(_dryad_S3#3, $phys_ptr_cast(SL#x0, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#2, treap_reach(x0)))), ==(old(_dryad_S2#2, treap_prios(x0)), old(_dryad_S3#3, treap_prios(x0)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#2, $phys_ptr_cast(SL#x0, ^b_node))) ==> F#treap_prios(_dryad_S2#2, $phys_ptr_cast(SL#x0, ^b_node)) == F#treap_prios(_dryad_S3#3, $phys_ptr_cast(SL#x0, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#2, treap_reach(xr)))), ==(old(_dryad_S2#2, treap(xr)), old(_dryad_S3#3, treap(xr)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#2, $phys_ptr_cast(L#xr, ^b_node))) ==> F#treap(_dryad_S2#2, $phys_ptr_cast(L#xr, ^b_node)) == F#treap(_dryad_S3#3, $phys_ptr_cast(L#xr, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#2, treap_reach(xr)))), ==(old(_dryad_S2#2, treap_reach(xr)), old(_dryad_S3#3, treap_reach(xr)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#2, $phys_ptr_cast(L#xr, ^b_node))) ==> F#treap_reach(_dryad_S2#2, $phys_ptr_cast(L#xr, ^b_node)) == F#treap_reach(_dryad_S3#3, $phys_ptr_cast(L#xr, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#2, treap_reach(xr)))), ==(old(_dryad_S2#2, treap_keys(xr)), old(_dryad_S3#3, treap_keys(xr)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#2, $phys_ptr_cast(L#xr, ^b_node))) ==> F#treap_keys(_dryad_S2#2, $phys_ptr_cast(L#xr, ^b_node)) == F#treap_keys(_dryad_S3#3, $phys_ptr_cast(L#xr, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#2, treap_reach(xr)))), ==(old(_dryad_S2#2, treap_max_key(xr)), old(_dryad_S3#3, treap_max_key(xr)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#2, $phys_ptr_cast(L#xr, ^b_node))) ==> F#treap_max_key(_dryad_S2#2, $phys_ptr_cast(L#xr, ^b_node)) == F#treap_max_key(_dryad_S3#3, $phys_ptr_cast(L#xr, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#2, treap_reach(xr)))), ==(old(_dryad_S2#2, treap_max_prio(xr)), old(_dryad_S3#3, treap_max_prio(xr)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#2, $phys_ptr_cast(L#xr, ^b_node))) ==> F#treap_max_prio(_dryad_S2#2, $phys_ptr_cast(L#xr, ^b_node)) == F#treap_max_prio(_dryad_S3#3, $phys_ptr_cast(L#xr, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#2, treap_reach(xr)))), ==(old(_dryad_S2#2, treap_min_key(xr)), old(_dryad_S3#3, treap_min_key(xr)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#2, $phys_ptr_cast(L#xr, ^b_node))) ==> F#treap_min_key(_dryad_S2#2, $phys_ptr_cast(L#xr, ^b_node)) == F#treap_min_key(_dryad_S3#3, $phys_ptr_cast(L#xr, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#2, treap_reach(xr)))), ==(old(_dryad_S2#2, treap_prios(xr)), old(_dryad_S3#3, treap_prios(xr)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#2, $phys_ptr_cast(L#xr, ^b_node))) ==> F#treap_prios(_dryad_S2#2, $phys_ptr_cast(L#xr, ^b_node)) == F#treap_prios(_dryad_S3#3, $phys_ptr_cast(L#xr, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#2, treap_reach(xl)))), ==(old(_dryad_S2#2, treap(xl)), old(_dryad_S3#3, treap(xl)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#2, $phys_ptr_cast(L#xl, ^b_node))) ==> F#treap(_dryad_S2#2, $phys_ptr_cast(L#xl, ^b_node)) == F#treap(_dryad_S3#3, $phys_ptr_cast(L#xl, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#2, treap_reach(xl)))), ==(old(_dryad_S2#2, treap_reach(xl)), old(_dryad_S3#3, treap_reach(xl)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#2, $phys_ptr_cast(L#xl, ^b_node))) ==> F#treap_reach(_dryad_S2#2, $phys_ptr_cast(L#xl, ^b_node)) == F#treap_reach(_dryad_S3#3, $phys_ptr_cast(L#xl, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#2, treap_reach(xl)))), ==(old(_dryad_S2#2, treap_keys(xl)), old(_dryad_S3#3, treap_keys(xl)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#2, $phys_ptr_cast(L#xl, ^b_node))) ==> F#treap_keys(_dryad_S2#2, $phys_ptr_cast(L#xl, ^b_node)) == F#treap_keys(_dryad_S3#3, $phys_ptr_cast(L#xl, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#2, treap_reach(xl)))), ==(old(_dryad_S2#2, treap_max_key(xl)), old(_dryad_S3#3, treap_max_key(xl)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#2, $phys_ptr_cast(L#xl, ^b_node))) ==> F#treap_max_key(_dryad_S2#2, $phys_ptr_cast(L#xl, ^b_node)) == F#treap_max_key(_dryad_S3#3, $phys_ptr_cast(L#xl, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#2, treap_reach(xl)))), ==(old(_dryad_S2#2, treap_max_prio(xl)), old(_dryad_S3#3, treap_max_prio(xl)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#2, $phys_ptr_cast(L#xl, ^b_node))) ==> F#treap_max_prio(_dryad_S2#2, $phys_ptr_cast(L#xl, ^b_node)) == F#treap_max_prio(_dryad_S3#3, $phys_ptr_cast(L#xl, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#2, treap_reach(xl)))), ==(old(_dryad_S2#2, treap_min_key(xl)), old(_dryad_S3#3, treap_min_key(xl)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#2, $phys_ptr_cast(L#xl, ^b_node))) ==> F#treap_min_key(_dryad_S2#2, $phys_ptr_cast(L#xl, ^b_node)) == F#treap_min_key(_dryad_S3#3, $phys_ptr_cast(L#xl, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#2, treap_reach(xl)))), ==(old(_dryad_S2#2, treap_prios(xl)), old(_dryad_S3#3, treap_prios(xl)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#2, $phys_ptr_cast(L#xl, ^b_node))) ==> F#treap_prios(_dryad_S2#2, $phys_ptr_cast(L#xl, ^b_node)) == F#treap_prios(_dryad_S3#3, $phys_ptr_cast(L#xl, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#2, treap_reach(tmp)))), ==(old(_dryad_S2#2, treap(tmp)), old(_dryad_S3#3, treap(tmp)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#2, $phys_ptr_cast(L#tmp, ^b_node))) ==> F#treap(_dryad_S2#2, $phys_ptr_cast(L#tmp, ^b_node)) == F#treap(_dryad_S3#3, $phys_ptr_cast(L#tmp, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#2, treap_reach(tmp)))), ==(old(_dryad_S2#2, treap_reach(tmp)), old(_dryad_S3#3, treap_reach(tmp)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#2, $phys_ptr_cast(L#tmp, ^b_node))) ==> F#treap_reach(_dryad_S2#2, $phys_ptr_cast(L#tmp, ^b_node)) == F#treap_reach(_dryad_S3#3, $phys_ptr_cast(L#tmp, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#2, treap_reach(tmp)))), ==(old(_dryad_S2#2, treap_keys(tmp)), old(_dryad_S3#3, treap_keys(tmp)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#2, $phys_ptr_cast(L#tmp, ^b_node))) ==> F#treap_keys(_dryad_S2#2, $phys_ptr_cast(L#tmp, ^b_node)) == F#treap_keys(_dryad_S3#3, $phys_ptr_cast(L#tmp, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#2, treap_reach(tmp)))), ==(old(_dryad_S2#2, treap_max_key(tmp)), old(_dryad_S3#3, treap_max_key(tmp)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#2, $phys_ptr_cast(L#tmp, ^b_node))) ==> F#treap_max_key(_dryad_S2#2, $phys_ptr_cast(L#tmp, ^b_node)) == F#treap_max_key(_dryad_S3#3, $phys_ptr_cast(L#tmp, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#2, treap_reach(tmp)))), ==(old(_dryad_S2#2, treap_max_prio(tmp)), old(_dryad_S3#3, treap_max_prio(tmp)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#2, $phys_ptr_cast(L#tmp, ^b_node))) ==> F#treap_max_prio(_dryad_S2#2, $phys_ptr_cast(L#tmp, ^b_node)) == F#treap_max_prio(_dryad_S3#3, $phys_ptr_cast(L#tmp, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#2, treap_reach(tmp)))), ==(old(_dryad_S2#2, treap_min_key(tmp)), old(_dryad_S3#3, treap_min_key(tmp)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#2, $phys_ptr_cast(L#tmp, ^b_node))) ==> F#treap_min_key(_dryad_S2#2, $phys_ptr_cast(L#tmp, ^b_node)) == F#treap_min_key(_dryad_S3#3, $phys_ptr_cast(L#tmp, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#2, treap_reach(tmp)))), ==(old(_dryad_S2#2, treap_prios(tmp)), old(_dryad_S3#3, treap_prios(tmp)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#2, $phys_ptr_cast(L#tmp, ^b_node))) ==> F#treap_prios(_dryad_S2#2, $phys_ptr_cast(L#tmp, ^b_node)) == F#treap_prios(_dryad_S3#3, $phys_ptr_cast(L#tmp, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(x, x1)), @_vcc_ptr_eq_pure(*((x1->left)), old(_dryad_S2#2, *((x1->left))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(SL#x1, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#2, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(x, x1)), @_vcc_ptr_eq_pure(*((x1->right)), old(_dryad_S2#2, *((x1->right))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(SL#x1, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#2, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(x, x1)), ==(*((x1->key)), old(_dryad_S2#2, *((x1->key))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(SL#x1, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)) == $rd_inv(_dryad_S2#2, b_node.key, $phys_ptr_cast(SL#x1, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(x, x1)), ==(*((x1->prio)), old(_dryad_S2#2, *((x1->prio))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(SL#x1, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node)) == $rd_inv(_dryad_S2#2, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(x, x0)), @_vcc_ptr_eq_pure(*((x0->left)), old(_dryad_S2#2, *((x0->left))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(SL#x0, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#2, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(x, x0)), @_vcc_ptr_eq_pure(*((x0->right)), old(_dryad_S2#2, *((x0->right))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(SL#x0, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#2, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(x, x0)), ==(*((x0->key)), old(_dryad_S2#2, *((x0->key))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(SL#x0, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)) == $rd_inv(_dryad_S2#2, b_node.key, $phys_ptr_cast(SL#x0, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(x, x0)), ==(*((x0->prio)), old(_dryad_S2#2, *((x0->prio))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(SL#x0, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node)) == $rd_inv(_dryad_S2#2, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(x, xr)), @_vcc_ptr_eq_pure(*((xr->left)), old(_dryad_S2#2, *((xr->left))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(L#xr, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#2, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(x, xr)), @_vcc_ptr_eq_pure(*((xr->right)), old(_dryad_S2#2, *((xr->right))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(L#xr, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#2, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(x, xr)), ==(*((xr->key)), old(_dryad_S2#2, *((xr->key))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(L#xr, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)) == $rd_inv(_dryad_S2#2, b_node.key, $phys_ptr_cast(L#xr, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(x, xr)), ==(*((xr->prio)), old(_dryad_S2#2, *((xr->prio))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(L#xr, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node)) == $rd_inv(_dryad_S2#2, b_node.prio, $phys_ptr_cast(L#xr, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(x, xl)), @_vcc_ptr_eq_pure(*((xl->left)), old(_dryad_S2#2, *((xl->left))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(L#xl, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#2, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(x, xl)), @_vcc_ptr_eq_pure(*((xl->right)), old(_dryad_S2#2, *((xl->right))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(L#xl, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#2, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(x, xl)), ==(*((xl->key)), old(_dryad_S2#2, *((xl->key))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(L#xl, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)) == $rd_inv(_dryad_S2#2, b_node.key, $phys_ptr_cast(L#xl, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(x, xl)), ==(*((xl->prio)), old(_dryad_S2#2, *((xl->prio))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(L#xl, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node)) == $rd_inv(_dryad_S2#2, b_node.prio, $phys_ptr_cast(L#xl, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(x, tmp)), @_vcc_ptr_eq_pure(*((tmp->left)), old(_dryad_S2#2, *((tmp->left))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(L#tmp, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#2, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(x, tmp)), @_vcc_ptr_eq_pure(*((tmp->right)), old(_dryad_S2#2, *((tmp->right))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(L#tmp, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#2, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(x, tmp)), ==(*((tmp->key)), old(_dryad_S2#2, *((tmp->key))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(L#tmp, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)) == $rd_inv(_dryad_S2#2, b_node.key, $phys_ptr_cast(L#tmp, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(x, tmp)), ==(*((tmp->prio)), old(_dryad_S2#2, *((tmp->prio))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(L#tmp, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node)) == $rd_inv(_dryad_S2#2, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node));
                // assume ==>(@_vcc_ptr_neq_null(x1), ==(treap(x1), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x1->left))), treap(*((x1->right)))), unchecked!(@_vcc_oset_in(x1, @_vcc_oset_union(treap_reach(*((x1->left))), treap_reach(*((x1->right))))))), unchecked!(@_vcc_intset_in(*((x1->key)), @_vcc_intset_union(treap_keys(*((x1->left))), treap_keys(*((x1->right))))))), unchecked!(@_vcc_intset_in(*((x1->prio)), @_vcc_intset_union(treap_prios(*((x1->left))), treap_prios(*((x1->right))))))), @_vcc_oset_disjoint(treap_reach(*((x1->left))), treap_reach(*((x1->right))))), @_vcc_intset_disjoint(treap_keys(*((x1->left))), treap_keys(*((x1->right))))), @_vcc_intset_disjoint(treap_prios(*((x1->left))), treap_prios(*((x1->right))))), ==>(@_vcc_ptr_neq_null(*((x1->left))), <(treap_max_key(*((x1->left))), *((x1->key))))), ==>(@_vcc_ptr_neq_null(*((x1->right))), <(*((x1->key)), treap_min_key(*((x1->right)))))), ==>(@_vcc_ptr_neq_null(*((x1->left))), <(treap_max_prio(*((x1->left))), *((x1->prio))))), ==>(@_vcc_ptr_neq_null(*((x1->right))), <(treap_max_prio(*((x1->right))), *((x1->prio))))))); 
                assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> F#treap($s, $phys_ptr_cast(SL#x1, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(SL#x1, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1), ==(treap_reach(x1), @_vcc_oset_union(@_vcc_oset_singleton(x1), @_vcc_oset_union(treap_reach(*((x1->left))), treap_reach(*((x1->right))))))); 
                assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(SL#x1, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(SL#x1, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1), ==(treap_keys(x1), @_vcc_intset_union(@_vcc_intset_singleton(*((x1->key))), @_vcc_intset_union(treap_keys(*((x1->left))), treap_keys(*((x1->right))))))); 
                assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(SL#x1, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x1->left))), @_vcc_ptr_neq_null(*((x1->right)))), ==(treap_max_key(x1), @\int_max(*((x1->key)), @\int_max(treap_max_key(*((x1->left))), treap_max_key(*((x1->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x1->left))), @_vcc_ptr_eq_null(*((x1->right)))), ==(treap_max_key(x1), @\int_max(*((x1->key)), treap_max_key(*((x1->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x1->left))), @_vcc_ptr_neq_null(*((x1->right)))), ==(treap_max_key(x1), @\int_max(*((x1->key)), treap_max_key(*((x1->right)))))))); 
                assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x1->left))), @_vcc_ptr_neq_null(*((x1->right)))), ==(treap_max_prio(x1), @\int_max(*((x1->prio)), @\int_max(treap_max_prio(*((x1->left))), treap_max_prio(*((x1->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x1->left))), @_vcc_ptr_eq_null(*((x1->right)))), ==(treap_max_prio(x1), @\int_max(*((x1->prio)), treap_max_prio(*((x1->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x1->left))), @_vcc_ptr_neq_null(*((x1->right)))), ==(treap_max_prio(x1), @\int_max(*((x1->prio)), treap_max_prio(*((x1->right)))))))); 
                assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x1->left))), @_vcc_ptr_neq_null(*((x1->right)))), ==(treap_min_key(x1), @\int_min(*((x1->key)), @\int_min(treap_min_key(*((x1->left))), treap_min_key(*((x1->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x1->left))), @_vcc_ptr_eq_null(*((x1->right)))), ==(treap_min_key(x1), @\int_min(*((x1->key)), treap_min_key(*((x1->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x1->left))), @_vcc_ptr_neq_null(*((x1->right)))), ==(treap_min_key(x1), @\int_min(*((x1->key)), treap_min_key(*((x1->right)))))))); 
                assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1), ==(treap_prios(x1), @_vcc_intset_union(@_vcc_intset_singleton(*((x1->prio))), @_vcc_intset_union(treap_prios(*((x1->left))), treap_prios(*((x1->right))))))); 
                assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(SL#x1, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0), ==(treap(x0), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x0->left))), treap(*((x0->right)))), unchecked!(@_vcc_oset_in(x0, @_vcc_oset_union(treap_reach(*((x0->left))), treap_reach(*((x0->right))))))), unchecked!(@_vcc_intset_in(*((x0->key)), @_vcc_intset_union(treap_keys(*((x0->left))), treap_keys(*((x0->right))))))), unchecked!(@_vcc_intset_in(*((x0->prio)), @_vcc_intset_union(treap_prios(*((x0->left))), treap_prios(*((x0->right))))))), @_vcc_oset_disjoint(treap_reach(*((x0->left))), treap_reach(*((x0->right))))), @_vcc_intset_disjoint(treap_keys(*((x0->left))), treap_keys(*((x0->right))))), @_vcc_intset_disjoint(treap_prios(*((x0->left))), treap_prios(*((x0->right))))), ==>(@_vcc_ptr_neq_null(*((x0->left))), <(treap_max_key(*((x0->left))), *((x0->key))))), ==>(@_vcc_ptr_neq_null(*((x0->right))), <(*((x0->key)), treap_min_key(*((x0->right)))))), ==>(@_vcc_ptr_neq_null(*((x0->left))), <(treap_max_prio(*((x0->left))), *((x0->prio))))), ==>(@_vcc_ptr_neq_null(*((x0->right))), <(treap_max_prio(*((x0->right))), *((x0->prio))))))); 
                assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> F#treap($s, $phys_ptr_cast(SL#x0, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(SL#x0, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0), ==(treap_reach(x0), @_vcc_oset_union(@_vcc_oset_singleton(x0), @_vcc_oset_union(treap_reach(*((x0->left))), treap_reach(*((x0->right))))))); 
                assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(SL#x0, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(SL#x0, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0), ==(treap_keys(x0), @_vcc_intset_union(@_vcc_intset_singleton(*((x0->key))), @_vcc_intset_union(treap_keys(*((x0->left))), treap_keys(*((x0->right))))))); 
                assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(SL#x0, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x0->left))), @_vcc_ptr_neq_null(*((x0->right)))), ==(treap_max_key(x0), @\int_max(*((x0->key)), @\int_max(treap_max_key(*((x0->left))), treap_max_key(*((x0->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x0->left))), @_vcc_ptr_eq_null(*((x0->right)))), ==(treap_max_key(x0), @\int_max(*((x0->key)), treap_max_key(*((x0->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x0->left))), @_vcc_ptr_neq_null(*((x0->right)))), ==(treap_max_key(x0), @\int_max(*((x0->key)), treap_max_key(*((x0->right)))))))); 
                assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x0->left))), @_vcc_ptr_neq_null(*((x0->right)))), ==(treap_max_prio(x0), @\int_max(*((x0->prio)), @\int_max(treap_max_prio(*((x0->left))), treap_max_prio(*((x0->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x0->left))), @_vcc_ptr_eq_null(*((x0->right)))), ==(treap_max_prio(x0), @\int_max(*((x0->prio)), treap_max_prio(*((x0->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x0->left))), @_vcc_ptr_neq_null(*((x0->right)))), ==(treap_max_prio(x0), @\int_max(*((x0->prio)), treap_max_prio(*((x0->right)))))))); 
                assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x0->left))), @_vcc_ptr_neq_null(*((x0->right)))), ==(treap_min_key(x0), @\int_min(*((x0->key)), @\int_min(treap_min_key(*((x0->left))), treap_min_key(*((x0->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x0->left))), @_vcc_ptr_eq_null(*((x0->right)))), ==(treap_min_key(x0), @\int_min(*((x0->key)), treap_min_key(*((x0->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x0->left))), @_vcc_ptr_neq_null(*((x0->right)))), ==(treap_min_key(x0), @\int_min(*((x0->key)), treap_min_key(*((x0->right)))))))); 
                assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0), ==(treap_prios(x0), @_vcc_intset_union(@_vcc_intset_singleton(*((x0->prio))), @_vcc_intset_union(treap_prios(*((x0->left))), treap_prios(*((x0->right))))))); 
                assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(SL#x0, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr), ==(treap(xr), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((xr->left))), treap(*((xr->right)))), unchecked!(@_vcc_oset_in(xr, @_vcc_oset_union(treap_reach(*((xr->left))), treap_reach(*((xr->right))))))), unchecked!(@_vcc_intset_in(*((xr->key)), @_vcc_intset_union(treap_keys(*((xr->left))), treap_keys(*((xr->right))))))), unchecked!(@_vcc_intset_in(*((xr->prio)), @_vcc_intset_union(treap_prios(*((xr->left))), treap_prios(*((xr->right))))))), @_vcc_oset_disjoint(treap_reach(*((xr->left))), treap_reach(*((xr->right))))), @_vcc_intset_disjoint(treap_keys(*((xr->left))), treap_keys(*((xr->right))))), @_vcc_intset_disjoint(treap_prios(*((xr->left))), treap_prios(*((xr->right))))), ==>(@_vcc_ptr_neq_null(*((xr->left))), <(treap_max_key(*((xr->left))), *((xr->key))))), ==>(@_vcc_ptr_neq_null(*((xr->right))), <(*((xr->key)), treap_min_key(*((xr->right)))))), ==>(@_vcc_ptr_neq_null(*((xr->left))), <(treap_max_prio(*((xr->left))), *((xr->prio))))), ==>(@_vcc_ptr_neq_null(*((xr->right))), <(treap_max_prio(*((xr->right))), *((xr->prio))))))); 
                assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> F#treap($s, $phys_ptr_cast(L#xr, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(L#xr, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr), ==(treap_reach(xr), @_vcc_oset_union(@_vcc_oset_singleton(xr), @_vcc_oset_union(treap_reach(*((xr->left))), treap_reach(*((xr->right))))))); 
                assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(L#xr, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(L#xr, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr), ==(treap_keys(xr), @_vcc_intset_union(@_vcc_intset_singleton(*((xr->key))), @_vcc_intset_union(treap_keys(*((xr->left))), treap_keys(*((xr->right))))))); 
                assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(L#xr, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_max_key(xr), @\int_max(*((xr->key)), @\int_max(treap_max_key(*((xr->left))), treap_max_key(*((xr->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_eq_null(*((xr->right)))), ==(treap_max_key(xr), @\int_max(*((xr->key)), treap_max_key(*((xr->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_max_key(xr), @\int_max(*((xr->key)), treap_max_key(*((xr->right)))))))); 
                assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_max_prio(xr), @\int_max(*((xr->prio)), @\int_max(treap_max_prio(*((xr->left))), treap_max_prio(*((xr->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_eq_null(*((xr->right)))), ==(treap_max_prio(xr), @\int_max(*((xr->prio)), treap_max_prio(*((xr->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_max_prio(xr), @\int_max(*((xr->prio)), treap_max_prio(*((xr->right)))))))); 
                assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_min_key(xr), @\int_min(*((xr->key)), @\int_min(treap_min_key(*((xr->left))), treap_min_key(*((xr->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_eq_null(*((xr->right)))), ==(treap_min_key(xr), @\int_min(*((xr->key)), treap_min_key(*((xr->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_min_key(xr), @\int_min(*((xr->key)), treap_min_key(*((xr->right)))))))); 
                assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr), ==(treap_prios(xr), @_vcc_intset_union(@_vcc_intset_singleton(*((xr->prio))), @_vcc_intset_union(treap_prios(*((xr->left))), treap_prios(*((xr->right))))))); 
                assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(L#xr, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl), ==(treap(xl), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((xl->left))), treap(*((xl->right)))), unchecked!(@_vcc_oset_in(xl, @_vcc_oset_union(treap_reach(*((xl->left))), treap_reach(*((xl->right))))))), unchecked!(@_vcc_intset_in(*((xl->key)), @_vcc_intset_union(treap_keys(*((xl->left))), treap_keys(*((xl->right))))))), unchecked!(@_vcc_intset_in(*((xl->prio)), @_vcc_intset_union(treap_prios(*((xl->left))), treap_prios(*((xl->right))))))), @_vcc_oset_disjoint(treap_reach(*((xl->left))), treap_reach(*((xl->right))))), @_vcc_intset_disjoint(treap_keys(*((xl->left))), treap_keys(*((xl->right))))), @_vcc_intset_disjoint(treap_prios(*((xl->left))), treap_prios(*((xl->right))))), ==>(@_vcc_ptr_neq_null(*((xl->left))), <(treap_max_key(*((xl->left))), *((xl->key))))), ==>(@_vcc_ptr_neq_null(*((xl->right))), <(*((xl->key)), treap_min_key(*((xl->right)))))), ==>(@_vcc_ptr_neq_null(*((xl->left))), <(treap_max_prio(*((xl->left))), *((xl->prio))))), ==>(@_vcc_ptr_neq_null(*((xl->right))), <(treap_max_prio(*((xl->right))), *((xl->prio))))))); 
                assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> F#treap($s, $phys_ptr_cast(L#xl, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(L#xl, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl), ==(treap_reach(xl), @_vcc_oset_union(@_vcc_oset_singleton(xl), @_vcc_oset_union(treap_reach(*((xl->left))), treap_reach(*((xl->right))))))); 
                assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(L#xl, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(L#xl, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl), ==(treap_keys(xl), @_vcc_intset_union(@_vcc_intset_singleton(*((xl->key))), @_vcc_intset_union(treap_keys(*((xl->left))), treap_keys(*((xl->right))))))); 
                assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(L#xl, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_max_key(xl), @\int_max(*((xl->key)), @\int_max(treap_max_key(*((xl->left))), treap_max_key(*((xl->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_eq_null(*((xl->right)))), ==(treap_max_key(xl), @\int_max(*((xl->key)), treap_max_key(*((xl->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_max_key(xl), @\int_max(*((xl->key)), treap_max_key(*((xl->right)))))))); 
                assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_max_prio(xl), @\int_max(*((xl->prio)), @\int_max(treap_max_prio(*((xl->left))), treap_max_prio(*((xl->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_eq_null(*((xl->right)))), ==(treap_max_prio(xl), @\int_max(*((xl->prio)), treap_max_prio(*((xl->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_max_prio(xl), @\int_max(*((xl->prio)), treap_max_prio(*((xl->right)))))))); 
                assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_min_key(xl), @\int_min(*((xl->key)), @\int_min(treap_min_key(*((xl->left))), treap_min_key(*((xl->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_eq_null(*((xl->right)))), ==(treap_min_key(xl), @\int_min(*((xl->key)), treap_min_key(*((xl->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_min_key(xl), @\int_min(*((xl->key)), treap_min_key(*((xl->right)))))))); 
                assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl), ==(treap_prios(xl), @_vcc_intset_union(@_vcc_intset_singleton(*((xl->prio))), @_vcc_intset_union(treap_prios(*((xl->left))), treap_prios(*((xl->right))))))); 
                assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(L#xl, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), ==(treap(tmp), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((tmp->left))), treap(*((tmp->right)))), unchecked!(@_vcc_oset_in(tmp, @_vcc_oset_union(treap_reach(*((tmp->left))), treap_reach(*((tmp->right))))))), unchecked!(@_vcc_intset_in(*((tmp->key)), @_vcc_intset_union(treap_keys(*((tmp->left))), treap_keys(*((tmp->right))))))), unchecked!(@_vcc_intset_in(*((tmp->prio)), @_vcc_intset_union(treap_prios(*((tmp->left))), treap_prios(*((tmp->right))))))), @_vcc_oset_disjoint(treap_reach(*((tmp->left))), treap_reach(*((tmp->right))))), @_vcc_intset_disjoint(treap_keys(*((tmp->left))), treap_keys(*((tmp->right))))), @_vcc_intset_disjoint(treap_prios(*((tmp->left))), treap_prios(*((tmp->right))))), ==>(@_vcc_ptr_neq_null(*((tmp->left))), <(treap_max_key(*((tmp->left))), *((tmp->key))))), ==>(@_vcc_ptr_neq_null(*((tmp->right))), <(*((tmp->key)), treap_min_key(*((tmp->right)))))), ==>(@_vcc_ptr_neq_null(*((tmp->left))), <(treap_max_prio(*((tmp->left))), *((tmp->prio))))), ==>(@_vcc_ptr_neq_null(*((tmp->right))), <(treap_max_prio(*((tmp->right))), *((tmp->prio))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> F#treap($s, $phys_ptr_cast(L#tmp, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(L#tmp, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), ==(treap_reach(tmp), @_vcc_oset_union(@_vcc_oset_singleton(tmp), @_vcc_oset_union(treap_reach(*((tmp->left))), treap_reach(*((tmp->right))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(L#tmp, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(L#tmp, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), ==(treap_keys(tmp), @_vcc_intset_union(@_vcc_intset_singleton(*((tmp->key))), @_vcc_intset_union(treap_keys(*((tmp->left))), treap_keys(*((tmp->right))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(L#tmp, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_max_key(tmp), @\int_max(*((tmp->key)), @\int_max(treap_max_key(*((tmp->left))), treap_max_key(*((tmp->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_eq_null(*((tmp->right)))), ==(treap_max_key(tmp), @\int_max(*((tmp->key)), treap_max_key(*((tmp->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_max_key(tmp), @\int_max(*((tmp->key)), treap_max_key(*((tmp->right)))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_max_prio(tmp), @\int_max(*((tmp->prio)), @\int_max(treap_max_prio(*((tmp->left))), treap_max_prio(*((tmp->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_eq_null(*((tmp->right)))), ==(treap_max_prio(tmp), @\int_max(*((tmp->prio)), treap_max_prio(*((tmp->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_max_prio(tmp), @\int_max(*((tmp->prio)), treap_max_prio(*((tmp->right)))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_min_key(tmp), @\int_min(*((tmp->key)), @\int_min(treap_min_key(*((tmp->left))), treap_min_key(*((tmp->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_eq_null(*((tmp->right)))), ==(treap_min_key(tmp), @\int_min(*((tmp->key)), treap_min_key(*((tmp->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_min_key(tmp), @\int_min(*((tmp->key)), treap_min_key(*((tmp->right)))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), ==(treap_prios(tmp), @_vcc_intset_union(@_vcc_intset_singleton(*((tmp->prio))), @_vcc_intset_union(treap_prios(*((tmp->left))), treap_prios(*((tmp->right))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(L#tmp, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), ==(treap(x), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x->left))), treap(*((x->right)))), unchecked!(@_vcc_oset_in(x, @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->key)), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->prio)), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))), @_vcc_oset_disjoint(treap_reach(*((x->left))), treap_reach(*((x->right))))), @_vcc_intset_disjoint(treap_keys(*((x->left))), treap_keys(*((x->right))))), @_vcc_intset_disjoint(treap_prios(*((x->left))), treap_prios(*((x->right))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_key(*((x->left))), *((x->key))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(*((x->key)), treap_min_key(*((x->right)))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_prio(*((x->left))), *((x->prio))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(treap_max_prio(*((x->right))), *((x->prio))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap($s, $phys_ptr_cast(P#x, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(P#x, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_reach(x), @_vcc_oset_union(@_vcc_oset_singleton(x), @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(P#x, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(P#x, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_keys(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->key))), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), @\int_max(treap_max_key(*((x->left))), treap_max_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->right)))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), @\int_max(treap_max_prio(*((x->left))), treap_max_prio(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->right)))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), @\int_min(treap_min_key(*((x->left))), treap_min_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->right)))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_prios(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->prio))), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), ==(treap(tmp), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((tmp->left))), treap(*((tmp->right)))), unchecked!(@_vcc_oset_in(tmp, @_vcc_oset_union(treap_reach(*((tmp->left))), treap_reach(*((tmp->right))))))), unchecked!(@_vcc_intset_in(*((tmp->key)), @_vcc_intset_union(treap_keys(*((tmp->left))), treap_keys(*((tmp->right))))))), unchecked!(@_vcc_intset_in(*((tmp->prio)), @_vcc_intset_union(treap_prios(*((tmp->left))), treap_prios(*((tmp->right))))))), @_vcc_oset_disjoint(treap_reach(*((tmp->left))), treap_reach(*((tmp->right))))), @_vcc_intset_disjoint(treap_keys(*((tmp->left))), treap_keys(*((tmp->right))))), @_vcc_intset_disjoint(treap_prios(*((tmp->left))), treap_prios(*((tmp->right))))), ==>(@_vcc_ptr_neq_null(*((tmp->left))), <(treap_max_key(*((tmp->left))), *((tmp->key))))), ==>(@_vcc_ptr_neq_null(*((tmp->right))), <(*((tmp->key)), treap_min_key(*((tmp->right)))))), ==>(@_vcc_ptr_neq_null(*((tmp->left))), <(treap_max_prio(*((tmp->left))), *((tmp->prio))))), ==>(@_vcc_ptr_neq_null(*((tmp->right))), <(treap_max_prio(*((tmp->right))), *((tmp->prio))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> F#treap($s, $phys_ptr_cast(L#tmp, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(L#tmp, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), ==(treap_reach(tmp), @_vcc_oset_union(@_vcc_oset_singleton(tmp), @_vcc_oset_union(treap_reach(*((tmp->left))), treap_reach(*((tmp->right))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(L#tmp, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(L#tmp, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), ==(treap_keys(tmp), @_vcc_intset_union(@_vcc_intset_singleton(*((tmp->key))), @_vcc_intset_union(treap_keys(*((tmp->left))), treap_keys(*((tmp->right))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(L#tmp, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_max_key(tmp), @\int_max(*((tmp->key)), @\int_max(treap_max_key(*((tmp->left))), treap_max_key(*((tmp->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_eq_null(*((tmp->right)))), ==(treap_max_key(tmp), @\int_max(*((tmp->key)), treap_max_key(*((tmp->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_max_key(tmp), @\int_max(*((tmp->key)), treap_max_key(*((tmp->right)))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_max_prio(tmp), @\int_max(*((tmp->prio)), @\int_max(treap_max_prio(*((tmp->left))), treap_max_prio(*((tmp->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_eq_null(*((tmp->right)))), ==(treap_max_prio(tmp), @\int_max(*((tmp->prio)), treap_max_prio(*((tmp->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_max_prio(tmp), @\int_max(*((tmp->prio)), treap_max_prio(*((tmp->right)))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_min_key(tmp), @\int_min(*((tmp->key)), @\int_min(treap_min_key(*((tmp->left))), treap_min_key(*((tmp->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_eq_null(*((tmp->right)))), ==(treap_min_key(tmp), @\int_min(*((tmp->key)), treap_min_key(*((tmp->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_min_key(tmp), @\int_min(*((tmp->key)), treap_min_key(*((tmp->right)))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), ==(treap_prios(tmp), @_vcc_intset_union(@_vcc_intset_singleton(*((tmp->prio))), @_vcc_intset_union(treap_prios(*((tmp->left))), treap_prios(*((tmp->right))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(L#tmp, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
                // return x; 
                $result := $phys_ptr_cast(P#x, ^b_node);
                assume true;
                assert $position_marker();
                goto #exit;
            }
            else
            {
              anon3:
                // assume ==>(@_vcc_ptr_neq_null(x1), ==(treap(x1), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x1->left))), treap(*((x1->right)))), unchecked!(@_vcc_oset_in(x1, @_vcc_oset_union(treap_reach(*((x1->left))), treap_reach(*((x1->right))))))), unchecked!(@_vcc_intset_in(*((x1->key)), @_vcc_intset_union(treap_keys(*((x1->left))), treap_keys(*((x1->right))))))), unchecked!(@_vcc_intset_in(*((x1->prio)), @_vcc_intset_union(treap_prios(*((x1->left))), treap_prios(*((x1->right))))))), @_vcc_oset_disjoint(treap_reach(*((x1->left))), treap_reach(*((x1->right))))), @_vcc_intset_disjoint(treap_keys(*((x1->left))), treap_keys(*((x1->right))))), @_vcc_intset_disjoint(treap_prios(*((x1->left))), treap_prios(*((x1->right))))), ==>(@_vcc_ptr_neq_null(*((x1->left))), <(treap_max_key(*((x1->left))), *((x1->key))))), ==>(@_vcc_ptr_neq_null(*((x1->right))), <(*((x1->key)), treap_min_key(*((x1->right)))))), ==>(@_vcc_ptr_neq_null(*((x1->left))), <(treap_max_prio(*((x1->left))), *((x1->prio))))), ==>(@_vcc_ptr_neq_null(*((x1->right))), <(treap_max_prio(*((x1->right))), *((x1->prio))))))); 
                assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> F#treap($s, $phys_ptr_cast(SL#x1, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(SL#x1, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1), ==(treap_reach(x1), @_vcc_oset_union(@_vcc_oset_singleton(x1), @_vcc_oset_union(treap_reach(*((x1->left))), treap_reach(*((x1->right))))))); 
                assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(SL#x1, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(SL#x1, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1), ==(treap_keys(x1), @_vcc_intset_union(@_vcc_intset_singleton(*((x1->key))), @_vcc_intset_union(treap_keys(*((x1->left))), treap_keys(*((x1->right))))))); 
                assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(SL#x1, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x1->left))), @_vcc_ptr_neq_null(*((x1->right)))), ==(treap_max_key(x1), @\int_max(*((x1->key)), @\int_max(treap_max_key(*((x1->left))), treap_max_key(*((x1->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x1->left))), @_vcc_ptr_eq_null(*((x1->right)))), ==(treap_max_key(x1), @\int_max(*((x1->key)), treap_max_key(*((x1->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x1->left))), @_vcc_ptr_neq_null(*((x1->right)))), ==(treap_max_key(x1), @\int_max(*((x1->key)), treap_max_key(*((x1->right)))))))); 
                assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x1->left))), @_vcc_ptr_neq_null(*((x1->right)))), ==(treap_max_prio(x1), @\int_max(*((x1->prio)), @\int_max(treap_max_prio(*((x1->left))), treap_max_prio(*((x1->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x1->left))), @_vcc_ptr_eq_null(*((x1->right)))), ==(treap_max_prio(x1), @\int_max(*((x1->prio)), treap_max_prio(*((x1->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x1->left))), @_vcc_ptr_neq_null(*((x1->right)))), ==(treap_max_prio(x1), @\int_max(*((x1->prio)), treap_max_prio(*((x1->right)))))))); 
                assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x1->left))), @_vcc_ptr_neq_null(*((x1->right)))), ==(treap_min_key(x1), @\int_min(*((x1->key)), @\int_min(treap_min_key(*((x1->left))), treap_min_key(*((x1->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x1->left))), @_vcc_ptr_eq_null(*((x1->right)))), ==(treap_min_key(x1), @\int_min(*((x1->key)), treap_min_key(*((x1->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x1->left))), @_vcc_ptr_neq_null(*((x1->right)))), ==(treap_min_key(x1), @\int_min(*((x1->key)), treap_min_key(*((x1->right)))))))); 
                assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1), ==(treap_prios(x1), @_vcc_intset_union(@_vcc_intset_singleton(*((x1->prio))), @_vcc_intset_union(treap_prios(*((x1->left))), treap_prios(*((x1->right))))))); 
                assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(SL#x1, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0), ==(treap(x0), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x0->left))), treap(*((x0->right)))), unchecked!(@_vcc_oset_in(x0, @_vcc_oset_union(treap_reach(*((x0->left))), treap_reach(*((x0->right))))))), unchecked!(@_vcc_intset_in(*((x0->key)), @_vcc_intset_union(treap_keys(*((x0->left))), treap_keys(*((x0->right))))))), unchecked!(@_vcc_intset_in(*((x0->prio)), @_vcc_intset_union(treap_prios(*((x0->left))), treap_prios(*((x0->right))))))), @_vcc_oset_disjoint(treap_reach(*((x0->left))), treap_reach(*((x0->right))))), @_vcc_intset_disjoint(treap_keys(*((x0->left))), treap_keys(*((x0->right))))), @_vcc_intset_disjoint(treap_prios(*((x0->left))), treap_prios(*((x0->right))))), ==>(@_vcc_ptr_neq_null(*((x0->left))), <(treap_max_key(*((x0->left))), *((x0->key))))), ==>(@_vcc_ptr_neq_null(*((x0->right))), <(*((x0->key)), treap_min_key(*((x0->right)))))), ==>(@_vcc_ptr_neq_null(*((x0->left))), <(treap_max_prio(*((x0->left))), *((x0->prio))))), ==>(@_vcc_ptr_neq_null(*((x0->right))), <(treap_max_prio(*((x0->right))), *((x0->prio))))))); 
                assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> F#treap($s, $phys_ptr_cast(SL#x0, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(SL#x0, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0), ==(treap_reach(x0), @_vcc_oset_union(@_vcc_oset_singleton(x0), @_vcc_oset_union(treap_reach(*((x0->left))), treap_reach(*((x0->right))))))); 
                assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(SL#x0, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(SL#x0, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0), ==(treap_keys(x0), @_vcc_intset_union(@_vcc_intset_singleton(*((x0->key))), @_vcc_intset_union(treap_keys(*((x0->left))), treap_keys(*((x0->right))))))); 
                assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(SL#x0, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x0->left))), @_vcc_ptr_neq_null(*((x0->right)))), ==(treap_max_key(x0), @\int_max(*((x0->key)), @\int_max(treap_max_key(*((x0->left))), treap_max_key(*((x0->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x0->left))), @_vcc_ptr_eq_null(*((x0->right)))), ==(treap_max_key(x0), @\int_max(*((x0->key)), treap_max_key(*((x0->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x0->left))), @_vcc_ptr_neq_null(*((x0->right)))), ==(treap_max_key(x0), @\int_max(*((x0->key)), treap_max_key(*((x0->right)))))))); 
                assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x0->left))), @_vcc_ptr_neq_null(*((x0->right)))), ==(treap_max_prio(x0), @\int_max(*((x0->prio)), @\int_max(treap_max_prio(*((x0->left))), treap_max_prio(*((x0->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x0->left))), @_vcc_ptr_eq_null(*((x0->right)))), ==(treap_max_prio(x0), @\int_max(*((x0->prio)), treap_max_prio(*((x0->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x0->left))), @_vcc_ptr_neq_null(*((x0->right)))), ==(treap_max_prio(x0), @\int_max(*((x0->prio)), treap_max_prio(*((x0->right)))))))); 
                assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x0->left))), @_vcc_ptr_neq_null(*((x0->right)))), ==(treap_min_key(x0), @\int_min(*((x0->key)), @\int_min(treap_min_key(*((x0->left))), treap_min_key(*((x0->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x0->left))), @_vcc_ptr_eq_null(*((x0->right)))), ==(treap_min_key(x0), @\int_min(*((x0->key)), treap_min_key(*((x0->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x0->left))), @_vcc_ptr_neq_null(*((x0->right)))), ==(treap_min_key(x0), @\int_min(*((x0->key)), treap_min_key(*((x0->right)))))))); 
                assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0), ==(treap_prios(x0), @_vcc_intset_union(@_vcc_intset_singleton(*((x0->prio))), @_vcc_intset_union(treap_prios(*((x0->left))), treap_prios(*((x0->right))))))); 
                assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(SL#x0, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr), ==(treap(xr), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((xr->left))), treap(*((xr->right)))), unchecked!(@_vcc_oset_in(xr, @_vcc_oset_union(treap_reach(*((xr->left))), treap_reach(*((xr->right))))))), unchecked!(@_vcc_intset_in(*((xr->key)), @_vcc_intset_union(treap_keys(*((xr->left))), treap_keys(*((xr->right))))))), unchecked!(@_vcc_intset_in(*((xr->prio)), @_vcc_intset_union(treap_prios(*((xr->left))), treap_prios(*((xr->right))))))), @_vcc_oset_disjoint(treap_reach(*((xr->left))), treap_reach(*((xr->right))))), @_vcc_intset_disjoint(treap_keys(*((xr->left))), treap_keys(*((xr->right))))), @_vcc_intset_disjoint(treap_prios(*((xr->left))), treap_prios(*((xr->right))))), ==>(@_vcc_ptr_neq_null(*((xr->left))), <(treap_max_key(*((xr->left))), *((xr->key))))), ==>(@_vcc_ptr_neq_null(*((xr->right))), <(*((xr->key)), treap_min_key(*((xr->right)))))), ==>(@_vcc_ptr_neq_null(*((xr->left))), <(treap_max_prio(*((xr->left))), *((xr->prio))))), ==>(@_vcc_ptr_neq_null(*((xr->right))), <(treap_max_prio(*((xr->right))), *((xr->prio))))))); 
                assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> F#treap($s, $phys_ptr_cast(L#xr, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(L#xr, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr), ==(treap_reach(xr), @_vcc_oset_union(@_vcc_oset_singleton(xr), @_vcc_oset_union(treap_reach(*((xr->left))), treap_reach(*((xr->right))))))); 
                assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(L#xr, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(L#xr, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr), ==(treap_keys(xr), @_vcc_intset_union(@_vcc_intset_singleton(*((xr->key))), @_vcc_intset_union(treap_keys(*((xr->left))), treap_keys(*((xr->right))))))); 
                assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(L#xr, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_max_key(xr), @\int_max(*((xr->key)), @\int_max(treap_max_key(*((xr->left))), treap_max_key(*((xr->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_eq_null(*((xr->right)))), ==(treap_max_key(xr), @\int_max(*((xr->key)), treap_max_key(*((xr->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_max_key(xr), @\int_max(*((xr->key)), treap_max_key(*((xr->right)))))))); 
                assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_max_prio(xr), @\int_max(*((xr->prio)), @\int_max(treap_max_prio(*((xr->left))), treap_max_prio(*((xr->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_eq_null(*((xr->right)))), ==(treap_max_prio(xr), @\int_max(*((xr->prio)), treap_max_prio(*((xr->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_max_prio(xr), @\int_max(*((xr->prio)), treap_max_prio(*((xr->right)))))))); 
                assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_min_key(xr), @\int_min(*((xr->key)), @\int_min(treap_min_key(*((xr->left))), treap_min_key(*((xr->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_eq_null(*((xr->right)))), ==(treap_min_key(xr), @\int_min(*((xr->key)), treap_min_key(*((xr->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_min_key(xr), @\int_min(*((xr->key)), treap_min_key(*((xr->right)))))))); 
                assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr), ==(treap_prios(xr), @_vcc_intset_union(@_vcc_intset_singleton(*((xr->prio))), @_vcc_intset_union(treap_prios(*((xr->left))), treap_prios(*((xr->right))))))); 
                assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(L#xr, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl), ==(treap(xl), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((xl->left))), treap(*((xl->right)))), unchecked!(@_vcc_oset_in(xl, @_vcc_oset_union(treap_reach(*((xl->left))), treap_reach(*((xl->right))))))), unchecked!(@_vcc_intset_in(*((xl->key)), @_vcc_intset_union(treap_keys(*((xl->left))), treap_keys(*((xl->right))))))), unchecked!(@_vcc_intset_in(*((xl->prio)), @_vcc_intset_union(treap_prios(*((xl->left))), treap_prios(*((xl->right))))))), @_vcc_oset_disjoint(treap_reach(*((xl->left))), treap_reach(*((xl->right))))), @_vcc_intset_disjoint(treap_keys(*((xl->left))), treap_keys(*((xl->right))))), @_vcc_intset_disjoint(treap_prios(*((xl->left))), treap_prios(*((xl->right))))), ==>(@_vcc_ptr_neq_null(*((xl->left))), <(treap_max_key(*((xl->left))), *((xl->key))))), ==>(@_vcc_ptr_neq_null(*((xl->right))), <(*((xl->key)), treap_min_key(*((xl->right)))))), ==>(@_vcc_ptr_neq_null(*((xl->left))), <(treap_max_prio(*((xl->left))), *((xl->prio))))), ==>(@_vcc_ptr_neq_null(*((xl->right))), <(treap_max_prio(*((xl->right))), *((xl->prio))))))); 
                assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> F#treap($s, $phys_ptr_cast(L#xl, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(L#xl, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl), ==(treap_reach(xl), @_vcc_oset_union(@_vcc_oset_singleton(xl), @_vcc_oset_union(treap_reach(*((xl->left))), treap_reach(*((xl->right))))))); 
                assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(L#xl, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(L#xl, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl), ==(treap_keys(xl), @_vcc_intset_union(@_vcc_intset_singleton(*((xl->key))), @_vcc_intset_union(treap_keys(*((xl->left))), treap_keys(*((xl->right))))))); 
                assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(L#xl, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_max_key(xl), @\int_max(*((xl->key)), @\int_max(treap_max_key(*((xl->left))), treap_max_key(*((xl->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_eq_null(*((xl->right)))), ==(treap_max_key(xl), @\int_max(*((xl->key)), treap_max_key(*((xl->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_max_key(xl), @\int_max(*((xl->key)), treap_max_key(*((xl->right)))))))); 
                assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_max_prio(xl), @\int_max(*((xl->prio)), @\int_max(treap_max_prio(*((xl->left))), treap_max_prio(*((xl->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_eq_null(*((xl->right)))), ==(treap_max_prio(xl), @\int_max(*((xl->prio)), treap_max_prio(*((xl->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_max_prio(xl), @\int_max(*((xl->prio)), treap_max_prio(*((xl->right)))))))); 
                assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_min_key(xl), @\int_min(*((xl->key)), @\int_min(treap_min_key(*((xl->left))), treap_min_key(*((xl->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_eq_null(*((xl->right)))), ==(treap_min_key(xl), @\int_min(*((xl->key)), treap_min_key(*((xl->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_min_key(xl), @\int_min(*((xl->key)), treap_min_key(*((xl->right)))))))); 
                assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl), ==(treap_prios(xl), @_vcc_intset_union(@_vcc_intset_singleton(*((xl->prio))), @_vcc_intset_union(treap_prios(*((xl->left))), treap_prios(*((xl->right))))))); 
                assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(L#xl, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), ==(treap(tmp), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((tmp->left))), treap(*((tmp->right)))), unchecked!(@_vcc_oset_in(tmp, @_vcc_oset_union(treap_reach(*((tmp->left))), treap_reach(*((tmp->right))))))), unchecked!(@_vcc_intset_in(*((tmp->key)), @_vcc_intset_union(treap_keys(*((tmp->left))), treap_keys(*((tmp->right))))))), unchecked!(@_vcc_intset_in(*((tmp->prio)), @_vcc_intset_union(treap_prios(*((tmp->left))), treap_prios(*((tmp->right))))))), @_vcc_oset_disjoint(treap_reach(*((tmp->left))), treap_reach(*((tmp->right))))), @_vcc_intset_disjoint(treap_keys(*((tmp->left))), treap_keys(*((tmp->right))))), @_vcc_intset_disjoint(treap_prios(*((tmp->left))), treap_prios(*((tmp->right))))), ==>(@_vcc_ptr_neq_null(*((tmp->left))), <(treap_max_key(*((tmp->left))), *((tmp->key))))), ==>(@_vcc_ptr_neq_null(*((tmp->right))), <(*((tmp->key)), treap_min_key(*((tmp->right)))))), ==>(@_vcc_ptr_neq_null(*((tmp->left))), <(treap_max_prio(*((tmp->left))), *((tmp->prio))))), ==>(@_vcc_ptr_neq_null(*((tmp->right))), <(treap_max_prio(*((tmp->right))), *((tmp->prio))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> F#treap($s, $phys_ptr_cast(L#tmp, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(L#tmp, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), ==(treap_reach(tmp), @_vcc_oset_union(@_vcc_oset_singleton(tmp), @_vcc_oset_union(treap_reach(*((tmp->left))), treap_reach(*((tmp->right))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(L#tmp, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(L#tmp, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), ==(treap_keys(tmp), @_vcc_intset_union(@_vcc_intset_singleton(*((tmp->key))), @_vcc_intset_union(treap_keys(*((tmp->left))), treap_keys(*((tmp->right))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(L#tmp, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_max_key(tmp), @\int_max(*((tmp->key)), @\int_max(treap_max_key(*((tmp->left))), treap_max_key(*((tmp->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_eq_null(*((tmp->right)))), ==(treap_max_key(tmp), @\int_max(*((tmp->key)), treap_max_key(*((tmp->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_max_key(tmp), @\int_max(*((tmp->key)), treap_max_key(*((tmp->right)))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_max_prio(tmp), @\int_max(*((tmp->prio)), @\int_max(treap_max_prio(*((tmp->left))), treap_max_prio(*((tmp->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_eq_null(*((tmp->right)))), ==(treap_max_prio(tmp), @\int_max(*((tmp->prio)), treap_max_prio(*((tmp->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_max_prio(tmp), @\int_max(*((tmp->prio)), treap_max_prio(*((tmp->right)))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_min_key(tmp), @\int_min(*((tmp->key)), @\int_min(treap_min_key(*((tmp->left))), treap_min_key(*((tmp->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_eq_null(*((tmp->right)))), ==(treap_min_key(tmp), @\int_min(*((tmp->key)), treap_min_key(*((tmp->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_min_key(tmp), @\int_min(*((tmp->key)), treap_min_key(*((tmp->right)))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), ==(treap_prios(tmp), @_vcc_intset_union(@_vcc_intset_singleton(*((tmp->prio))), @_vcc_intset_union(treap_prios(*((tmp->left))), treap_prios(*((tmp->right))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(L#tmp, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), ==(treap(x), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x->left))), treap(*((x->right)))), unchecked!(@_vcc_oset_in(x, @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->key)), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->prio)), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))), @_vcc_oset_disjoint(treap_reach(*((x->left))), treap_reach(*((x->right))))), @_vcc_intset_disjoint(treap_keys(*((x->left))), treap_keys(*((x->right))))), @_vcc_intset_disjoint(treap_prios(*((x->left))), treap_prios(*((x->right))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_key(*((x->left))), *((x->key))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(*((x->key)), treap_min_key(*((x->right)))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_prio(*((x->left))), *((x->prio))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(treap_max_prio(*((x->right))), *((x->prio))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap($s, $phys_ptr_cast(P#x, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(P#x, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_reach(x), @_vcc_oset_union(@_vcc_oset_singleton(x), @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(P#x, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(P#x, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_keys(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->key))), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), @\int_max(treap_max_key(*((x->left))), treap_max_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->right)))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), @\int_max(treap_max_prio(*((x->left))), treap_max_prio(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->right)))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), @\int_min(treap_min_key(*((x->left))), treap_min_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->right)))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_prios(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->prio))), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // struct b_node* lr; 
                // struct b_node* tmp2; 
                // tmp2 := tmp; 
                SL#tmp2 := $phys_ptr_cast(L#tmp, ^b_node);
                // struct b_node* stmtexpr0#21; 
                // stmtexpr0#21 := tmp2; 
                stmtexpr0#21 := $phys_ptr_cast(SL#tmp2, ^b_node);
                // assume ==>(@_vcc_ptr_neq_null(tmp), ==(treap(tmp), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((tmp->left))), treap(*((tmp->right)))), unchecked!(@_vcc_oset_in(tmp, @_vcc_oset_union(treap_reach(*((tmp->left))), treap_reach(*((tmp->right))))))), unchecked!(@_vcc_intset_in(*((tmp->key)), @_vcc_intset_union(treap_keys(*((tmp->left))), treap_keys(*((tmp->right))))))), unchecked!(@_vcc_intset_in(*((tmp->prio)), @_vcc_intset_union(treap_prios(*((tmp->left))), treap_prios(*((tmp->right))))))), @_vcc_oset_disjoint(treap_reach(*((tmp->left))), treap_reach(*((tmp->right))))), @_vcc_intset_disjoint(treap_keys(*((tmp->left))), treap_keys(*((tmp->right))))), @_vcc_intset_disjoint(treap_prios(*((tmp->left))), treap_prios(*((tmp->right))))), ==>(@_vcc_ptr_neq_null(*((tmp->left))), <(treap_max_key(*((tmp->left))), *((tmp->key))))), ==>(@_vcc_ptr_neq_null(*((tmp->right))), <(*((tmp->key)), treap_min_key(*((tmp->right)))))), ==>(@_vcc_ptr_neq_null(*((tmp->left))), <(treap_max_prio(*((tmp->left))), *((tmp->prio))))), ==>(@_vcc_ptr_neq_null(*((tmp->right))), <(treap_max_prio(*((tmp->right))), *((tmp->prio))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> F#treap($s, $phys_ptr_cast(L#tmp, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(L#tmp, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), ==(treap_reach(tmp), @_vcc_oset_union(@_vcc_oset_singleton(tmp), @_vcc_oset_union(treap_reach(*((tmp->left))), treap_reach(*((tmp->right))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(L#tmp, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(L#tmp, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), ==(treap_keys(tmp), @_vcc_intset_union(@_vcc_intset_singleton(*((tmp->key))), @_vcc_intset_union(treap_keys(*((tmp->left))), treap_keys(*((tmp->right))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(L#tmp, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_max_key(tmp), @\int_max(*((tmp->key)), @\int_max(treap_max_key(*((tmp->left))), treap_max_key(*((tmp->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_eq_null(*((tmp->right)))), ==(treap_max_key(tmp), @\int_max(*((tmp->key)), treap_max_key(*((tmp->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_max_key(tmp), @\int_max(*((tmp->key)), treap_max_key(*((tmp->right)))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_max_prio(tmp), @\int_max(*((tmp->prio)), @\int_max(treap_max_prio(*((tmp->left))), treap_max_prio(*((tmp->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_eq_null(*((tmp->right)))), ==(treap_max_prio(tmp), @\int_max(*((tmp->prio)), treap_max_prio(*((tmp->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_max_prio(tmp), @\int_max(*((tmp->prio)), treap_max_prio(*((tmp->right)))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_min_key(tmp), @\int_min(*((tmp->key)), @\int_min(treap_min_key(*((tmp->left))), treap_min_key(*((tmp->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_eq_null(*((tmp->right)))), ==(treap_min_key(tmp), @\int_min(*((tmp->key)), treap_min_key(*((tmp->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_min_key(tmp), @\int_min(*((tmp->key)), treap_min_key(*((tmp->right)))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), ==(treap_prios(tmp), @_vcc_intset_union(@_vcc_intset_singleton(*((tmp->prio))), @_vcc_intset_union(treap_prios(*((tmp->left))), treap_prios(*((tmp->right))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(L#tmp, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
                // assert @reads_check_normal((tmp->right)); 
                assert $thread_local($s, $phys_ptr_cast(L#tmp, ^b_node));
                // lr := *((tmp->right)); 
                L#lr := $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node);
                // assume ==>(@_vcc_ptr_neq_null(lr), ==(treap(lr), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((lr->left))), treap(*((lr->right)))), unchecked!(@_vcc_oset_in(lr, @_vcc_oset_union(treap_reach(*((lr->left))), treap_reach(*((lr->right))))))), unchecked!(@_vcc_intset_in(*((lr->key)), @_vcc_intset_union(treap_keys(*((lr->left))), treap_keys(*((lr->right))))))), unchecked!(@_vcc_intset_in(*((lr->prio)), @_vcc_intset_union(treap_prios(*((lr->left))), treap_prios(*((lr->right))))))), @_vcc_oset_disjoint(treap_reach(*((lr->left))), treap_reach(*((lr->right))))), @_vcc_intset_disjoint(treap_keys(*((lr->left))), treap_keys(*((lr->right))))), @_vcc_intset_disjoint(treap_prios(*((lr->left))), treap_prios(*((lr->right))))), ==>(@_vcc_ptr_neq_null(*((lr->left))), <(treap_max_key(*((lr->left))), *((lr->key))))), ==>(@_vcc_ptr_neq_null(*((lr->right))), <(*((lr->key)), treap_min_key(*((lr->right)))))), ==>(@_vcc_ptr_neq_null(*((lr->left))), <(treap_max_prio(*((lr->left))), *((lr->prio))))), ==>(@_vcc_ptr_neq_null(*((lr->right))), <(treap_max_prio(*((lr->right))), *((lr->prio))))))); 
                assume $non_null($phys_ptr_cast(L#lr, ^b_node)) ==> F#treap($s, $phys_ptr_cast(L#lr, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(L#lr, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(L#lr, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(L#lr, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(L#lr, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#lr, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#lr, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#lr, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(lr), ==(treap_reach(lr), @_vcc_oset_union(@_vcc_oset_singleton(lr), @_vcc_oset_union(treap_reach(*((lr->left))), treap_reach(*((lr->right))))))); 
                assume $non_null($phys_ptr_cast(L#lr, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(L#lr, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(L#lr, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(lr), ==(treap_keys(lr), @_vcc_intset_union(@_vcc_intset_singleton(*((lr->key))), @_vcc_intset_union(treap_keys(*((lr->left))), treap_keys(*((lr->right))))))); 
                assume $non_null($phys_ptr_cast(L#lr, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(L#lr, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(L#lr, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(lr), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((lr->left))), @_vcc_ptr_neq_null(*((lr->right)))), ==(treap_max_key(lr), @\int_max(*((lr->key)), @\int_max(treap_max_key(*((lr->left))), treap_max_key(*((lr->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((lr->left))), @_vcc_ptr_eq_null(*((lr->right)))), ==(treap_max_key(lr), @\int_max(*((lr->key)), treap_max_key(*((lr->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((lr->left))), @_vcc_ptr_neq_null(*((lr->right)))), ==(treap_max_key(lr), @\int_max(*((lr->key)), treap_max_key(*((lr->right)))))))); 
                assume $non_null($phys_ptr_cast(L#lr, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#lr, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#lr, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#lr, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#lr, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#lr, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#lr, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(lr), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((lr->left))), @_vcc_ptr_neq_null(*((lr->right)))), ==(treap_max_prio(lr), @\int_max(*((lr->prio)), @\int_max(treap_max_prio(*((lr->left))), treap_max_prio(*((lr->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((lr->left))), @_vcc_ptr_eq_null(*((lr->right)))), ==(treap_max_prio(lr), @\int_max(*((lr->prio)), treap_max_prio(*((lr->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((lr->left))), @_vcc_ptr_neq_null(*((lr->right)))), ==(treap_max_prio(lr), @\int_max(*((lr->prio)), treap_max_prio(*((lr->right)))))))); 
                assume $non_null($phys_ptr_cast(L#lr, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#lr, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#lr, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#lr, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#lr, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#lr, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#lr, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(lr), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((lr->left))), @_vcc_ptr_neq_null(*((lr->right)))), ==(treap_min_key(lr), @\int_min(*((lr->key)), @\int_min(treap_min_key(*((lr->left))), treap_min_key(*((lr->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((lr->left))), @_vcc_ptr_eq_null(*((lr->right)))), ==(treap_min_key(lr), @\int_min(*((lr->key)), treap_min_key(*((lr->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((lr->left))), @_vcc_ptr_neq_null(*((lr->right)))), ==(treap_min_key(lr), @\int_min(*((lr->key)), treap_min_key(*((lr->right)))))))); 
                assume $non_null($phys_ptr_cast(L#lr, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#lr, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#lr, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#lr, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#lr, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#lr, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#lr, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(lr), ==(treap_prios(lr), @_vcc_intset_union(@_vcc_intset_singleton(*((lr->prio))), @_vcc_intset_union(treap_prios(*((lr->left))), treap_prios(*((lr->right))))))); 
                assume $non_null($phys_ptr_cast(L#lr, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(L#lr, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(L#lr, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), ==(treap(tmp), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((tmp->left))), treap(*((tmp->right)))), unchecked!(@_vcc_oset_in(tmp, @_vcc_oset_union(treap_reach(*((tmp->left))), treap_reach(*((tmp->right))))))), unchecked!(@_vcc_intset_in(*((tmp->key)), @_vcc_intset_union(treap_keys(*((tmp->left))), treap_keys(*((tmp->right))))))), unchecked!(@_vcc_intset_in(*((tmp->prio)), @_vcc_intset_union(treap_prios(*((tmp->left))), treap_prios(*((tmp->right))))))), @_vcc_oset_disjoint(treap_reach(*((tmp->left))), treap_reach(*((tmp->right))))), @_vcc_intset_disjoint(treap_keys(*((tmp->left))), treap_keys(*((tmp->right))))), @_vcc_intset_disjoint(treap_prios(*((tmp->left))), treap_prios(*((tmp->right))))), ==>(@_vcc_ptr_neq_null(*((tmp->left))), <(treap_max_key(*((tmp->left))), *((tmp->key))))), ==>(@_vcc_ptr_neq_null(*((tmp->right))), <(*((tmp->key)), treap_min_key(*((tmp->right)))))), ==>(@_vcc_ptr_neq_null(*((tmp->left))), <(treap_max_prio(*((tmp->left))), *((tmp->prio))))), ==>(@_vcc_ptr_neq_null(*((tmp->right))), <(treap_max_prio(*((tmp->right))), *((tmp->prio))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> F#treap($s, $phys_ptr_cast(L#tmp, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(L#tmp, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), ==(treap_reach(tmp), @_vcc_oset_union(@_vcc_oset_singleton(tmp), @_vcc_oset_union(treap_reach(*((tmp->left))), treap_reach(*((tmp->right))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(L#tmp, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(L#tmp, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), ==(treap_keys(tmp), @_vcc_intset_union(@_vcc_intset_singleton(*((tmp->key))), @_vcc_intset_union(treap_keys(*((tmp->left))), treap_keys(*((tmp->right))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(L#tmp, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_max_key(tmp), @\int_max(*((tmp->key)), @\int_max(treap_max_key(*((tmp->left))), treap_max_key(*((tmp->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_eq_null(*((tmp->right)))), ==(treap_max_key(tmp), @\int_max(*((tmp->key)), treap_max_key(*((tmp->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_max_key(tmp), @\int_max(*((tmp->key)), treap_max_key(*((tmp->right)))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_max_prio(tmp), @\int_max(*((tmp->prio)), @\int_max(treap_max_prio(*((tmp->left))), treap_max_prio(*((tmp->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_eq_null(*((tmp->right)))), ==(treap_max_prio(tmp), @\int_max(*((tmp->prio)), treap_max_prio(*((tmp->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_max_prio(tmp), @\int_max(*((tmp->prio)), treap_max_prio(*((tmp->right)))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_min_key(tmp), @\int_min(*((tmp->key)), @\int_min(treap_min_key(*((tmp->left))), treap_min_key(*((tmp->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_eq_null(*((tmp->right)))), ==(treap_min_key(tmp), @\int_min(*((tmp->key)), treap_min_key(*((tmp->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_min_key(tmp), @\int_min(*((tmp->key)), treap_min_key(*((tmp->right)))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), ==(treap_prios(tmp), @_vcc_intset_union(@_vcc_intset_singleton(*((tmp->prio))), @_vcc_intset_union(treap_prios(*((tmp->left))), treap_prios(*((tmp->right))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(L#tmp, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
                // _math \state _dryad_S2#4; 
                // _dryad_S2#4 := @_vcc_current_state(@state); 
                _dryad_S2#4 := $current_state($s);
                // _math \state stmtexpr1#22; 
                // stmtexpr1#22 := _dryad_S2#4; 
                stmtexpr1#22 := _dryad_S2#4;
                // assert @prim_writes_check((x->left)); 
                assert $writable_prim($s, #wrTime$3^5.3, $dot($phys_ptr_cast(P#x, ^b_node), b_node.left));
                // *(x->left) := lr; 
                call $write_int(b_node.left, $phys_ptr_cast(P#x, ^b_node), $ptr_to_int($phys_ptr_cast(L#lr, ^b_node)));
                assume $full_stop_ext(#tok$3^60.9, $s);
                // _math \state _dryad_S3#5; 
                // _dryad_S3#5 := @_vcc_current_state(@state); 
                _dryad_S3#5 := $current_state($s);
                // _math \state stmtexpr2#23; 
                // stmtexpr2#23 := _dryad_S3#5; 
                stmtexpr2#23 := _dryad_S3#5;
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(*((x->right)))))), ==(old(_dryad_S2#4, treap(*((x->right)))), old(_dryad_S3#5, treap(*((x->right)))))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $rd_phys_ptr(_dryad_S2#4, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) ==> F#treap(_dryad_S2#4, $rd_phys_ptr(_dryad_S2#4, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) == F#treap(_dryad_S3#5, $rd_phys_ptr(_dryad_S3#5, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(*((x->right)))))), ==(old(_dryad_S2#4, treap_reach(*((x->right)))), old(_dryad_S3#5, treap_reach(*((x->right)))))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $rd_phys_ptr(_dryad_S2#4, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) ==> F#treap_reach(_dryad_S2#4, $rd_phys_ptr(_dryad_S2#4, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) == F#treap_reach(_dryad_S3#5, $rd_phys_ptr(_dryad_S3#5, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(*((x->right)))))), ==(old(_dryad_S2#4, treap_keys(*((x->right)))), old(_dryad_S3#5, treap_keys(*((x->right)))))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $rd_phys_ptr(_dryad_S2#4, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) ==> F#treap_keys(_dryad_S2#4, $rd_phys_ptr(_dryad_S2#4, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) == F#treap_keys(_dryad_S3#5, $rd_phys_ptr(_dryad_S3#5, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(*((x->right)))))), ==(old(_dryad_S2#4, treap_max_key(*((x->right)))), old(_dryad_S3#5, treap_max_key(*((x->right)))))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $rd_phys_ptr(_dryad_S2#4, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) ==> F#treap_max_key(_dryad_S2#4, $rd_phys_ptr(_dryad_S2#4, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) == F#treap_max_key(_dryad_S3#5, $rd_phys_ptr(_dryad_S3#5, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(*((x->right)))))), ==(old(_dryad_S2#4, treap_max_prio(*((x->right)))), old(_dryad_S3#5, treap_max_prio(*((x->right)))))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $rd_phys_ptr(_dryad_S2#4, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) ==> F#treap_max_prio(_dryad_S2#4, $rd_phys_ptr(_dryad_S2#4, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) == F#treap_max_prio(_dryad_S3#5, $rd_phys_ptr(_dryad_S3#5, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(*((x->right)))))), ==(old(_dryad_S2#4, treap_min_key(*((x->right)))), old(_dryad_S3#5, treap_min_key(*((x->right)))))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $rd_phys_ptr(_dryad_S2#4, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) ==> F#treap_min_key(_dryad_S2#4, $rd_phys_ptr(_dryad_S2#4, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) == F#treap_min_key(_dryad_S3#5, $rd_phys_ptr(_dryad_S3#5, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(*((x->right)))))), ==(old(_dryad_S2#4, treap_prios(*((x->right)))), old(_dryad_S3#5, treap_prios(*((x->right)))))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $rd_phys_ptr(_dryad_S2#4, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) ==> F#treap_prios(_dryad_S2#4, $rd_phys_ptr(_dryad_S2#4, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) == F#treap_prios(_dryad_S3#5, $rd_phys_ptr(_dryad_S3#5, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(tmp2)))), ==(old(_dryad_S2#4, treap(tmp2)), old(_dryad_S3#5, treap(tmp2)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $phys_ptr_cast(SL#tmp2, ^b_node))) ==> F#treap(_dryad_S2#4, $phys_ptr_cast(SL#tmp2, ^b_node)) == F#treap(_dryad_S3#5, $phys_ptr_cast(SL#tmp2, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(tmp2)))), ==(old(_dryad_S2#4, treap_reach(tmp2)), old(_dryad_S3#5, treap_reach(tmp2)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $phys_ptr_cast(SL#tmp2, ^b_node))) ==> F#treap_reach(_dryad_S2#4, $phys_ptr_cast(SL#tmp2, ^b_node)) == F#treap_reach(_dryad_S3#5, $phys_ptr_cast(SL#tmp2, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(tmp2)))), ==(old(_dryad_S2#4, treap_keys(tmp2)), old(_dryad_S3#5, treap_keys(tmp2)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $phys_ptr_cast(SL#tmp2, ^b_node))) ==> F#treap_keys(_dryad_S2#4, $phys_ptr_cast(SL#tmp2, ^b_node)) == F#treap_keys(_dryad_S3#5, $phys_ptr_cast(SL#tmp2, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(tmp2)))), ==(old(_dryad_S2#4, treap_max_key(tmp2)), old(_dryad_S3#5, treap_max_key(tmp2)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $phys_ptr_cast(SL#tmp2, ^b_node))) ==> F#treap_max_key(_dryad_S2#4, $phys_ptr_cast(SL#tmp2, ^b_node)) == F#treap_max_key(_dryad_S3#5, $phys_ptr_cast(SL#tmp2, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(tmp2)))), ==(old(_dryad_S2#4, treap_max_prio(tmp2)), old(_dryad_S3#5, treap_max_prio(tmp2)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $phys_ptr_cast(SL#tmp2, ^b_node))) ==> F#treap_max_prio(_dryad_S2#4, $phys_ptr_cast(SL#tmp2, ^b_node)) == F#treap_max_prio(_dryad_S3#5, $phys_ptr_cast(SL#tmp2, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(tmp2)))), ==(old(_dryad_S2#4, treap_min_key(tmp2)), old(_dryad_S3#5, treap_min_key(tmp2)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $phys_ptr_cast(SL#tmp2, ^b_node))) ==> F#treap_min_key(_dryad_S2#4, $phys_ptr_cast(SL#tmp2, ^b_node)) == F#treap_min_key(_dryad_S3#5, $phys_ptr_cast(SL#tmp2, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(tmp2)))), ==(old(_dryad_S2#4, treap_prios(tmp2)), old(_dryad_S3#5, treap_prios(tmp2)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $phys_ptr_cast(SL#tmp2, ^b_node))) ==> F#treap_prios(_dryad_S2#4, $phys_ptr_cast(SL#tmp2, ^b_node)) == F#treap_prios(_dryad_S3#5, $phys_ptr_cast(SL#tmp2, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(lr)))), ==(old(_dryad_S2#4, treap(lr)), old(_dryad_S3#5, treap(lr)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $phys_ptr_cast(L#lr, ^b_node))) ==> F#treap(_dryad_S2#4, $phys_ptr_cast(L#lr, ^b_node)) == F#treap(_dryad_S3#5, $phys_ptr_cast(L#lr, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(lr)))), ==(old(_dryad_S2#4, treap_reach(lr)), old(_dryad_S3#5, treap_reach(lr)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $phys_ptr_cast(L#lr, ^b_node))) ==> F#treap_reach(_dryad_S2#4, $phys_ptr_cast(L#lr, ^b_node)) == F#treap_reach(_dryad_S3#5, $phys_ptr_cast(L#lr, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(lr)))), ==(old(_dryad_S2#4, treap_keys(lr)), old(_dryad_S3#5, treap_keys(lr)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $phys_ptr_cast(L#lr, ^b_node))) ==> F#treap_keys(_dryad_S2#4, $phys_ptr_cast(L#lr, ^b_node)) == F#treap_keys(_dryad_S3#5, $phys_ptr_cast(L#lr, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(lr)))), ==(old(_dryad_S2#4, treap_max_key(lr)), old(_dryad_S3#5, treap_max_key(lr)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $phys_ptr_cast(L#lr, ^b_node))) ==> F#treap_max_key(_dryad_S2#4, $phys_ptr_cast(L#lr, ^b_node)) == F#treap_max_key(_dryad_S3#5, $phys_ptr_cast(L#lr, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(lr)))), ==(old(_dryad_S2#4, treap_max_prio(lr)), old(_dryad_S3#5, treap_max_prio(lr)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $phys_ptr_cast(L#lr, ^b_node))) ==> F#treap_max_prio(_dryad_S2#4, $phys_ptr_cast(L#lr, ^b_node)) == F#treap_max_prio(_dryad_S3#5, $phys_ptr_cast(L#lr, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(lr)))), ==(old(_dryad_S2#4, treap_min_key(lr)), old(_dryad_S3#5, treap_min_key(lr)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $phys_ptr_cast(L#lr, ^b_node))) ==> F#treap_min_key(_dryad_S2#4, $phys_ptr_cast(L#lr, ^b_node)) == F#treap_min_key(_dryad_S3#5, $phys_ptr_cast(L#lr, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(lr)))), ==(old(_dryad_S2#4, treap_prios(lr)), old(_dryad_S3#5, treap_prios(lr)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $phys_ptr_cast(L#lr, ^b_node))) ==> F#treap_prios(_dryad_S2#4, $phys_ptr_cast(L#lr, ^b_node)) == F#treap_prios(_dryad_S3#5, $phys_ptr_cast(L#lr, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(x1)))), ==(old(_dryad_S2#4, treap(x1)), old(_dryad_S3#5, treap(x1)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $phys_ptr_cast(SL#x1, ^b_node))) ==> F#treap(_dryad_S2#4, $phys_ptr_cast(SL#x1, ^b_node)) == F#treap(_dryad_S3#5, $phys_ptr_cast(SL#x1, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(x1)))), ==(old(_dryad_S2#4, treap_reach(x1)), old(_dryad_S3#5, treap_reach(x1)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $phys_ptr_cast(SL#x1, ^b_node))) ==> F#treap_reach(_dryad_S2#4, $phys_ptr_cast(SL#x1, ^b_node)) == F#treap_reach(_dryad_S3#5, $phys_ptr_cast(SL#x1, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(x1)))), ==(old(_dryad_S2#4, treap_keys(x1)), old(_dryad_S3#5, treap_keys(x1)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $phys_ptr_cast(SL#x1, ^b_node))) ==> F#treap_keys(_dryad_S2#4, $phys_ptr_cast(SL#x1, ^b_node)) == F#treap_keys(_dryad_S3#5, $phys_ptr_cast(SL#x1, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(x1)))), ==(old(_dryad_S2#4, treap_max_key(x1)), old(_dryad_S3#5, treap_max_key(x1)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $phys_ptr_cast(SL#x1, ^b_node))) ==> F#treap_max_key(_dryad_S2#4, $phys_ptr_cast(SL#x1, ^b_node)) == F#treap_max_key(_dryad_S3#5, $phys_ptr_cast(SL#x1, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(x1)))), ==(old(_dryad_S2#4, treap_max_prio(x1)), old(_dryad_S3#5, treap_max_prio(x1)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $phys_ptr_cast(SL#x1, ^b_node))) ==> F#treap_max_prio(_dryad_S2#4, $phys_ptr_cast(SL#x1, ^b_node)) == F#treap_max_prio(_dryad_S3#5, $phys_ptr_cast(SL#x1, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(x1)))), ==(old(_dryad_S2#4, treap_min_key(x1)), old(_dryad_S3#5, treap_min_key(x1)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $phys_ptr_cast(SL#x1, ^b_node))) ==> F#treap_min_key(_dryad_S2#4, $phys_ptr_cast(SL#x1, ^b_node)) == F#treap_min_key(_dryad_S3#5, $phys_ptr_cast(SL#x1, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(x1)))), ==(old(_dryad_S2#4, treap_prios(x1)), old(_dryad_S3#5, treap_prios(x1)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $phys_ptr_cast(SL#x1, ^b_node))) ==> F#treap_prios(_dryad_S2#4, $phys_ptr_cast(SL#x1, ^b_node)) == F#treap_prios(_dryad_S3#5, $phys_ptr_cast(SL#x1, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(x0)))), ==(old(_dryad_S2#4, treap(x0)), old(_dryad_S3#5, treap(x0)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $phys_ptr_cast(SL#x0, ^b_node))) ==> F#treap(_dryad_S2#4, $phys_ptr_cast(SL#x0, ^b_node)) == F#treap(_dryad_S3#5, $phys_ptr_cast(SL#x0, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(x0)))), ==(old(_dryad_S2#4, treap_reach(x0)), old(_dryad_S3#5, treap_reach(x0)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $phys_ptr_cast(SL#x0, ^b_node))) ==> F#treap_reach(_dryad_S2#4, $phys_ptr_cast(SL#x0, ^b_node)) == F#treap_reach(_dryad_S3#5, $phys_ptr_cast(SL#x0, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(x0)))), ==(old(_dryad_S2#4, treap_keys(x0)), old(_dryad_S3#5, treap_keys(x0)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $phys_ptr_cast(SL#x0, ^b_node))) ==> F#treap_keys(_dryad_S2#4, $phys_ptr_cast(SL#x0, ^b_node)) == F#treap_keys(_dryad_S3#5, $phys_ptr_cast(SL#x0, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(x0)))), ==(old(_dryad_S2#4, treap_max_key(x0)), old(_dryad_S3#5, treap_max_key(x0)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $phys_ptr_cast(SL#x0, ^b_node))) ==> F#treap_max_key(_dryad_S2#4, $phys_ptr_cast(SL#x0, ^b_node)) == F#treap_max_key(_dryad_S3#5, $phys_ptr_cast(SL#x0, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(x0)))), ==(old(_dryad_S2#4, treap_max_prio(x0)), old(_dryad_S3#5, treap_max_prio(x0)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $phys_ptr_cast(SL#x0, ^b_node))) ==> F#treap_max_prio(_dryad_S2#4, $phys_ptr_cast(SL#x0, ^b_node)) == F#treap_max_prio(_dryad_S3#5, $phys_ptr_cast(SL#x0, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(x0)))), ==(old(_dryad_S2#4, treap_min_key(x0)), old(_dryad_S3#5, treap_min_key(x0)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $phys_ptr_cast(SL#x0, ^b_node))) ==> F#treap_min_key(_dryad_S2#4, $phys_ptr_cast(SL#x0, ^b_node)) == F#treap_min_key(_dryad_S3#5, $phys_ptr_cast(SL#x0, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(x0)))), ==(old(_dryad_S2#4, treap_prios(x0)), old(_dryad_S3#5, treap_prios(x0)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $phys_ptr_cast(SL#x0, ^b_node))) ==> F#treap_prios(_dryad_S2#4, $phys_ptr_cast(SL#x0, ^b_node)) == F#treap_prios(_dryad_S3#5, $phys_ptr_cast(SL#x0, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(xr)))), ==(old(_dryad_S2#4, treap(xr)), old(_dryad_S3#5, treap(xr)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $phys_ptr_cast(L#xr, ^b_node))) ==> F#treap(_dryad_S2#4, $phys_ptr_cast(L#xr, ^b_node)) == F#treap(_dryad_S3#5, $phys_ptr_cast(L#xr, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(xr)))), ==(old(_dryad_S2#4, treap_reach(xr)), old(_dryad_S3#5, treap_reach(xr)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $phys_ptr_cast(L#xr, ^b_node))) ==> F#treap_reach(_dryad_S2#4, $phys_ptr_cast(L#xr, ^b_node)) == F#treap_reach(_dryad_S3#5, $phys_ptr_cast(L#xr, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(xr)))), ==(old(_dryad_S2#4, treap_keys(xr)), old(_dryad_S3#5, treap_keys(xr)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $phys_ptr_cast(L#xr, ^b_node))) ==> F#treap_keys(_dryad_S2#4, $phys_ptr_cast(L#xr, ^b_node)) == F#treap_keys(_dryad_S3#5, $phys_ptr_cast(L#xr, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(xr)))), ==(old(_dryad_S2#4, treap_max_key(xr)), old(_dryad_S3#5, treap_max_key(xr)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $phys_ptr_cast(L#xr, ^b_node))) ==> F#treap_max_key(_dryad_S2#4, $phys_ptr_cast(L#xr, ^b_node)) == F#treap_max_key(_dryad_S3#5, $phys_ptr_cast(L#xr, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(xr)))), ==(old(_dryad_S2#4, treap_max_prio(xr)), old(_dryad_S3#5, treap_max_prio(xr)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $phys_ptr_cast(L#xr, ^b_node))) ==> F#treap_max_prio(_dryad_S2#4, $phys_ptr_cast(L#xr, ^b_node)) == F#treap_max_prio(_dryad_S3#5, $phys_ptr_cast(L#xr, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(xr)))), ==(old(_dryad_S2#4, treap_min_key(xr)), old(_dryad_S3#5, treap_min_key(xr)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $phys_ptr_cast(L#xr, ^b_node))) ==> F#treap_min_key(_dryad_S2#4, $phys_ptr_cast(L#xr, ^b_node)) == F#treap_min_key(_dryad_S3#5, $phys_ptr_cast(L#xr, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(xr)))), ==(old(_dryad_S2#4, treap_prios(xr)), old(_dryad_S3#5, treap_prios(xr)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $phys_ptr_cast(L#xr, ^b_node))) ==> F#treap_prios(_dryad_S2#4, $phys_ptr_cast(L#xr, ^b_node)) == F#treap_prios(_dryad_S3#5, $phys_ptr_cast(L#xr, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(xl)))), ==(old(_dryad_S2#4, treap(xl)), old(_dryad_S3#5, treap(xl)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $phys_ptr_cast(L#xl, ^b_node))) ==> F#treap(_dryad_S2#4, $phys_ptr_cast(L#xl, ^b_node)) == F#treap(_dryad_S3#5, $phys_ptr_cast(L#xl, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(xl)))), ==(old(_dryad_S2#4, treap_reach(xl)), old(_dryad_S3#5, treap_reach(xl)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $phys_ptr_cast(L#xl, ^b_node))) ==> F#treap_reach(_dryad_S2#4, $phys_ptr_cast(L#xl, ^b_node)) == F#treap_reach(_dryad_S3#5, $phys_ptr_cast(L#xl, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(xl)))), ==(old(_dryad_S2#4, treap_keys(xl)), old(_dryad_S3#5, treap_keys(xl)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $phys_ptr_cast(L#xl, ^b_node))) ==> F#treap_keys(_dryad_S2#4, $phys_ptr_cast(L#xl, ^b_node)) == F#treap_keys(_dryad_S3#5, $phys_ptr_cast(L#xl, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(xl)))), ==(old(_dryad_S2#4, treap_max_key(xl)), old(_dryad_S3#5, treap_max_key(xl)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $phys_ptr_cast(L#xl, ^b_node))) ==> F#treap_max_key(_dryad_S2#4, $phys_ptr_cast(L#xl, ^b_node)) == F#treap_max_key(_dryad_S3#5, $phys_ptr_cast(L#xl, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(xl)))), ==(old(_dryad_S2#4, treap_max_prio(xl)), old(_dryad_S3#5, treap_max_prio(xl)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $phys_ptr_cast(L#xl, ^b_node))) ==> F#treap_max_prio(_dryad_S2#4, $phys_ptr_cast(L#xl, ^b_node)) == F#treap_max_prio(_dryad_S3#5, $phys_ptr_cast(L#xl, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(xl)))), ==(old(_dryad_S2#4, treap_min_key(xl)), old(_dryad_S3#5, treap_min_key(xl)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $phys_ptr_cast(L#xl, ^b_node))) ==> F#treap_min_key(_dryad_S2#4, $phys_ptr_cast(L#xl, ^b_node)) == F#treap_min_key(_dryad_S3#5, $phys_ptr_cast(L#xl, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(xl)))), ==(old(_dryad_S2#4, treap_prios(xl)), old(_dryad_S3#5, treap_prios(xl)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $phys_ptr_cast(L#xl, ^b_node))) ==> F#treap_prios(_dryad_S2#4, $phys_ptr_cast(L#xl, ^b_node)) == F#treap_prios(_dryad_S3#5, $phys_ptr_cast(L#xl, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(tmp)))), ==(old(_dryad_S2#4, treap(tmp)), old(_dryad_S3#5, treap(tmp)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $phys_ptr_cast(L#tmp, ^b_node))) ==> F#treap(_dryad_S2#4, $phys_ptr_cast(L#tmp, ^b_node)) == F#treap(_dryad_S3#5, $phys_ptr_cast(L#tmp, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(tmp)))), ==(old(_dryad_S2#4, treap_reach(tmp)), old(_dryad_S3#5, treap_reach(tmp)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $phys_ptr_cast(L#tmp, ^b_node))) ==> F#treap_reach(_dryad_S2#4, $phys_ptr_cast(L#tmp, ^b_node)) == F#treap_reach(_dryad_S3#5, $phys_ptr_cast(L#tmp, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(tmp)))), ==(old(_dryad_S2#4, treap_keys(tmp)), old(_dryad_S3#5, treap_keys(tmp)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $phys_ptr_cast(L#tmp, ^b_node))) ==> F#treap_keys(_dryad_S2#4, $phys_ptr_cast(L#tmp, ^b_node)) == F#treap_keys(_dryad_S3#5, $phys_ptr_cast(L#tmp, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(tmp)))), ==(old(_dryad_S2#4, treap_max_key(tmp)), old(_dryad_S3#5, treap_max_key(tmp)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $phys_ptr_cast(L#tmp, ^b_node))) ==> F#treap_max_key(_dryad_S2#4, $phys_ptr_cast(L#tmp, ^b_node)) == F#treap_max_key(_dryad_S3#5, $phys_ptr_cast(L#tmp, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(tmp)))), ==(old(_dryad_S2#4, treap_max_prio(tmp)), old(_dryad_S3#5, treap_max_prio(tmp)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $phys_ptr_cast(L#tmp, ^b_node))) ==> F#treap_max_prio(_dryad_S2#4, $phys_ptr_cast(L#tmp, ^b_node)) == F#treap_max_prio(_dryad_S3#5, $phys_ptr_cast(L#tmp, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(tmp)))), ==(old(_dryad_S2#4, treap_min_key(tmp)), old(_dryad_S3#5, treap_min_key(tmp)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $phys_ptr_cast(L#tmp, ^b_node))) ==> F#treap_min_key(_dryad_S2#4, $phys_ptr_cast(L#tmp, ^b_node)) == F#treap_min_key(_dryad_S3#5, $phys_ptr_cast(L#tmp, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#4, treap_reach(tmp)))), ==(old(_dryad_S2#4, treap_prios(tmp)), old(_dryad_S3#5, treap_prios(tmp)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#4, $phys_ptr_cast(L#tmp, ^b_node))) ==> F#treap_prios(_dryad_S2#4, $phys_ptr_cast(L#tmp, ^b_node)) == F#treap_prios(_dryad_S3#5, $phys_ptr_cast(L#tmp, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(x, tmp2)), @_vcc_ptr_eq_pure(*((tmp2->left)), old(_dryad_S2#4, *((tmp2->left))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(SL#tmp2, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#4, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(x, tmp2)), @_vcc_ptr_eq_pure(*((tmp2->right)), old(_dryad_S2#4, *((tmp2->right))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(SL#tmp2, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#4, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(x, tmp2)), ==(*((tmp2->key)), old(_dryad_S2#4, *((tmp2->key))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(SL#tmp2, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(SL#tmp2, ^b_node)) == $rd_inv(_dryad_S2#4, b_node.key, $phys_ptr_cast(SL#tmp2, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(x, tmp2)), ==(*((tmp2->prio)), old(_dryad_S2#4, *((tmp2->prio))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(SL#tmp2, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(SL#tmp2, ^b_node)) == $rd_inv(_dryad_S2#4, b_node.prio, $phys_ptr_cast(SL#tmp2, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(x, lr)), @_vcc_ptr_eq_pure(*((lr->left)), old(_dryad_S2#4, *((lr->left))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(L#lr, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#4, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(x, lr)), @_vcc_ptr_eq_pure(*((lr->right)), old(_dryad_S2#4, *((lr->right))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(L#lr, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#4, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(x, lr)), ==(*((lr->key)), old(_dryad_S2#4, *((lr->key))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(L#lr, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#lr, ^b_node)) == $rd_inv(_dryad_S2#4, b_node.key, $phys_ptr_cast(L#lr, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(x, lr)), ==(*((lr->prio)), old(_dryad_S2#4, *((lr->prio))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(L#lr, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(L#lr, ^b_node)) == $rd_inv(_dryad_S2#4, b_node.prio, $phys_ptr_cast(L#lr, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(x, x1)), @_vcc_ptr_eq_pure(*((x1->left)), old(_dryad_S2#4, *((x1->left))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(SL#x1, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#4, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(x, x1)), @_vcc_ptr_eq_pure(*((x1->right)), old(_dryad_S2#4, *((x1->right))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(SL#x1, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#4, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(x, x1)), ==(*((x1->key)), old(_dryad_S2#4, *((x1->key))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(SL#x1, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)) == $rd_inv(_dryad_S2#4, b_node.key, $phys_ptr_cast(SL#x1, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(x, x1)), ==(*((x1->prio)), old(_dryad_S2#4, *((x1->prio))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(SL#x1, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node)) == $rd_inv(_dryad_S2#4, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(x, x0)), @_vcc_ptr_eq_pure(*((x0->left)), old(_dryad_S2#4, *((x0->left))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(SL#x0, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#4, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(x, x0)), @_vcc_ptr_eq_pure(*((x0->right)), old(_dryad_S2#4, *((x0->right))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(SL#x0, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#4, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(x, x0)), ==(*((x0->key)), old(_dryad_S2#4, *((x0->key))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(SL#x0, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)) == $rd_inv(_dryad_S2#4, b_node.key, $phys_ptr_cast(SL#x0, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(x, x0)), ==(*((x0->prio)), old(_dryad_S2#4, *((x0->prio))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(SL#x0, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node)) == $rd_inv(_dryad_S2#4, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(x, xr)), @_vcc_ptr_eq_pure(*((xr->left)), old(_dryad_S2#4, *((xr->left))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(L#xr, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#4, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(x, xr)), @_vcc_ptr_eq_pure(*((xr->right)), old(_dryad_S2#4, *((xr->right))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(L#xr, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#4, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(x, xr)), ==(*((xr->key)), old(_dryad_S2#4, *((xr->key))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(L#xr, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)) == $rd_inv(_dryad_S2#4, b_node.key, $phys_ptr_cast(L#xr, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(x, xr)), ==(*((xr->prio)), old(_dryad_S2#4, *((xr->prio))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(L#xr, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node)) == $rd_inv(_dryad_S2#4, b_node.prio, $phys_ptr_cast(L#xr, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(x, xl)), @_vcc_ptr_eq_pure(*((xl->left)), old(_dryad_S2#4, *((xl->left))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(L#xl, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#4, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(x, xl)), @_vcc_ptr_eq_pure(*((xl->right)), old(_dryad_S2#4, *((xl->right))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(L#xl, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#4, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(x, xl)), ==(*((xl->key)), old(_dryad_S2#4, *((xl->key))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(L#xl, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)) == $rd_inv(_dryad_S2#4, b_node.key, $phys_ptr_cast(L#xl, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(x, xl)), ==(*((xl->prio)), old(_dryad_S2#4, *((xl->prio))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(L#xl, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node)) == $rd_inv(_dryad_S2#4, b_node.prio, $phys_ptr_cast(L#xl, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(x, tmp)), @_vcc_ptr_eq_pure(*((tmp->left)), old(_dryad_S2#4, *((tmp->left))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(L#tmp, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#4, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(x, tmp)), @_vcc_ptr_eq_pure(*((tmp->right)), old(_dryad_S2#4, *((tmp->right))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(L#tmp, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#4, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(x, tmp)), ==(*((tmp->key)), old(_dryad_S2#4, *((tmp->key))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(L#tmp, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)) == $rd_inv(_dryad_S2#4, b_node.key, $phys_ptr_cast(L#tmp, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(x, tmp)), ==(*((tmp->prio)), old(_dryad_S2#4, *((tmp->prio))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(L#tmp, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node)) == $rd_inv(_dryad_S2#4, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node));
                // assume ==>(@_vcc_ptr_neq_null(tmp2), ==(treap(tmp2), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((tmp2->left))), treap(*((tmp2->right)))), unchecked!(@_vcc_oset_in(tmp2, @_vcc_oset_union(treap_reach(*((tmp2->left))), treap_reach(*((tmp2->right))))))), unchecked!(@_vcc_intset_in(*((tmp2->key)), @_vcc_intset_union(treap_keys(*((tmp2->left))), treap_keys(*((tmp2->right))))))), unchecked!(@_vcc_intset_in(*((tmp2->prio)), @_vcc_intset_union(treap_prios(*((tmp2->left))), treap_prios(*((tmp2->right))))))), @_vcc_oset_disjoint(treap_reach(*((tmp2->left))), treap_reach(*((tmp2->right))))), @_vcc_intset_disjoint(treap_keys(*((tmp2->left))), treap_keys(*((tmp2->right))))), @_vcc_intset_disjoint(treap_prios(*((tmp2->left))), treap_prios(*((tmp2->right))))), ==>(@_vcc_ptr_neq_null(*((tmp2->left))), <(treap_max_key(*((tmp2->left))), *((tmp2->key))))), ==>(@_vcc_ptr_neq_null(*((tmp2->right))), <(*((tmp2->key)), treap_min_key(*((tmp2->right)))))), ==>(@_vcc_ptr_neq_null(*((tmp2->left))), <(treap_max_prio(*((tmp2->left))), *((tmp2->prio))))), ==>(@_vcc_ptr_neq_null(*((tmp2->right))), <(treap_max_prio(*((tmp2->right))), *((tmp2->prio))))))); 
                assume $non_null($phys_ptr_cast(SL#tmp2, ^b_node)) ==> F#treap($s, $phys_ptr_cast(SL#tmp2, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(SL#tmp2, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(SL#tmp2, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#tmp2, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(SL#tmp2, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(SL#tmp2, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(SL#tmp2, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(SL#tmp2, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp2), ==(treap_reach(tmp2), @_vcc_oset_union(@_vcc_oset_singleton(tmp2), @_vcc_oset_union(treap_reach(*((tmp2->left))), treap_reach(*((tmp2->right))))))); 
                assume $non_null($phys_ptr_cast(SL#tmp2, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(SL#tmp2, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(SL#tmp2, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp2), ==(treap_keys(tmp2), @_vcc_intset_union(@_vcc_intset_singleton(*((tmp2->key))), @_vcc_intset_union(treap_keys(*((tmp2->left))), treap_keys(*((tmp2->right))))))); 
                assume $non_null($phys_ptr_cast(SL#tmp2, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(SL#tmp2, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(SL#tmp2, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp2), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp2->left))), @_vcc_ptr_neq_null(*((tmp2->right)))), ==(treap_max_key(tmp2), @\int_max(*((tmp2->key)), @\int_max(treap_max_key(*((tmp2->left))), treap_max_key(*((tmp2->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp2->left))), @_vcc_ptr_eq_null(*((tmp2->right)))), ==(treap_max_key(tmp2), @\int_max(*((tmp2->key)), treap_max_key(*((tmp2->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp2->left))), @_vcc_ptr_neq_null(*((tmp2->right)))), ==(treap_max_key(tmp2), @\int_max(*((tmp2->key)), treap_max_key(*((tmp2->right)))))))); 
                assume $non_null($phys_ptr_cast(SL#tmp2, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#tmp2, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#tmp2, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#tmp2, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#tmp2, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#tmp2, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#tmp2, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp2), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp2->left))), @_vcc_ptr_neq_null(*((tmp2->right)))), ==(treap_max_prio(tmp2), @\int_max(*((tmp2->prio)), @\int_max(treap_max_prio(*((tmp2->left))), treap_max_prio(*((tmp2->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp2->left))), @_vcc_ptr_eq_null(*((tmp2->right)))), ==(treap_max_prio(tmp2), @\int_max(*((tmp2->prio)), treap_max_prio(*((tmp2->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp2->left))), @_vcc_ptr_neq_null(*((tmp2->right)))), ==(treap_max_prio(tmp2), @\int_max(*((tmp2->prio)), treap_max_prio(*((tmp2->right)))))))); 
                assume $non_null($phys_ptr_cast(SL#tmp2, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#tmp2, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#tmp2, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#tmp2, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#tmp2, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#tmp2, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#tmp2, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp2), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp2->left))), @_vcc_ptr_neq_null(*((tmp2->right)))), ==(treap_min_key(tmp2), @\int_min(*((tmp2->key)), @\int_min(treap_min_key(*((tmp2->left))), treap_min_key(*((tmp2->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp2->left))), @_vcc_ptr_eq_null(*((tmp2->right)))), ==(treap_min_key(tmp2), @\int_min(*((tmp2->key)), treap_min_key(*((tmp2->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp2->left))), @_vcc_ptr_neq_null(*((tmp2->right)))), ==(treap_min_key(tmp2), @\int_min(*((tmp2->key)), treap_min_key(*((tmp2->right)))))))); 
                assume $non_null($phys_ptr_cast(SL#tmp2, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#tmp2, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#tmp2, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#tmp2, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#tmp2, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#tmp2, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#tmp2, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp2), ==(treap_prios(tmp2), @_vcc_intset_union(@_vcc_intset_singleton(*((tmp2->prio))), @_vcc_intset_union(treap_prios(*((tmp2->left))), treap_prios(*((tmp2->right))))))); 
                assume $non_null($phys_ptr_cast(SL#tmp2, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(SL#tmp2, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#tmp2, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(lr), ==(treap(lr), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((lr->left))), treap(*((lr->right)))), unchecked!(@_vcc_oset_in(lr, @_vcc_oset_union(treap_reach(*((lr->left))), treap_reach(*((lr->right))))))), unchecked!(@_vcc_intset_in(*((lr->key)), @_vcc_intset_union(treap_keys(*((lr->left))), treap_keys(*((lr->right))))))), unchecked!(@_vcc_intset_in(*((lr->prio)), @_vcc_intset_union(treap_prios(*((lr->left))), treap_prios(*((lr->right))))))), @_vcc_oset_disjoint(treap_reach(*((lr->left))), treap_reach(*((lr->right))))), @_vcc_intset_disjoint(treap_keys(*((lr->left))), treap_keys(*((lr->right))))), @_vcc_intset_disjoint(treap_prios(*((lr->left))), treap_prios(*((lr->right))))), ==>(@_vcc_ptr_neq_null(*((lr->left))), <(treap_max_key(*((lr->left))), *((lr->key))))), ==>(@_vcc_ptr_neq_null(*((lr->right))), <(*((lr->key)), treap_min_key(*((lr->right)))))), ==>(@_vcc_ptr_neq_null(*((lr->left))), <(treap_max_prio(*((lr->left))), *((lr->prio))))), ==>(@_vcc_ptr_neq_null(*((lr->right))), <(treap_max_prio(*((lr->right))), *((lr->prio))))))); 
                assume $non_null($phys_ptr_cast(L#lr, ^b_node)) ==> F#treap($s, $phys_ptr_cast(L#lr, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(L#lr, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(L#lr, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(L#lr, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(L#lr, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#lr, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#lr, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#lr, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(lr), ==(treap_reach(lr), @_vcc_oset_union(@_vcc_oset_singleton(lr), @_vcc_oset_union(treap_reach(*((lr->left))), treap_reach(*((lr->right))))))); 
                assume $non_null($phys_ptr_cast(L#lr, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(L#lr, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(L#lr, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(lr), ==(treap_keys(lr), @_vcc_intset_union(@_vcc_intset_singleton(*((lr->key))), @_vcc_intset_union(treap_keys(*((lr->left))), treap_keys(*((lr->right))))))); 
                assume $non_null($phys_ptr_cast(L#lr, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(L#lr, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(L#lr, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(lr), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((lr->left))), @_vcc_ptr_neq_null(*((lr->right)))), ==(treap_max_key(lr), @\int_max(*((lr->key)), @\int_max(treap_max_key(*((lr->left))), treap_max_key(*((lr->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((lr->left))), @_vcc_ptr_eq_null(*((lr->right)))), ==(treap_max_key(lr), @\int_max(*((lr->key)), treap_max_key(*((lr->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((lr->left))), @_vcc_ptr_neq_null(*((lr->right)))), ==(treap_max_key(lr), @\int_max(*((lr->key)), treap_max_key(*((lr->right)))))))); 
                assume $non_null($phys_ptr_cast(L#lr, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#lr, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#lr, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#lr, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#lr, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#lr, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#lr, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(lr), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((lr->left))), @_vcc_ptr_neq_null(*((lr->right)))), ==(treap_max_prio(lr), @\int_max(*((lr->prio)), @\int_max(treap_max_prio(*((lr->left))), treap_max_prio(*((lr->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((lr->left))), @_vcc_ptr_eq_null(*((lr->right)))), ==(treap_max_prio(lr), @\int_max(*((lr->prio)), treap_max_prio(*((lr->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((lr->left))), @_vcc_ptr_neq_null(*((lr->right)))), ==(treap_max_prio(lr), @\int_max(*((lr->prio)), treap_max_prio(*((lr->right)))))))); 
                assume $non_null($phys_ptr_cast(L#lr, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#lr, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#lr, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#lr, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#lr, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#lr, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#lr, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(lr), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((lr->left))), @_vcc_ptr_neq_null(*((lr->right)))), ==(treap_min_key(lr), @\int_min(*((lr->key)), @\int_min(treap_min_key(*((lr->left))), treap_min_key(*((lr->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((lr->left))), @_vcc_ptr_eq_null(*((lr->right)))), ==(treap_min_key(lr), @\int_min(*((lr->key)), treap_min_key(*((lr->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((lr->left))), @_vcc_ptr_neq_null(*((lr->right)))), ==(treap_min_key(lr), @\int_min(*((lr->key)), treap_min_key(*((lr->right)))))))); 
                assume $non_null($phys_ptr_cast(L#lr, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#lr, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#lr, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#lr, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#lr, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#lr, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#lr, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(lr), ==(treap_prios(lr), @_vcc_intset_union(@_vcc_intset_singleton(*((lr->prio))), @_vcc_intset_union(treap_prios(*((lr->left))), treap_prios(*((lr->right))))))); 
                assume $non_null($phys_ptr_cast(L#lr, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(L#lr, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(L#lr, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1), ==(treap(x1), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x1->left))), treap(*((x1->right)))), unchecked!(@_vcc_oset_in(x1, @_vcc_oset_union(treap_reach(*((x1->left))), treap_reach(*((x1->right))))))), unchecked!(@_vcc_intset_in(*((x1->key)), @_vcc_intset_union(treap_keys(*((x1->left))), treap_keys(*((x1->right))))))), unchecked!(@_vcc_intset_in(*((x1->prio)), @_vcc_intset_union(treap_prios(*((x1->left))), treap_prios(*((x1->right))))))), @_vcc_oset_disjoint(treap_reach(*((x1->left))), treap_reach(*((x1->right))))), @_vcc_intset_disjoint(treap_keys(*((x1->left))), treap_keys(*((x1->right))))), @_vcc_intset_disjoint(treap_prios(*((x1->left))), treap_prios(*((x1->right))))), ==>(@_vcc_ptr_neq_null(*((x1->left))), <(treap_max_key(*((x1->left))), *((x1->key))))), ==>(@_vcc_ptr_neq_null(*((x1->right))), <(*((x1->key)), treap_min_key(*((x1->right)))))), ==>(@_vcc_ptr_neq_null(*((x1->left))), <(treap_max_prio(*((x1->left))), *((x1->prio))))), ==>(@_vcc_ptr_neq_null(*((x1->right))), <(treap_max_prio(*((x1->right))), *((x1->prio))))))); 
                assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> F#treap($s, $phys_ptr_cast(SL#x1, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(SL#x1, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1), ==(treap_reach(x1), @_vcc_oset_union(@_vcc_oset_singleton(x1), @_vcc_oset_union(treap_reach(*((x1->left))), treap_reach(*((x1->right))))))); 
                assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(SL#x1, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(SL#x1, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1), ==(treap_keys(x1), @_vcc_intset_union(@_vcc_intset_singleton(*((x1->key))), @_vcc_intset_union(treap_keys(*((x1->left))), treap_keys(*((x1->right))))))); 
                assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(SL#x1, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x1->left))), @_vcc_ptr_neq_null(*((x1->right)))), ==(treap_max_key(x1), @\int_max(*((x1->key)), @\int_max(treap_max_key(*((x1->left))), treap_max_key(*((x1->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x1->left))), @_vcc_ptr_eq_null(*((x1->right)))), ==(treap_max_key(x1), @\int_max(*((x1->key)), treap_max_key(*((x1->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x1->left))), @_vcc_ptr_neq_null(*((x1->right)))), ==(treap_max_key(x1), @\int_max(*((x1->key)), treap_max_key(*((x1->right)))))))); 
                assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x1->left))), @_vcc_ptr_neq_null(*((x1->right)))), ==(treap_max_prio(x1), @\int_max(*((x1->prio)), @\int_max(treap_max_prio(*((x1->left))), treap_max_prio(*((x1->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x1->left))), @_vcc_ptr_eq_null(*((x1->right)))), ==(treap_max_prio(x1), @\int_max(*((x1->prio)), treap_max_prio(*((x1->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x1->left))), @_vcc_ptr_neq_null(*((x1->right)))), ==(treap_max_prio(x1), @\int_max(*((x1->prio)), treap_max_prio(*((x1->right)))))))); 
                assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x1->left))), @_vcc_ptr_neq_null(*((x1->right)))), ==(treap_min_key(x1), @\int_min(*((x1->key)), @\int_min(treap_min_key(*((x1->left))), treap_min_key(*((x1->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x1->left))), @_vcc_ptr_eq_null(*((x1->right)))), ==(treap_min_key(x1), @\int_min(*((x1->key)), treap_min_key(*((x1->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x1->left))), @_vcc_ptr_neq_null(*((x1->right)))), ==(treap_min_key(x1), @\int_min(*((x1->key)), treap_min_key(*((x1->right)))))))); 
                assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1), ==(treap_prios(x1), @_vcc_intset_union(@_vcc_intset_singleton(*((x1->prio))), @_vcc_intset_union(treap_prios(*((x1->left))), treap_prios(*((x1->right))))))); 
                assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(SL#x1, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0), ==(treap(x0), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x0->left))), treap(*((x0->right)))), unchecked!(@_vcc_oset_in(x0, @_vcc_oset_union(treap_reach(*((x0->left))), treap_reach(*((x0->right))))))), unchecked!(@_vcc_intset_in(*((x0->key)), @_vcc_intset_union(treap_keys(*((x0->left))), treap_keys(*((x0->right))))))), unchecked!(@_vcc_intset_in(*((x0->prio)), @_vcc_intset_union(treap_prios(*((x0->left))), treap_prios(*((x0->right))))))), @_vcc_oset_disjoint(treap_reach(*((x0->left))), treap_reach(*((x0->right))))), @_vcc_intset_disjoint(treap_keys(*((x0->left))), treap_keys(*((x0->right))))), @_vcc_intset_disjoint(treap_prios(*((x0->left))), treap_prios(*((x0->right))))), ==>(@_vcc_ptr_neq_null(*((x0->left))), <(treap_max_key(*((x0->left))), *((x0->key))))), ==>(@_vcc_ptr_neq_null(*((x0->right))), <(*((x0->key)), treap_min_key(*((x0->right)))))), ==>(@_vcc_ptr_neq_null(*((x0->left))), <(treap_max_prio(*((x0->left))), *((x0->prio))))), ==>(@_vcc_ptr_neq_null(*((x0->right))), <(treap_max_prio(*((x0->right))), *((x0->prio))))))); 
                assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> F#treap($s, $phys_ptr_cast(SL#x0, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(SL#x0, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0), ==(treap_reach(x0), @_vcc_oset_union(@_vcc_oset_singleton(x0), @_vcc_oset_union(treap_reach(*((x0->left))), treap_reach(*((x0->right))))))); 
                assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(SL#x0, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(SL#x0, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0), ==(treap_keys(x0), @_vcc_intset_union(@_vcc_intset_singleton(*((x0->key))), @_vcc_intset_union(treap_keys(*((x0->left))), treap_keys(*((x0->right))))))); 
                assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(SL#x0, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x0->left))), @_vcc_ptr_neq_null(*((x0->right)))), ==(treap_max_key(x0), @\int_max(*((x0->key)), @\int_max(treap_max_key(*((x0->left))), treap_max_key(*((x0->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x0->left))), @_vcc_ptr_eq_null(*((x0->right)))), ==(treap_max_key(x0), @\int_max(*((x0->key)), treap_max_key(*((x0->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x0->left))), @_vcc_ptr_neq_null(*((x0->right)))), ==(treap_max_key(x0), @\int_max(*((x0->key)), treap_max_key(*((x0->right)))))))); 
                assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x0->left))), @_vcc_ptr_neq_null(*((x0->right)))), ==(treap_max_prio(x0), @\int_max(*((x0->prio)), @\int_max(treap_max_prio(*((x0->left))), treap_max_prio(*((x0->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x0->left))), @_vcc_ptr_eq_null(*((x0->right)))), ==(treap_max_prio(x0), @\int_max(*((x0->prio)), treap_max_prio(*((x0->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x0->left))), @_vcc_ptr_neq_null(*((x0->right)))), ==(treap_max_prio(x0), @\int_max(*((x0->prio)), treap_max_prio(*((x0->right)))))))); 
                assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x0->left))), @_vcc_ptr_neq_null(*((x0->right)))), ==(treap_min_key(x0), @\int_min(*((x0->key)), @\int_min(treap_min_key(*((x0->left))), treap_min_key(*((x0->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x0->left))), @_vcc_ptr_eq_null(*((x0->right)))), ==(treap_min_key(x0), @\int_min(*((x0->key)), treap_min_key(*((x0->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x0->left))), @_vcc_ptr_neq_null(*((x0->right)))), ==(treap_min_key(x0), @\int_min(*((x0->key)), treap_min_key(*((x0->right)))))))); 
                assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0), ==(treap_prios(x0), @_vcc_intset_union(@_vcc_intset_singleton(*((x0->prio))), @_vcc_intset_union(treap_prios(*((x0->left))), treap_prios(*((x0->right))))))); 
                assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(SL#x0, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr), ==(treap(xr), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((xr->left))), treap(*((xr->right)))), unchecked!(@_vcc_oset_in(xr, @_vcc_oset_union(treap_reach(*((xr->left))), treap_reach(*((xr->right))))))), unchecked!(@_vcc_intset_in(*((xr->key)), @_vcc_intset_union(treap_keys(*((xr->left))), treap_keys(*((xr->right))))))), unchecked!(@_vcc_intset_in(*((xr->prio)), @_vcc_intset_union(treap_prios(*((xr->left))), treap_prios(*((xr->right))))))), @_vcc_oset_disjoint(treap_reach(*((xr->left))), treap_reach(*((xr->right))))), @_vcc_intset_disjoint(treap_keys(*((xr->left))), treap_keys(*((xr->right))))), @_vcc_intset_disjoint(treap_prios(*((xr->left))), treap_prios(*((xr->right))))), ==>(@_vcc_ptr_neq_null(*((xr->left))), <(treap_max_key(*((xr->left))), *((xr->key))))), ==>(@_vcc_ptr_neq_null(*((xr->right))), <(*((xr->key)), treap_min_key(*((xr->right)))))), ==>(@_vcc_ptr_neq_null(*((xr->left))), <(treap_max_prio(*((xr->left))), *((xr->prio))))), ==>(@_vcc_ptr_neq_null(*((xr->right))), <(treap_max_prio(*((xr->right))), *((xr->prio))))))); 
                assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> F#treap($s, $phys_ptr_cast(L#xr, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(L#xr, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr), ==(treap_reach(xr), @_vcc_oset_union(@_vcc_oset_singleton(xr), @_vcc_oset_union(treap_reach(*((xr->left))), treap_reach(*((xr->right))))))); 
                assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(L#xr, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(L#xr, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr), ==(treap_keys(xr), @_vcc_intset_union(@_vcc_intset_singleton(*((xr->key))), @_vcc_intset_union(treap_keys(*((xr->left))), treap_keys(*((xr->right))))))); 
                assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(L#xr, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_max_key(xr), @\int_max(*((xr->key)), @\int_max(treap_max_key(*((xr->left))), treap_max_key(*((xr->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_eq_null(*((xr->right)))), ==(treap_max_key(xr), @\int_max(*((xr->key)), treap_max_key(*((xr->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_max_key(xr), @\int_max(*((xr->key)), treap_max_key(*((xr->right)))))))); 
                assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_max_prio(xr), @\int_max(*((xr->prio)), @\int_max(treap_max_prio(*((xr->left))), treap_max_prio(*((xr->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_eq_null(*((xr->right)))), ==(treap_max_prio(xr), @\int_max(*((xr->prio)), treap_max_prio(*((xr->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_max_prio(xr), @\int_max(*((xr->prio)), treap_max_prio(*((xr->right)))))))); 
                assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_min_key(xr), @\int_min(*((xr->key)), @\int_min(treap_min_key(*((xr->left))), treap_min_key(*((xr->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_eq_null(*((xr->right)))), ==(treap_min_key(xr), @\int_min(*((xr->key)), treap_min_key(*((xr->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_min_key(xr), @\int_min(*((xr->key)), treap_min_key(*((xr->right)))))))); 
                assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr), ==(treap_prios(xr), @_vcc_intset_union(@_vcc_intset_singleton(*((xr->prio))), @_vcc_intset_union(treap_prios(*((xr->left))), treap_prios(*((xr->right))))))); 
                assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(L#xr, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl), ==(treap(xl), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((xl->left))), treap(*((xl->right)))), unchecked!(@_vcc_oset_in(xl, @_vcc_oset_union(treap_reach(*((xl->left))), treap_reach(*((xl->right))))))), unchecked!(@_vcc_intset_in(*((xl->key)), @_vcc_intset_union(treap_keys(*((xl->left))), treap_keys(*((xl->right))))))), unchecked!(@_vcc_intset_in(*((xl->prio)), @_vcc_intset_union(treap_prios(*((xl->left))), treap_prios(*((xl->right))))))), @_vcc_oset_disjoint(treap_reach(*((xl->left))), treap_reach(*((xl->right))))), @_vcc_intset_disjoint(treap_keys(*((xl->left))), treap_keys(*((xl->right))))), @_vcc_intset_disjoint(treap_prios(*((xl->left))), treap_prios(*((xl->right))))), ==>(@_vcc_ptr_neq_null(*((xl->left))), <(treap_max_key(*((xl->left))), *((xl->key))))), ==>(@_vcc_ptr_neq_null(*((xl->right))), <(*((xl->key)), treap_min_key(*((xl->right)))))), ==>(@_vcc_ptr_neq_null(*((xl->left))), <(treap_max_prio(*((xl->left))), *((xl->prio))))), ==>(@_vcc_ptr_neq_null(*((xl->right))), <(treap_max_prio(*((xl->right))), *((xl->prio))))))); 
                assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> F#treap($s, $phys_ptr_cast(L#xl, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(L#xl, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl), ==(treap_reach(xl), @_vcc_oset_union(@_vcc_oset_singleton(xl), @_vcc_oset_union(treap_reach(*((xl->left))), treap_reach(*((xl->right))))))); 
                assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(L#xl, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(L#xl, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl), ==(treap_keys(xl), @_vcc_intset_union(@_vcc_intset_singleton(*((xl->key))), @_vcc_intset_union(treap_keys(*((xl->left))), treap_keys(*((xl->right))))))); 
                assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(L#xl, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_max_key(xl), @\int_max(*((xl->key)), @\int_max(treap_max_key(*((xl->left))), treap_max_key(*((xl->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_eq_null(*((xl->right)))), ==(treap_max_key(xl), @\int_max(*((xl->key)), treap_max_key(*((xl->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_max_key(xl), @\int_max(*((xl->key)), treap_max_key(*((xl->right)))))))); 
                assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_max_prio(xl), @\int_max(*((xl->prio)), @\int_max(treap_max_prio(*((xl->left))), treap_max_prio(*((xl->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_eq_null(*((xl->right)))), ==(treap_max_prio(xl), @\int_max(*((xl->prio)), treap_max_prio(*((xl->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_max_prio(xl), @\int_max(*((xl->prio)), treap_max_prio(*((xl->right)))))))); 
                assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_min_key(xl), @\int_min(*((xl->key)), @\int_min(treap_min_key(*((xl->left))), treap_min_key(*((xl->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_eq_null(*((xl->right)))), ==(treap_min_key(xl), @\int_min(*((xl->key)), treap_min_key(*((xl->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_min_key(xl), @\int_min(*((xl->key)), treap_min_key(*((xl->right)))))))); 
                assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl), ==(treap_prios(xl), @_vcc_intset_union(@_vcc_intset_singleton(*((xl->prio))), @_vcc_intset_union(treap_prios(*((xl->left))), treap_prios(*((xl->right))))))); 
                assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(L#xl, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), ==(treap(tmp), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((tmp->left))), treap(*((tmp->right)))), unchecked!(@_vcc_oset_in(tmp, @_vcc_oset_union(treap_reach(*((tmp->left))), treap_reach(*((tmp->right))))))), unchecked!(@_vcc_intset_in(*((tmp->key)), @_vcc_intset_union(treap_keys(*((tmp->left))), treap_keys(*((tmp->right))))))), unchecked!(@_vcc_intset_in(*((tmp->prio)), @_vcc_intset_union(treap_prios(*((tmp->left))), treap_prios(*((tmp->right))))))), @_vcc_oset_disjoint(treap_reach(*((tmp->left))), treap_reach(*((tmp->right))))), @_vcc_intset_disjoint(treap_keys(*((tmp->left))), treap_keys(*((tmp->right))))), @_vcc_intset_disjoint(treap_prios(*((tmp->left))), treap_prios(*((tmp->right))))), ==>(@_vcc_ptr_neq_null(*((tmp->left))), <(treap_max_key(*((tmp->left))), *((tmp->key))))), ==>(@_vcc_ptr_neq_null(*((tmp->right))), <(*((tmp->key)), treap_min_key(*((tmp->right)))))), ==>(@_vcc_ptr_neq_null(*((tmp->left))), <(treap_max_prio(*((tmp->left))), *((tmp->prio))))), ==>(@_vcc_ptr_neq_null(*((tmp->right))), <(treap_max_prio(*((tmp->right))), *((tmp->prio))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> F#treap($s, $phys_ptr_cast(L#tmp, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(L#tmp, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), ==(treap_reach(tmp), @_vcc_oset_union(@_vcc_oset_singleton(tmp), @_vcc_oset_union(treap_reach(*((tmp->left))), treap_reach(*((tmp->right))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(L#tmp, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(L#tmp, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), ==(treap_keys(tmp), @_vcc_intset_union(@_vcc_intset_singleton(*((tmp->key))), @_vcc_intset_union(treap_keys(*((tmp->left))), treap_keys(*((tmp->right))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(L#tmp, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_max_key(tmp), @\int_max(*((tmp->key)), @\int_max(treap_max_key(*((tmp->left))), treap_max_key(*((tmp->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_eq_null(*((tmp->right)))), ==(treap_max_key(tmp), @\int_max(*((tmp->key)), treap_max_key(*((tmp->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_max_key(tmp), @\int_max(*((tmp->key)), treap_max_key(*((tmp->right)))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_max_prio(tmp), @\int_max(*((tmp->prio)), @\int_max(treap_max_prio(*((tmp->left))), treap_max_prio(*((tmp->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_eq_null(*((tmp->right)))), ==(treap_max_prio(tmp), @\int_max(*((tmp->prio)), treap_max_prio(*((tmp->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_max_prio(tmp), @\int_max(*((tmp->prio)), treap_max_prio(*((tmp->right)))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_min_key(tmp), @\int_min(*((tmp->key)), @\int_min(treap_min_key(*((tmp->left))), treap_min_key(*((tmp->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_eq_null(*((tmp->right)))), ==(treap_min_key(tmp), @\int_min(*((tmp->key)), treap_min_key(*((tmp->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_min_key(tmp), @\int_min(*((tmp->key)), treap_min_key(*((tmp->right)))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), ==(treap_prios(tmp), @_vcc_intset_union(@_vcc_intset_singleton(*((tmp->prio))), @_vcc_intset_union(treap_prios(*((tmp->left))), treap_prios(*((tmp->right))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(L#tmp, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), ==(treap(x), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x->left))), treap(*((x->right)))), unchecked!(@_vcc_oset_in(x, @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->key)), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->prio)), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))), @_vcc_oset_disjoint(treap_reach(*((x->left))), treap_reach(*((x->right))))), @_vcc_intset_disjoint(treap_keys(*((x->left))), treap_keys(*((x->right))))), @_vcc_intset_disjoint(treap_prios(*((x->left))), treap_prios(*((x->right))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_key(*((x->left))), *((x->key))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(*((x->key)), treap_min_key(*((x->right)))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_prio(*((x->left))), *((x->prio))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(treap_max_prio(*((x->right))), *((x->prio))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap($s, $phys_ptr_cast(P#x, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(P#x, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_reach(x), @_vcc_oset_union(@_vcc_oset_singleton(x), @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(P#x, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(P#x, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_keys(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->key))), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), @\int_max(treap_max_key(*((x->left))), treap_max_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->right)))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), @\int_max(treap_max_prio(*((x->left))), treap_max_prio(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->right)))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), @\int_min(treap_min_key(*((x->left))), treap_min_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->right)))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_prios(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->prio))), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(lr), ==(treap(lr), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((lr->left))), treap(*((lr->right)))), unchecked!(@_vcc_oset_in(lr, @_vcc_oset_union(treap_reach(*((lr->left))), treap_reach(*((lr->right))))))), unchecked!(@_vcc_intset_in(*((lr->key)), @_vcc_intset_union(treap_keys(*((lr->left))), treap_keys(*((lr->right))))))), unchecked!(@_vcc_intset_in(*((lr->prio)), @_vcc_intset_union(treap_prios(*((lr->left))), treap_prios(*((lr->right))))))), @_vcc_oset_disjoint(treap_reach(*((lr->left))), treap_reach(*((lr->right))))), @_vcc_intset_disjoint(treap_keys(*((lr->left))), treap_keys(*((lr->right))))), @_vcc_intset_disjoint(treap_prios(*((lr->left))), treap_prios(*((lr->right))))), ==>(@_vcc_ptr_neq_null(*((lr->left))), <(treap_max_key(*((lr->left))), *((lr->key))))), ==>(@_vcc_ptr_neq_null(*((lr->right))), <(*((lr->key)), treap_min_key(*((lr->right)))))), ==>(@_vcc_ptr_neq_null(*((lr->left))), <(treap_max_prio(*((lr->left))), *((lr->prio))))), ==>(@_vcc_ptr_neq_null(*((lr->right))), <(treap_max_prio(*((lr->right))), *((lr->prio))))))); 
                assume $non_null($phys_ptr_cast(L#lr, ^b_node)) ==> F#treap($s, $phys_ptr_cast(L#lr, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(L#lr, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(L#lr, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(L#lr, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(L#lr, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#lr, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#lr, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#lr, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(lr), ==(treap_reach(lr), @_vcc_oset_union(@_vcc_oset_singleton(lr), @_vcc_oset_union(treap_reach(*((lr->left))), treap_reach(*((lr->right))))))); 
                assume $non_null($phys_ptr_cast(L#lr, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(L#lr, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(L#lr, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(lr), ==(treap_keys(lr), @_vcc_intset_union(@_vcc_intset_singleton(*((lr->key))), @_vcc_intset_union(treap_keys(*((lr->left))), treap_keys(*((lr->right))))))); 
                assume $non_null($phys_ptr_cast(L#lr, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(L#lr, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(L#lr, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(lr), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((lr->left))), @_vcc_ptr_neq_null(*((lr->right)))), ==(treap_max_key(lr), @\int_max(*((lr->key)), @\int_max(treap_max_key(*((lr->left))), treap_max_key(*((lr->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((lr->left))), @_vcc_ptr_eq_null(*((lr->right)))), ==(treap_max_key(lr), @\int_max(*((lr->key)), treap_max_key(*((lr->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((lr->left))), @_vcc_ptr_neq_null(*((lr->right)))), ==(treap_max_key(lr), @\int_max(*((lr->key)), treap_max_key(*((lr->right)))))))); 
                assume $non_null($phys_ptr_cast(L#lr, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#lr, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#lr, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#lr, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#lr, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#lr, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#lr, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(lr), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((lr->left))), @_vcc_ptr_neq_null(*((lr->right)))), ==(treap_max_prio(lr), @\int_max(*((lr->prio)), @\int_max(treap_max_prio(*((lr->left))), treap_max_prio(*((lr->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((lr->left))), @_vcc_ptr_eq_null(*((lr->right)))), ==(treap_max_prio(lr), @\int_max(*((lr->prio)), treap_max_prio(*((lr->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((lr->left))), @_vcc_ptr_neq_null(*((lr->right)))), ==(treap_max_prio(lr), @\int_max(*((lr->prio)), treap_max_prio(*((lr->right)))))))); 
                assume $non_null($phys_ptr_cast(L#lr, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#lr, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#lr, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#lr, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#lr, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#lr, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#lr, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(lr), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((lr->left))), @_vcc_ptr_neq_null(*((lr->right)))), ==(treap_min_key(lr), @\int_min(*((lr->key)), @\int_min(treap_min_key(*((lr->left))), treap_min_key(*((lr->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((lr->left))), @_vcc_ptr_eq_null(*((lr->right)))), ==(treap_min_key(lr), @\int_min(*((lr->key)), treap_min_key(*((lr->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((lr->left))), @_vcc_ptr_neq_null(*((lr->right)))), ==(treap_min_key(lr), @\int_min(*((lr->key)), treap_min_key(*((lr->right)))))))); 
                assume $non_null($phys_ptr_cast(L#lr, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#lr, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#lr, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#lr, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#lr, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#lr, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#lr, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(lr), ==(treap_prios(lr), @_vcc_intset_union(@_vcc_intset_singleton(*((lr->prio))), @_vcc_intset_union(treap_prios(*((lr->left))), treap_prios(*((lr->right))))))); 
                assume $non_null($phys_ptr_cast(L#lr, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(L#lr, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(L#lr, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))));
                // _math \state _dryad_S4#6; 
                // _dryad_S4#6 := @_vcc_current_state(@state); 
                _dryad_S4#6 := $current_state($s);
                // _math \state stmtexpr3#24; 
                // stmtexpr3#24 := _dryad_S4#6; 
                stmtexpr3#24 := _dryad_S4#6;
                // assert @prim_writes_check((tmp->right)); 
                assert $writable_prim($s, #wrTime$3^5.3, $dot($phys_ptr_cast(L#tmp, ^b_node), b_node.right));
                // *(tmp->right) := x; 
                call $write_int(b_node.right, $phys_ptr_cast(L#tmp, ^b_node), $ptr_to_int($phys_ptr_cast(P#x, ^b_node)));
                assume $full_stop_ext(#tok$3^62.9, $s);
                // _math \state _dryad_S5#7; 
                // _dryad_S5#7 := @_vcc_current_state(@state); 
                _dryad_S5#7 := $current_state($s);
                // _math \state stmtexpr4#25; 
                // stmtexpr4#25 := _dryad_S5#7; 
                stmtexpr4#25 := _dryad_S5#7;
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(*((tmp->left)))))), ==(old(_dryad_S4#6, treap(*((tmp->left)))), old(_dryad_S5#7, treap(*((tmp->left)))))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $rd_phys_ptr(_dryad_S4#6, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))) ==> F#treap(_dryad_S4#6, $rd_phys_ptr(_dryad_S4#6, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) == F#treap(_dryad_S5#7, $rd_phys_ptr(_dryad_S5#7, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(*((tmp->left)))))), ==(old(_dryad_S4#6, treap_reach(*((tmp->left)))), old(_dryad_S5#7, treap_reach(*((tmp->left)))))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $rd_phys_ptr(_dryad_S4#6, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))) ==> F#treap_reach(_dryad_S4#6, $rd_phys_ptr(_dryad_S4#6, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) == F#treap_reach(_dryad_S5#7, $rd_phys_ptr(_dryad_S5#7, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(*((tmp->left)))))), ==(old(_dryad_S4#6, treap_keys(*((tmp->left)))), old(_dryad_S5#7, treap_keys(*((tmp->left)))))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $rd_phys_ptr(_dryad_S4#6, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))) ==> F#treap_keys(_dryad_S4#6, $rd_phys_ptr(_dryad_S4#6, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) == F#treap_keys(_dryad_S5#7, $rd_phys_ptr(_dryad_S5#7, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(*((tmp->left)))))), ==(old(_dryad_S4#6, treap_max_key(*((tmp->left)))), old(_dryad_S5#7, treap_max_key(*((tmp->left)))))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $rd_phys_ptr(_dryad_S4#6, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))) ==> F#treap_max_key(_dryad_S4#6, $rd_phys_ptr(_dryad_S4#6, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) == F#treap_max_key(_dryad_S5#7, $rd_phys_ptr(_dryad_S5#7, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(*((tmp->left)))))), ==(old(_dryad_S4#6, treap_max_prio(*((tmp->left)))), old(_dryad_S5#7, treap_max_prio(*((tmp->left)))))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $rd_phys_ptr(_dryad_S4#6, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))) ==> F#treap_max_prio(_dryad_S4#6, $rd_phys_ptr(_dryad_S4#6, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) == F#treap_max_prio(_dryad_S5#7, $rd_phys_ptr(_dryad_S5#7, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(*((tmp->left)))))), ==(old(_dryad_S4#6, treap_min_key(*((tmp->left)))), old(_dryad_S5#7, treap_min_key(*((tmp->left)))))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $rd_phys_ptr(_dryad_S4#6, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))) ==> F#treap_min_key(_dryad_S4#6, $rd_phys_ptr(_dryad_S4#6, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) == F#treap_min_key(_dryad_S5#7, $rd_phys_ptr(_dryad_S5#7, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(*((tmp->left)))))), ==(old(_dryad_S4#6, treap_prios(*((tmp->left)))), old(_dryad_S5#7, treap_prios(*((tmp->left)))))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $rd_phys_ptr(_dryad_S4#6, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))) ==> F#treap_prios(_dryad_S4#6, $rd_phys_ptr(_dryad_S4#6, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) == F#treap_prios(_dryad_S5#7, $rd_phys_ptr(_dryad_S5#7, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(tmp2)))), ==(old(_dryad_S4#6, treap(tmp2)), old(_dryad_S5#7, treap(tmp2)))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $phys_ptr_cast(SL#tmp2, ^b_node))) ==> F#treap(_dryad_S4#6, $phys_ptr_cast(SL#tmp2, ^b_node)) == F#treap(_dryad_S5#7, $phys_ptr_cast(SL#tmp2, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(tmp2)))), ==(old(_dryad_S4#6, treap_reach(tmp2)), old(_dryad_S5#7, treap_reach(tmp2)))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $phys_ptr_cast(SL#tmp2, ^b_node))) ==> F#treap_reach(_dryad_S4#6, $phys_ptr_cast(SL#tmp2, ^b_node)) == F#treap_reach(_dryad_S5#7, $phys_ptr_cast(SL#tmp2, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(tmp2)))), ==(old(_dryad_S4#6, treap_keys(tmp2)), old(_dryad_S5#7, treap_keys(tmp2)))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $phys_ptr_cast(SL#tmp2, ^b_node))) ==> F#treap_keys(_dryad_S4#6, $phys_ptr_cast(SL#tmp2, ^b_node)) == F#treap_keys(_dryad_S5#7, $phys_ptr_cast(SL#tmp2, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(tmp2)))), ==(old(_dryad_S4#6, treap_max_key(tmp2)), old(_dryad_S5#7, treap_max_key(tmp2)))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $phys_ptr_cast(SL#tmp2, ^b_node))) ==> F#treap_max_key(_dryad_S4#6, $phys_ptr_cast(SL#tmp2, ^b_node)) == F#treap_max_key(_dryad_S5#7, $phys_ptr_cast(SL#tmp2, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(tmp2)))), ==(old(_dryad_S4#6, treap_max_prio(tmp2)), old(_dryad_S5#7, treap_max_prio(tmp2)))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $phys_ptr_cast(SL#tmp2, ^b_node))) ==> F#treap_max_prio(_dryad_S4#6, $phys_ptr_cast(SL#tmp2, ^b_node)) == F#treap_max_prio(_dryad_S5#7, $phys_ptr_cast(SL#tmp2, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(tmp2)))), ==(old(_dryad_S4#6, treap_min_key(tmp2)), old(_dryad_S5#7, treap_min_key(tmp2)))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $phys_ptr_cast(SL#tmp2, ^b_node))) ==> F#treap_min_key(_dryad_S4#6, $phys_ptr_cast(SL#tmp2, ^b_node)) == F#treap_min_key(_dryad_S5#7, $phys_ptr_cast(SL#tmp2, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(tmp2)))), ==(old(_dryad_S4#6, treap_prios(tmp2)), old(_dryad_S5#7, treap_prios(tmp2)))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $phys_ptr_cast(SL#tmp2, ^b_node))) ==> F#treap_prios(_dryad_S4#6, $phys_ptr_cast(SL#tmp2, ^b_node)) == F#treap_prios(_dryad_S5#7, $phys_ptr_cast(SL#tmp2, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(lr)))), ==(old(_dryad_S4#6, treap(lr)), old(_dryad_S5#7, treap(lr)))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $phys_ptr_cast(L#lr, ^b_node))) ==> F#treap(_dryad_S4#6, $phys_ptr_cast(L#lr, ^b_node)) == F#treap(_dryad_S5#7, $phys_ptr_cast(L#lr, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(lr)))), ==(old(_dryad_S4#6, treap_reach(lr)), old(_dryad_S5#7, treap_reach(lr)))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $phys_ptr_cast(L#lr, ^b_node))) ==> F#treap_reach(_dryad_S4#6, $phys_ptr_cast(L#lr, ^b_node)) == F#treap_reach(_dryad_S5#7, $phys_ptr_cast(L#lr, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(lr)))), ==(old(_dryad_S4#6, treap_keys(lr)), old(_dryad_S5#7, treap_keys(lr)))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $phys_ptr_cast(L#lr, ^b_node))) ==> F#treap_keys(_dryad_S4#6, $phys_ptr_cast(L#lr, ^b_node)) == F#treap_keys(_dryad_S5#7, $phys_ptr_cast(L#lr, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(lr)))), ==(old(_dryad_S4#6, treap_max_key(lr)), old(_dryad_S5#7, treap_max_key(lr)))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $phys_ptr_cast(L#lr, ^b_node))) ==> F#treap_max_key(_dryad_S4#6, $phys_ptr_cast(L#lr, ^b_node)) == F#treap_max_key(_dryad_S5#7, $phys_ptr_cast(L#lr, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(lr)))), ==(old(_dryad_S4#6, treap_max_prio(lr)), old(_dryad_S5#7, treap_max_prio(lr)))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $phys_ptr_cast(L#lr, ^b_node))) ==> F#treap_max_prio(_dryad_S4#6, $phys_ptr_cast(L#lr, ^b_node)) == F#treap_max_prio(_dryad_S5#7, $phys_ptr_cast(L#lr, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(lr)))), ==(old(_dryad_S4#6, treap_min_key(lr)), old(_dryad_S5#7, treap_min_key(lr)))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $phys_ptr_cast(L#lr, ^b_node))) ==> F#treap_min_key(_dryad_S4#6, $phys_ptr_cast(L#lr, ^b_node)) == F#treap_min_key(_dryad_S5#7, $phys_ptr_cast(L#lr, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(lr)))), ==(old(_dryad_S4#6, treap_prios(lr)), old(_dryad_S5#7, treap_prios(lr)))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $phys_ptr_cast(L#lr, ^b_node))) ==> F#treap_prios(_dryad_S4#6, $phys_ptr_cast(L#lr, ^b_node)) == F#treap_prios(_dryad_S5#7, $phys_ptr_cast(L#lr, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(x1)))), ==(old(_dryad_S4#6, treap(x1)), old(_dryad_S5#7, treap(x1)))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $phys_ptr_cast(SL#x1, ^b_node))) ==> F#treap(_dryad_S4#6, $phys_ptr_cast(SL#x1, ^b_node)) == F#treap(_dryad_S5#7, $phys_ptr_cast(SL#x1, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(x1)))), ==(old(_dryad_S4#6, treap_reach(x1)), old(_dryad_S5#7, treap_reach(x1)))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $phys_ptr_cast(SL#x1, ^b_node))) ==> F#treap_reach(_dryad_S4#6, $phys_ptr_cast(SL#x1, ^b_node)) == F#treap_reach(_dryad_S5#7, $phys_ptr_cast(SL#x1, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(x1)))), ==(old(_dryad_S4#6, treap_keys(x1)), old(_dryad_S5#7, treap_keys(x1)))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $phys_ptr_cast(SL#x1, ^b_node))) ==> F#treap_keys(_dryad_S4#6, $phys_ptr_cast(SL#x1, ^b_node)) == F#treap_keys(_dryad_S5#7, $phys_ptr_cast(SL#x1, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(x1)))), ==(old(_dryad_S4#6, treap_max_key(x1)), old(_dryad_S5#7, treap_max_key(x1)))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $phys_ptr_cast(SL#x1, ^b_node))) ==> F#treap_max_key(_dryad_S4#6, $phys_ptr_cast(SL#x1, ^b_node)) == F#treap_max_key(_dryad_S5#7, $phys_ptr_cast(SL#x1, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(x1)))), ==(old(_dryad_S4#6, treap_max_prio(x1)), old(_dryad_S5#7, treap_max_prio(x1)))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $phys_ptr_cast(SL#x1, ^b_node))) ==> F#treap_max_prio(_dryad_S4#6, $phys_ptr_cast(SL#x1, ^b_node)) == F#treap_max_prio(_dryad_S5#7, $phys_ptr_cast(SL#x1, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(x1)))), ==(old(_dryad_S4#6, treap_min_key(x1)), old(_dryad_S5#7, treap_min_key(x1)))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $phys_ptr_cast(SL#x1, ^b_node))) ==> F#treap_min_key(_dryad_S4#6, $phys_ptr_cast(SL#x1, ^b_node)) == F#treap_min_key(_dryad_S5#7, $phys_ptr_cast(SL#x1, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(x1)))), ==(old(_dryad_S4#6, treap_prios(x1)), old(_dryad_S5#7, treap_prios(x1)))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $phys_ptr_cast(SL#x1, ^b_node))) ==> F#treap_prios(_dryad_S4#6, $phys_ptr_cast(SL#x1, ^b_node)) == F#treap_prios(_dryad_S5#7, $phys_ptr_cast(SL#x1, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(x0)))), ==(old(_dryad_S4#6, treap(x0)), old(_dryad_S5#7, treap(x0)))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $phys_ptr_cast(SL#x0, ^b_node))) ==> F#treap(_dryad_S4#6, $phys_ptr_cast(SL#x0, ^b_node)) == F#treap(_dryad_S5#7, $phys_ptr_cast(SL#x0, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(x0)))), ==(old(_dryad_S4#6, treap_reach(x0)), old(_dryad_S5#7, treap_reach(x0)))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $phys_ptr_cast(SL#x0, ^b_node))) ==> F#treap_reach(_dryad_S4#6, $phys_ptr_cast(SL#x0, ^b_node)) == F#treap_reach(_dryad_S5#7, $phys_ptr_cast(SL#x0, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(x0)))), ==(old(_dryad_S4#6, treap_keys(x0)), old(_dryad_S5#7, treap_keys(x0)))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $phys_ptr_cast(SL#x0, ^b_node))) ==> F#treap_keys(_dryad_S4#6, $phys_ptr_cast(SL#x0, ^b_node)) == F#treap_keys(_dryad_S5#7, $phys_ptr_cast(SL#x0, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(x0)))), ==(old(_dryad_S4#6, treap_max_key(x0)), old(_dryad_S5#7, treap_max_key(x0)))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $phys_ptr_cast(SL#x0, ^b_node))) ==> F#treap_max_key(_dryad_S4#6, $phys_ptr_cast(SL#x0, ^b_node)) == F#treap_max_key(_dryad_S5#7, $phys_ptr_cast(SL#x0, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(x0)))), ==(old(_dryad_S4#6, treap_max_prio(x0)), old(_dryad_S5#7, treap_max_prio(x0)))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $phys_ptr_cast(SL#x0, ^b_node))) ==> F#treap_max_prio(_dryad_S4#6, $phys_ptr_cast(SL#x0, ^b_node)) == F#treap_max_prio(_dryad_S5#7, $phys_ptr_cast(SL#x0, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(x0)))), ==(old(_dryad_S4#6, treap_min_key(x0)), old(_dryad_S5#7, treap_min_key(x0)))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $phys_ptr_cast(SL#x0, ^b_node))) ==> F#treap_min_key(_dryad_S4#6, $phys_ptr_cast(SL#x0, ^b_node)) == F#treap_min_key(_dryad_S5#7, $phys_ptr_cast(SL#x0, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(x0)))), ==(old(_dryad_S4#6, treap_prios(x0)), old(_dryad_S5#7, treap_prios(x0)))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $phys_ptr_cast(SL#x0, ^b_node))) ==> F#treap_prios(_dryad_S4#6, $phys_ptr_cast(SL#x0, ^b_node)) == F#treap_prios(_dryad_S5#7, $phys_ptr_cast(SL#x0, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(xr)))), ==(old(_dryad_S4#6, treap(xr)), old(_dryad_S5#7, treap(xr)))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $phys_ptr_cast(L#xr, ^b_node))) ==> F#treap(_dryad_S4#6, $phys_ptr_cast(L#xr, ^b_node)) == F#treap(_dryad_S5#7, $phys_ptr_cast(L#xr, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(xr)))), ==(old(_dryad_S4#6, treap_reach(xr)), old(_dryad_S5#7, treap_reach(xr)))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $phys_ptr_cast(L#xr, ^b_node))) ==> F#treap_reach(_dryad_S4#6, $phys_ptr_cast(L#xr, ^b_node)) == F#treap_reach(_dryad_S5#7, $phys_ptr_cast(L#xr, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(xr)))), ==(old(_dryad_S4#6, treap_keys(xr)), old(_dryad_S5#7, treap_keys(xr)))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $phys_ptr_cast(L#xr, ^b_node))) ==> F#treap_keys(_dryad_S4#6, $phys_ptr_cast(L#xr, ^b_node)) == F#treap_keys(_dryad_S5#7, $phys_ptr_cast(L#xr, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(xr)))), ==(old(_dryad_S4#6, treap_max_key(xr)), old(_dryad_S5#7, treap_max_key(xr)))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $phys_ptr_cast(L#xr, ^b_node))) ==> F#treap_max_key(_dryad_S4#6, $phys_ptr_cast(L#xr, ^b_node)) == F#treap_max_key(_dryad_S5#7, $phys_ptr_cast(L#xr, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(xr)))), ==(old(_dryad_S4#6, treap_max_prio(xr)), old(_dryad_S5#7, treap_max_prio(xr)))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $phys_ptr_cast(L#xr, ^b_node))) ==> F#treap_max_prio(_dryad_S4#6, $phys_ptr_cast(L#xr, ^b_node)) == F#treap_max_prio(_dryad_S5#7, $phys_ptr_cast(L#xr, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(xr)))), ==(old(_dryad_S4#6, treap_min_key(xr)), old(_dryad_S5#7, treap_min_key(xr)))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $phys_ptr_cast(L#xr, ^b_node))) ==> F#treap_min_key(_dryad_S4#6, $phys_ptr_cast(L#xr, ^b_node)) == F#treap_min_key(_dryad_S5#7, $phys_ptr_cast(L#xr, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(xr)))), ==(old(_dryad_S4#6, treap_prios(xr)), old(_dryad_S5#7, treap_prios(xr)))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $phys_ptr_cast(L#xr, ^b_node))) ==> F#treap_prios(_dryad_S4#6, $phys_ptr_cast(L#xr, ^b_node)) == F#treap_prios(_dryad_S5#7, $phys_ptr_cast(L#xr, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(xl)))), ==(old(_dryad_S4#6, treap(xl)), old(_dryad_S5#7, treap(xl)))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $phys_ptr_cast(L#xl, ^b_node))) ==> F#treap(_dryad_S4#6, $phys_ptr_cast(L#xl, ^b_node)) == F#treap(_dryad_S5#7, $phys_ptr_cast(L#xl, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(xl)))), ==(old(_dryad_S4#6, treap_reach(xl)), old(_dryad_S5#7, treap_reach(xl)))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $phys_ptr_cast(L#xl, ^b_node))) ==> F#treap_reach(_dryad_S4#6, $phys_ptr_cast(L#xl, ^b_node)) == F#treap_reach(_dryad_S5#7, $phys_ptr_cast(L#xl, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(xl)))), ==(old(_dryad_S4#6, treap_keys(xl)), old(_dryad_S5#7, treap_keys(xl)))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $phys_ptr_cast(L#xl, ^b_node))) ==> F#treap_keys(_dryad_S4#6, $phys_ptr_cast(L#xl, ^b_node)) == F#treap_keys(_dryad_S5#7, $phys_ptr_cast(L#xl, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(xl)))), ==(old(_dryad_S4#6, treap_max_key(xl)), old(_dryad_S5#7, treap_max_key(xl)))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $phys_ptr_cast(L#xl, ^b_node))) ==> F#treap_max_key(_dryad_S4#6, $phys_ptr_cast(L#xl, ^b_node)) == F#treap_max_key(_dryad_S5#7, $phys_ptr_cast(L#xl, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(xl)))), ==(old(_dryad_S4#6, treap_max_prio(xl)), old(_dryad_S5#7, treap_max_prio(xl)))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $phys_ptr_cast(L#xl, ^b_node))) ==> F#treap_max_prio(_dryad_S4#6, $phys_ptr_cast(L#xl, ^b_node)) == F#treap_max_prio(_dryad_S5#7, $phys_ptr_cast(L#xl, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(xl)))), ==(old(_dryad_S4#6, treap_min_key(xl)), old(_dryad_S5#7, treap_min_key(xl)))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $phys_ptr_cast(L#xl, ^b_node))) ==> F#treap_min_key(_dryad_S4#6, $phys_ptr_cast(L#xl, ^b_node)) == F#treap_min_key(_dryad_S5#7, $phys_ptr_cast(L#xl, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(xl)))), ==(old(_dryad_S4#6, treap_prios(xl)), old(_dryad_S5#7, treap_prios(xl)))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $phys_ptr_cast(L#xl, ^b_node))) ==> F#treap_prios(_dryad_S4#6, $phys_ptr_cast(L#xl, ^b_node)) == F#treap_prios(_dryad_S5#7, $phys_ptr_cast(L#xl, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(x)))), ==(old(_dryad_S4#6, treap(x)), old(_dryad_S5#7, treap(x)))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap(_dryad_S4#6, $phys_ptr_cast(P#x, ^b_node)) == F#treap(_dryad_S5#7, $phys_ptr_cast(P#x, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(x)))), ==(old(_dryad_S4#6, treap_reach(x)), old(_dryad_S5#7, treap_reach(x)))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_reach(_dryad_S4#6, $phys_ptr_cast(P#x, ^b_node)) == F#treap_reach(_dryad_S5#7, $phys_ptr_cast(P#x, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(x)))), ==(old(_dryad_S4#6, treap_keys(x)), old(_dryad_S5#7, treap_keys(x)))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_keys(_dryad_S4#6, $phys_ptr_cast(P#x, ^b_node)) == F#treap_keys(_dryad_S5#7, $phys_ptr_cast(P#x, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(x)))), ==(old(_dryad_S4#6, treap_max_key(x)), old(_dryad_S5#7, treap_max_key(x)))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_max_key(_dryad_S4#6, $phys_ptr_cast(P#x, ^b_node)) == F#treap_max_key(_dryad_S5#7, $phys_ptr_cast(P#x, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(x)))), ==(old(_dryad_S4#6, treap_max_prio(x)), old(_dryad_S5#7, treap_max_prio(x)))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_max_prio(_dryad_S4#6, $phys_ptr_cast(P#x, ^b_node)) == F#treap_max_prio(_dryad_S5#7, $phys_ptr_cast(P#x, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(x)))), ==(old(_dryad_S4#6, treap_min_key(x)), old(_dryad_S5#7, treap_min_key(x)))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_min_key(_dryad_S4#6, $phys_ptr_cast(P#x, ^b_node)) == F#treap_min_key(_dryad_S5#7, $phys_ptr_cast(P#x, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp, old(_dryad_S4#6, treap_reach(x)))), ==(old(_dryad_S4#6, treap_prios(x)), old(_dryad_S5#7, treap_prios(x)))); 
                assume !$oset_in($phys_ptr_cast(L#tmp, ^b_node), F#treap_reach(_dryad_S4#6, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_prios(_dryad_S4#6, $phys_ptr_cast(P#x, ^b_node)) == F#treap_prios(_dryad_S5#7, $phys_ptr_cast(P#x, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp, tmp2)), @_vcc_ptr_eq_pure(*((tmp2->left)), old(_dryad_S4#6, *((tmp2->left))))); 
                assume !($phys_ptr_cast(L#tmp, ^b_node) == $phys_ptr_cast(SL#tmp2, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S4#6, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp, tmp2)), @_vcc_ptr_eq_pure(*((tmp2->right)), old(_dryad_S4#6, *((tmp2->right))))); 
                assume !($phys_ptr_cast(L#tmp, ^b_node) == $phys_ptr_cast(SL#tmp2, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S4#6, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp, tmp2)), ==(*((tmp2->key)), old(_dryad_S4#6, *((tmp2->key))))); 
                assume !($phys_ptr_cast(L#tmp, ^b_node) == $phys_ptr_cast(SL#tmp2, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(SL#tmp2, ^b_node)) == $rd_inv(_dryad_S4#6, b_node.key, $phys_ptr_cast(SL#tmp2, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp, tmp2)), ==(*((tmp2->prio)), old(_dryad_S4#6, *((tmp2->prio))))); 
                assume !($phys_ptr_cast(L#tmp, ^b_node) == $phys_ptr_cast(SL#tmp2, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(SL#tmp2, ^b_node)) == $rd_inv(_dryad_S4#6, b_node.prio, $phys_ptr_cast(SL#tmp2, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp, lr)), @_vcc_ptr_eq_pure(*((lr->left)), old(_dryad_S4#6, *((lr->left))))); 
                assume !($phys_ptr_cast(L#tmp, ^b_node) == $phys_ptr_cast(L#lr, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S4#6, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp, lr)), @_vcc_ptr_eq_pure(*((lr->right)), old(_dryad_S4#6, *((lr->right))))); 
                assume !($phys_ptr_cast(L#tmp, ^b_node) == $phys_ptr_cast(L#lr, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S4#6, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp, lr)), ==(*((lr->key)), old(_dryad_S4#6, *((lr->key))))); 
                assume !($phys_ptr_cast(L#tmp, ^b_node) == $phys_ptr_cast(L#lr, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#lr, ^b_node)) == $rd_inv(_dryad_S4#6, b_node.key, $phys_ptr_cast(L#lr, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp, lr)), ==(*((lr->prio)), old(_dryad_S4#6, *((lr->prio))))); 
                assume !($phys_ptr_cast(L#tmp, ^b_node) == $phys_ptr_cast(L#lr, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(L#lr, ^b_node)) == $rd_inv(_dryad_S4#6, b_node.prio, $phys_ptr_cast(L#lr, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp, x1)), @_vcc_ptr_eq_pure(*((x1->left)), old(_dryad_S4#6, *((x1->left))))); 
                assume !($phys_ptr_cast(L#tmp, ^b_node) == $phys_ptr_cast(SL#x1, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S4#6, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp, x1)), @_vcc_ptr_eq_pure(*((x1->right)), old(_dryad_S4#6, *((x1->right))))); 
                assume !($phys_ptr_cast(L#tmp, ^b_node) == $phys_ptr_cast(SL#x1, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S4#6, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp, x1)), ==(*((x1->key)), old(_dryad_S4#6, *((x1->key))))); 
                assume !($phys_ptr_cast(L#tmp, ^b_node) == $phys_ptr_cast(SL#x1, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)) == $rd_inv(_dryad_S4#6, b_node.key, $phys_ptr_cast(SL#x1, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp, x1)), ==(*((x1->prio)), old(_dryad_S4#6, *((x1->prio))))); 
                assume !($phys_ptr_cast(L#tmp, ^b_node) == $phys_ptr_cast(SL#x1, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node)) == $rd_inv(_dryad_S4#6, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp, x0)), @_vcc_ptr_eq_pure(*((x0->left)), old(_dryad_S4#6, *((x0->left))))); 
                assume !($phys_ptr_cast(L#tmp, ^b_node) == $phys_ptr_cast(SL#x0, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S4#6, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp, x0)), @_vcc_ptr_eq_pure(*((x0->right)), old(_dryad_S4#6, *((x0->right))))); 
                assume !($phys_ptr_cast(L#tmp, ^b_node) == $phys_ptr_cast(SL#x0, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S4#6, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp, x0)), ==(*((x0->key)), old(_dryad_S4#6, *((x0->key))))); 
                assume !($phys_ptr_cast(L#tmp, ^b_node) == $phys_ptr_cast(SL#x0, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)) == $rd_inv(_dryad_S4#6, b_node.key, $phys_ptr_cast(SL#x0, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp, x0)), ==(*((x0->prio)), old(_dryad_S4#6, *((x0->prio))))); 
                assume !($phys_ptr_cast(L#tmp, ^b_node) == $phys_ptr_cast(SL#x0, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node)) == $rd_inv(_dryad_S4#6, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp, xr)), @_vcc_ptr_eq_pure(*((xr->left)), old(_dryad_S4#6, *((xr->left))))); 
                assume !($phys_ptr_cast(L#tmp, ^b_node) == $phys_ptr_cast(L#xr, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S4#6, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp, xr)), @_vcc_ptr_eq_pure(*((xr->right)), old(_dryad_S4#6, *((xr->right))))); 
                assume !($phys_ptr_cast(L#tmp, ^b_node) == $phys_ptr_cast(L#xr, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S4#6, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp, xr)), ==(*((xr->key)), old(_dryad_S4#6, *((xr->key))))); 
                assume !($phys_ptr_cast(L#tmp, ^b_node) == $phys_ptr_cast(L#xr, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)) == $rd_inv(_dryad_S4#6, b_node.key, $phys_ptr_cast(L#xr, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp, xr)), ==(*((xr->prio)), old(_dryad_S4#6, *((xr->prio))))); 
                assume !($phys_ptr_cast(L#tmp, ^b_node) == $phys_ptr_cast(L#xr, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node)) == $rd_inv(_dryad_S4#6, b_node.prio, $phys_ptr_cast(L#xr, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp, xl)), @_vcc_ptr_eq_pure(*((xl->left)), old(_dryad_S4#6, *((xl->left))))); 
                assume !($phys_ptr_cast(L#tmp, ^b_node) == $phys_ptr_cast(L#xl, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S4#6, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp, xl)), @_vcc_ptr_eq_pure(*((xl->right)), old(_dryad_S4#6, *((xl->right))))); 
                assume !($phys_ptr_cast(L#tmp, ^b_node) == $phys_ptr_cast(L#xl, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S4#6, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp, xl)), ==(*((xl->key)), old(_dryad_S4#6, *((xl->key))))); 
                assume !($phys_ptr_cast(L#tmp, ^b_node) == $phys_ptr_cast(L#xl, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)) == $rd_inv(_dryad_S4#6, b_node.key, $phys_ptr_cast(L#xl, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp, xl)), ==(*((xl->prio)), old(_dryad_S4#6, *((xl->prio))))); 
                assume !($phys_ptr_cast(L#tmp, ^b_node) == $phys_ptr_cast(L#xl, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node)) == $rd_inv(_dryad_S4#6, b_node.prio, $phys_ptr_cast(L#xl, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp, x)), @_vcc_ptr_eq_pure(*((x->left)), old(_dryad_S4#6, *((x->left))))); 
                assume !($phys_ptr_cast(L#tmp, ^b_node) == $phys_ptr_cast(P#x, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S4#6, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp, x)), @_vcc_ptr_eq_pure(*((x->right)), old(_dryad_S4#6, *((x->right))))); 
                assume !($phys_ptr_cast(L#tmp, ^b_node) == $phys_ptr_cast(P#x, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S4#6, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp, x)), ==(*((x->key)), old(_dryad_S4#6, *((x->key))))); 
                assume !($phys_ptr_cast(L#tmp, ^b_node) == $phys_ptr_cast(P#x, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) == $rd_inv(_dryad_S4#6, b_node.key, $phys_ptr_cast(P#x, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp, x)), ==(*((x->prio)), old(_dryad_S4#6, *((x->prio))))); 
                assume !($phys_ptr_cast(L#tmp, ^b_node) == $phys_ptr_cast(P#x, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)) == $rd_inv(_dryad_S4#6, b_node.prio, $phys_ptr_cast(P#x, ^b_node));
                // assume ==>(@_vcc_ptr_neq_null(tmp2), ==(treap(tmp2), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((tmp2->left))), treap(*((tmp2->right)))), unchecked!(@_vcc_oset_in(tmp2, @_vcc_oset_union(treap_reach(*((tmp2->left))), treap_reach(*((tmp2->right))))))), unchecked!(@_vcc_intset_in(*((tmp2->key)), @_vcc_intset_union(treap_keys(*((tmp2->left))), treap_keys(*((tmp2->right))))))), unchecked!(@_vcc_intset_in(*((tmp2->prio)), @_vcc_intset_union(treap_prios(*((tmp2->left))), treap_prios(*((tmp2->right))))))), @_vcc_oset_disjoint(treap_reach(*((tmp2->left))), treap_reach(*((tmp2->right))))), @_vcc_intset_disjoint(treap_keys(*((tmp2->left))), treap_keys(*((tmp2->right))))), @_vcc_intset_disjoint(treap_prios(*((tmp2->left))), treap_prios(*((tmp2->right))))), ==>(@_vcc_ptr_neq_null(*((tmp2->left))), <(treap_max_key(*((tmp2->left))), *((tmp2->key))))), ==>(@_vcc_ptr_neq_null(*((tmp2->right))), <(*((tmp2->key)), treap_min_key(*((tmp2->right)))))), ==>(@_vcc_ptr_neq_null(*((tmp2->left))), <(treap_max_prio(*((tmp2->left))), *((tmp2->prio))))), ==>(@_vcc_ptr_neq_null(*((tmp2->right))), <(treap_max_prio(*((tmp2->right))), *((tmp2->prio))))))); 
                assume $non_null($phys_ptr_cast(SL#tmp2, ^b_node)) ==> F#treap($s, $phys_ptr_cast(SL#tmp2, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(SL#tmp2, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(SL#tmp2, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#tmp2, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(SL#tmp2, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(SL#tmp2, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(SL#tmp2, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(SL#tmp2, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp2), ==(treap_reach(tmp2), @_vcc_oset_union(@_vcc_oset_singleton(tmp2), @_vcc_oset_union(treap_reach(*((tmp2->left))), treap_reach(*((tmp2->right))))))); 
                assume $non_null($phys_ptr_cast(SL#tmp2, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(SL#tmp2, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(SL#tmp2, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp2), ==(treap_keys(tmp2), @_vcc_intset_union(@_vcc_intset_singleton(*((tmp2->key))), @_vcc_intset_union(treap_keys(*((tmp2->left))), treap_keys(*((tmp2->right))))))); 
                assume $non_null($phys_ptr_cast(SL#tmp2, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(SL#tmp2, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(SL#tmp2, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp2), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp2->left))), @_vcc_ptr_neq_null(*((tmp2->right)))), ==(treap_max_key(tmp2), @\int_max(*((tmp2->key)), @\int_max(treap_max_key(*((tmp2->left))), treap_max_key(*((tmp2->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp2->left))), @_vcc_ptr_eq_null(*((tmp2->right)))), ==(treap_max_key(tmp2), @\int_max(*((tmp2->key)), treap_max_key(*((tmp2->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp2->left))), @_vcc_ptr_neq_null(*((tmp2->right)))), ==(treap_max_key(tmp2), @\int_max(*((tmp2->key)), treap_max_key(*((tmp2->right)))))))); 
                assume $non_null($phys_ptr_cast(SL#tmp2, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#tmp2, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#tmp2, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#tmp2, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#tmp2, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#tmp2, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#tmp2, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp2), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp2->left))), @_vcc_ptr_neq_null(*((tmp2->right)))), ==(treap_max_prio(tmp2), @\int_max(*((tmp2->prio)), @\int_max(treap_max_prio(*((tmp2->left))), treap_max_prio(*((tmp2->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp2->left))), @_vcc_ptr_eq_null(*((tmp2->right)))), ==(treap_max_prio(tmp2), @\int_max(*((tmp2->prio)), treap_max_prio(*((tmp2->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp2->left))), @_vcc_ptr_neq_null(*((tmp2->right)))), ==(treap_max_prio(tmp2), @\int_max(*((tmp2->prio)), treap_max_prio(*((tmp2->right)))))))); 
                assume $non_null($phys_ptr_cast(SL#tmp2, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#tmp2, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#tmp2, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#tmp2, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#tmp2, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#tmp2, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#tmp2, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp2), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp2->left))), @_vcc_ptr_neq_null(*((tmp2->right)))), ==(treap_min_key(tmp2), @\int_min(*((tmp2->key)), @\int_min(treap_min_key(*((tmp2->left))), treap_min_key(*((tmp2->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp2->left))), @_vcc_ptr_eq_null(*((tmp2->right)))), ==(treap_min_key(tmp2), @\int_min(*((tmp2->key)), treap_min_key(*((tmp2->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp2->left))), @_vcc_ptr_neq_null(*((tmp2->right)))), ==(treap_min_key(tmp2), @\int_min(*((tmp2->key)), treap_min_key(*((tmp2->right)))))))); 
                assume $non_null($phys_ptr_cast(SL#tmp2, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#tmp2, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#tmp2, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#tmp2, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#tmp2, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#tmp2, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#tmp2, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp2), ==(treap_prios(tmp2), @_vcc_intset_union(@_vcc_intset_singleton(*((tmp2->prio))), @_vcc_intset_union(treap_prios(*((tmp2->left))), treap_prios(*((tmp2->right))))))); 
                assume $non_null($phys_ptr_cast(SL#tmp2, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(SL#tmp2, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#tmp2, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#tmp2, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(lr), ==(treap(lr), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((lr->left))), treap(*((lr->right)))), unchecked!(@_vcc_oset_in(lr, @_vcc_oset_union(treap_reach(*((lr->left))), treap_reach(*((lr->right))))))), unchecked!(@_vcc_intset_in(*((lr->key)), @_vcc_intset_union(treap_keys(*((lr->left))), treap_keys(*((lr->right))))))), unchecked!(@_vcc_intset_in(*((lr->prio)), @_vcc_intset_union(treap_prios(*((lr->left))), treap_prios(*((lr->right))))))), @_vcc_oset_disjoint(treap_reach(*((lr->left))), treap_reach(*((lr->right))))), @_vcc_intset_disjoint(treap_keys(*((lr->left))), treap_keys(*((lr->right))))), @_vcc_intset_disjoint(treap_prios(*((lr->left))), treap_prios(*((lr->right))))), ==>(@_vcc_ptr_neq_null(*((lr->left))), <(treap_max_key(*((lr->left))), *((lr->key))))), ==>(@_vcc_ptr_neq_null(*((lr->right))), <(*((lr->key)), treap_min_key(*((lr->right)))))), ==>(@_vcc_ptr_neq_null(*((lr->left))), <(treap_max_prio(*((lr->left))), *((lr->prio))))), ==>(@_vcc_ptr_neq_null(*((lr->right))), <(treap_max_prio(*((lr->right))), *((lr->prio))))))); 
                assume $non_null($phys_ptr_cast(L#lr, ^b_node)) ==> F#treap($s, $phys_ptr_cast(L#lr, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(L#lr, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(L#lr, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(L#lr, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(L#lr, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#lr, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#lr, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#lr, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(lr), ==(treap_reach(lr), @_vcc_oset_union(@_vcc_oset_singleton(lr), @_vcc_oset_union(treap_reach(*((lr->left))), treap_reach(*((lr->right))))))); 
                assume $non_null($phys_ptr_cast(L#lr, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(L#lr, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(L#lr, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(lr), ==(treap_keys(lr), @_vcc_intset_union(@_vcc_intset_singleton(*((lr->key))), @_vcc_intset_union(treap_keys(*((lr->left))), treap_keys(*((lr->right))))))); 
                assume $non_null($phys_ptr_cast(L#lr, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(L#lr, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(L#lr, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(lr), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((lr->left))), @_vcc_ptr_neq_null(*((lr->right)))), ==(treap_max_key(lr), @\int_max(*((lr->key)), @\int_max(treap_max_key(*((lr->left))), treap_max_key(*((lr->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((lr->left))), @_vcc_ptr_eq_null(*((lr->right)))), ==(treap_max_key(lr), @\int_max(*((lr->key)), treap_max_key(*((lr->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((lr->left))), @_vcc_ptr_neq_null(*((lr->right)))), ==(treap_max_key(lr), @\int_max(*((lr->key)), treap_max_key(*((lr->right)))))))); 
                assume $non_null($phys_ptr_cast(L#lr, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#lr, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#lr, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#lr, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#lr, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#lr, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#lr, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(lr), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((lr->left))), @_vcc_ptr_neq_null(*((lr->right)))), ==(treap_max_prio(lr), @\int_max(*((lr->prio)), @\int_max(treap_max_prio(*((lr->left))), treap_max_prio(*((lr->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((lr->left))), @_vcc_ptr_eq_null(*((lr->right)))), ==(treap_max_prio(lr), @\int_max(*((lr->prio)), treap_max_prio(*((lr->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((lr->left))), @_vcc_ptr_neq_null(*((lr->right)))), ==(treap_max_prio(lr), @\int_max(*((lr->prio)), treap_max_prio(*((lr->right)))))))); 
                assume $non_null($phys_ptr_cast(L#lr, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#lr, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#lr, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#lr, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#lr, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#lr, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#lr, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(lr), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((lr->left))), @_vcc_ptr_neq_null(*((lr->right)))), ==(treap_min_key(lr), @\int_min(*((lr->key)), @\int_min(treap_min_key(*((lr->left))), treap_min_key(*((lr->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((lr->left))), @_vcc_ptr_eq_null(*((lr->right)))), ==(treap_min_key(lr), @\int_min(*((lr->key)), treap_min_key(*((lr->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((lr->left))), @_vcc_ptr_neq_null(*((lr->right)))), ==(treap_min_key(lr), @\int_min(*((lr->key)), treap_min_key(*((lr->right)))))))); 
                assume $non_null($phys_ptr_cast(L#lr, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#lr, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#lr, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#lr, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#lr, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#lr, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#lr, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(lr), ==(treap_prios(lr), @_vcc_intset_union(@_vcc_intset_singleton(*((lr->prio))), @_vcc_intset_union(treap_prios(*((lr->left))), treap_prios(*((lr->right))))))); 
                assume $non_null($phys_ptr_cast(L#lr, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(L#lr, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(L#lr, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#lr, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#lr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1), ==(treap(x1), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x1->left))), treap(*((x1->right)))), unchecked!(@_vcc_oset_in(x1, @_vcc_oset_union(treap_reach(*((x1->left))), treap_reach(*((x1->right))))))), unchecked!(@_vcc_intset_in(*((x1->key)), @_vcc_intset_union(treap_keys(*((x1->left))), treap_keys(*((x1->right))))))), unchecked!(@_vcc_intset_in(*((x1->prio)), @_vcc_intset_union(treap_prios(*((x1->left))), treap_prios(*((x1->right))))))), @_vcc_oset_disjoint(treap_reach(*((x1->left))), treap_reach(*((x1->right))))), @_vcc_intset_disjoint(treap_keys(*((x1->left))), treap_keys(*((x1->right))))), @_vcc_intset_disjoint(treap_prios(*((x1->left))), treap_prios(*((x1->right))))), ==>(@_vcc_ptr_neq_null(*((x1->left))), <(treap_max_key(*((x1->left))), *((x1->key))))), ==>(@_vcc_ptr_neq_null(*((x1->right))), <(*((x1->key)), treap_min_key(*((x1->right)))))), ==>(@_vcc_ptr_neq_null(*((x1->left))), <(treap_max_prio(*((x1->left))), *((x1->prio))))), ==>(@_vcc_ptr_neq_null(*((x1->right))), <(treap_max_prio(*((x1->right))), *((x1->prio))))))); 
                assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> F#treap($s, $phys_ptr_cast(SL#x1, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(SL#x1, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1), ==(treap_reach(x1), @_vcc_oset_union(@_vcc_oset_singleton(x1), @_vcc_oset_union(treap_reach(*((x1->left))), treap_reach(*((x1->right))))))); 
                assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(SL#x1, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(SL#x1, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1), ==(treap_keys(x1), @_vcc_intset_union(@_vcc_intset_singleton(*((x1->key))), @_vcc_intset_union(treap_keys(*((x1->left))), treap_keys(*((x1->right))))))); 
                assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(SL#x1, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x1->left))), @_vcc_ptr_neq_null(*((x1->right)))), ==(treap_max_key(x1), @\int_max(*((x1->key)), @\int_max(treap_max_key(*((x1->left))), treap_max_key(*((x1->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x1->left))), @_vcc_ptr_eq_null(*((x1->right)))), ==(treap_max_key(x1), @\int_max(*((x1->key)), treap_max_key(*((x1->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x1->left))), @_vcc_ptr_neq_null(*((x1->right)))), ==(treap_max_key(x1), @\int_max(*((x1->key)), treap_max_key(*((x1->right)))))))); 
                assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x1->left))), @_vcc_ptr_neq_null(*((x1->right)))), ==(treap_max_prio(x1), @\int_max(*((x1->prio)), @\int_max(treap_max_prio(*((x1->left))), treap_max_prio(*((x1->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x1->left))), @_vcc_ptr_eq_null(*((x1->right)))), ==(treap_max_prio(x1), @\int_max(*((x1->prio)), treap_max_prio(*((x1->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x1->left))), @_vcc_ptr_neq_null(*((x1->right)))), ==(treap_max_prio(x1), @\int_max(*((x1->prio)), treap_max_prio(*((x1->right)))))))); 
                assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x1->left))), @_vcc_ptr_neq_null(*((x1->right)))), ==(treap_min_key(x1), @\int_min(*((x1->key)), @\int_min(treap_min_key(*((x1->left))), treap_min_key(*((x1->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x1->left))), @_vcc_ptr_eq_null(*((x1->right)))), ==(treap_min_key(x1), @\int_min(*((x1->key)), treap_min_key(*((x1->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x1->left))), @_vcc_ptr_neq_null(*((x1->right)))), ==(treap_min_key(x1), @\int_min(*((x1->key)), treap_min_key(*((x1->right)))))))); 
                assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#x1, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x1, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1), ==(treap_prios(x1), @_vcc_intset_union(@_vcc_intset_singleton(*((x1->prio))), @_vcc_intset_union(treap_prios(*((x1->left))), treap_prios(*((x1->right))))))); 
                assume $non_null($phys_ptr_cast(SL#x1, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(SL#x1, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x1, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x1, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x1, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0), ==(treap(x0), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x0->left))), treap(*((x0->right)))), unchecked!(@_vcc_oset_in(x0, @_vcc_oset_union(treap_reach(*((x0->left))), treap_reach(*((x0->right))))))), unchecked!(@_vcc_intset_in(*((x0->key)), @_vcc_intset_union(treap_keys(*((x0->left))), treap_keys(*((x0->right))))))), unchecked!(@_vcc_intset_in(*((x0->prio)), @_vcc_intset_union(treap_prios(*((x0->left))), treap_prios(*((x0->right))))))), @_vcc_oset_disjoint(treap_reach(*((x0->left))), treap_reach(*((x0->right))))), @_vcc_intset_disjoint(treap_keys(*((x0->left))), treap_keys(*((x0->right))))), @_vcc_intset_disjoint(treap_prios(*((x0->left))), treap_prios(*((x0->right))))), ==>(@_vcc_ptr_neq_null(*((x0->left))), <(treap_max_key(*((x0->left))), *((x0->key))))), ==>(@_vcc_ptr_neq_null(*((x0->right))), <(*((x0->key)), treap_min_key(*((x0->right)))))), ==>(@_vcc_ptr_neq_null(*((x0->left))), <(treap_max_prio(*((x0->left))), *((x0->prio))))), ==>(@_vcc_ptr_neq_null(*((x0->right))), <(treap_max_prio(*((x0->right))), *((x0->prio))))))); 
                assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> F#treap($s, $phys_ptr_cast(SL#x0, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(SL#x0, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0), ==(treap_reach(x0), @_vcc_oset_union(@_vcc_oset_singleton(x0), @_vcc_oset_union(treap_reach(*((x0->left))), treap_reach(*((x0->right))))))); 
                assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(SL#x0, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(SL#x0, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0), ==(treap_keys(x0), @_vcc_intset_union(@_vcc_intset_singleton(*((x0->key))), @_vcc_intset_union(treap_keys(*((x0->left))), treap_keys(*((x0->right))))))); 
                assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(SL#x0, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x0->left))), @_vcc_ptr_neq_null(*((x0->right)))), ==(treap_max_key(x0), @\int_max(*((x0->key)), @\int_max(treap_max_key(*((x0->left))), treap_max_key(*((x0->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x0->left))), @_vcc_ptr_eq_null(*((x0->right)))), ==(treap_max_key(x0), @\int_max(*((x0->key)), treap_max_key(*((x0->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x0->left))), @_vcc_ptr_neq_null(*((x0->right)))), ==(treap_max_key(x0), @\int_max(*((x0->key)), treap_max_key(*((x0->right)))))))); 
                assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x0->left))), @_vcc_ptr_neq_null(*((x0->right)))), ==(treap_max_prio(x0), @\int_max(*((x0->prio)), @\int_max(treap_max_prio(*((x0->left))), treap_max_prio(*((x0->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x0->left))), @_vcc_ptr_eq_null(*((x0->right)))), ==(treap_max_prio(x0), @\int_max(*((x0->prio)), treap_max_prio(*((x0->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x0->left))), @_vcc_ptr_neq_null(*((x0->right)))), ==(treap_max_prio(x0), @\int_max(*((x0->prio)), treap_max_prio(*((x0->right)))))))); 
                assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x0->left))), @_vcc_ptr_neq_null(*((x0->right)))), ==(treap_min_key(x0), @\int_min(*((x0->key)), @\int_min(treap_min_key(*((x0->left))), treap_min_key(*((x0->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x0->left))), @_vcc_ptr_eq_null(*((x0->right)))), ==(treap_min_key(x0), @\int_min(*((x0->key)), treap_min_key(*((x0->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x0->left))), @_vcc_ptr_neq_null(*((x0->right)))), ==(treap_min_key(x0), @\int_min(*((x0->key)), treap_min_key(*((x0->right)))))))); 
                assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(SL#x0, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(SL#x0, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0), ==(treap_prios(x0), @_vcc_intset_union(@_vcc_intset_singleton(*((x0->prio))), @_vcc_intset_union(treap_prios(*((x0->left))), treap_prios(*((x0->right))))))); 
                assume $non_null($phys_ptr_cast(SL#x0, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(SL#x0, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(SL#x0, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(SL#x0, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(SL#x0, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr), ==(treap(xr), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((xr->left))), treap(*((xr->right)))), unchecked!(@_vcc_oset_in(xr, @_vcc_oset_union(treap_reach(*((xr->left))), treap_reach(*((xr->right))))))), unchecked!(@_vcc_intset_in(*((xr->key)), @_vcc_intset_union(treap_keys(*((xr->left))), treap_keys(*((xr->right))))))), unchecked!(@_vcc_intset_in(*((xr->prio)), @_vcc_intset_union(treap_prios(*((xr->left))), treap_prios(*((xr->right))))))), @_vcc_oset_disjoint(treap_reach(*((xr->left))), treap_reach(*((xr->right))))), @_vcc_intset_disjoint(treap_keys(*((xr->left))), treap_keys(*((xr->right))))), @_vcc_intset_disjoint(treap_prios(*((xr->left))), treap_prios(*((xr->right))))), ==>(@_vcc_ptr_neq_null(*((xr->left))), <(treap_max_key(*((xr->left))), *((xr->key))))), ==>(@_vcc_ptr_neq_null(*((xr->right))), <(*((xr->key)), treap_min_key(*((xr->right)))))), ==>(@_vcc_ptr_neq_null(*((xr->left))), <(treap_max_prio(*((xr->left))), *((xr->prio))))), ==>(@_vcc_ptr_neq_null(*((xr->right))), <(treap_max_prio(*((xr->right))), *((xr->prio))))))); 
                assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> F#treap($s, $phys_ptr_cast(L#xr, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(L#xr, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr), ==(treap_reach(xr), @_vcc_oset_union(@_vcc_oset_singleton(xr), @_vcc_oset_union(treap_reach(*((xr->left))), treap_reach(*((xr->right))))))); 
                assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(L#xr, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(L#xr, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr), ==(treap_keys(xr), @_vcc_intset_union(@_vcc_intset_singleton(*((xr->key))), @_vcc_intset_union(treap_keys(*((xr->left))), treap_keys(*((xr->right))))))); 
                assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(L#xr, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_max_key(xr), @\int_max(*((xr->key)), @\int_max(treap_max_key(*((xr->left))), treap_max_key(*((xr->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_eq_null(*((xr->right)))), ==(treap_max_key(xr), @\int_max(*((xr->key)), treap_max_key(*((xr->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_max_key(xr), @\int_max(*((xr->key)), treap_max_key(*((xr->right)))))))); 
                assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_max_prio(xr), @\int_max(*((xr->prio)), @\int_max(treap_max_prio(*((xr->left))), treap_max_prio(*((xr->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_eq_null(*((xr->right)))), ==(treap_max_prio(xr), @\int_max(*((xr->prio)), treap_max_prio(*((xr->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_max_prio(xr), @\int_max(*((xr->prio)), treap_max_prio(*((xr->right)))))))); 
                assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_min_key(xr), @\int_min(*((xr->key)), @\int_min(treap_min_key(*((xr->left))), treap_min_key(*((xr->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr->left))), @_vcc_ptr_eq_null(*((xr->right)))), ==(treap_min_key(xr), @\int_min(*((xr->key)), treap_min_key(*((xr->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr->left))), @_vcc_ptr_neq_null(*((xr->right)))), ==(treap_min_key(xr), @\int_min(*((xr->key)), treap_min_key(*((xr->right)))))))); 
                assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xr, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xr, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr), ==(treap_prios(xr), @_vcc_intset_union(@_vcc_intset_singleton(*((xr->prio))), @_vcc_intset_union(treap_prios(*((xr->left))), treap_prios(*((xr->right))))))); 
                assume $non_null($phys_ptr_cast(L#xr, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(L#xr, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xr, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xr, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xr, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl), ==(treap(xl), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((xl->left))), treap(*((xl->right)))), unchecked!(@_vcc_oset_in(xl, @_vcc_oset_union(treap_reach(*((xl->left))), treap_reach(*((xl->right))))))), unchecked!(@_vcc_intset_in(*((xl->key)), @_vcc_intset_union(treap_keys(*((xl->left))), treap_keys(*((xl->right))))))), unchecked!(@_vcc_intset_in(*((xl->prio)), @_vcc_intset_union(treap_prios(*((xl->left))), treap_prios(*((xl->right))))))), @_vcc_oset_disjoint(treap_reach(*((xl->left))), treap_reach(*((xl->right))))), @_vcc_intset_disjoint(treap_keys(*((xl->left))), treap_keys(*((xl->right))))), @_vcc_intset_disjoint(treap_prios(*((xl->left))), treap_prios(*((xl->right))))), ==>(@_vcc_ptr_neq_null(*((xl->left))), <(treap_max_key(*((xl->left))), *((xl->key))))), ==>(@_vcc_ptr_neq_null(*((xl->right))), <(*((xl->key)), treap_min_key(*((xl->right)))))), ==>(@_vcc_ptr_neq_null(*((xl->left))), <(treap_max_prio(*((xl->left))), *((xl->prio))))), ==>(@_vcc_ptr_neq_null(*((xl->right))), <(treap_max_prio(*((xl->right))), *((xl->prio))))))); 
                assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> F#treap($s, $phys_ptr_cast(L#xl, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(L#xl, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl), ==(treap_reach(xl), @_vcc_oset_union(@_vcc_oset_singleton(xl), @_vcc_oset_union(treap_reach(*((xl->left))), treap_reach(*((xl->right))))))); 
                assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(L#xl, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(L#xl, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl), ==(treap_keys(xl), @_vcc_intset_union(@_vcc_intset_singleton(*((xl->key))), @_vcc_intset_union(treap_keys(*((xl->left))), treap_keys(*((xl->right))))))); 
                assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(L#xl, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_max_key(xl), @\int_max(*((xl->key)), @\int_max(treap_max_key(*((xl->left))), treap_max_key(*((xl->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_eq_null(*((xl->right)))), ==(treap_max_key(xl), @\int_max(*((xl->key)), treap_max_key(*((xl->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_max_key(xl), @\int_max(*((xl->key)), treap_max_key(*((xl->right)))))))); 
                assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_max_prio(xl), @\int_max(*((xl->prio)), @\int_max(treap_max_prio(*((xl->left))), treap_max_prio(*((xl->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_eq_null(*((xl->right)))), ==(treap_max_prio(xl), @\int_max(*((xl->prio)), treap_max_prio(*((xl->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_max_prio(xl), @\int_max(*((xl->prio)), treap_max_prio(*((xl->right)))))))); 
                assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_min_key(xl), @\int_min(*((xl->key)), @\int_min(treap_min_key(*((xl->left))), treap_min_key(*((xl->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl->left))), @_vcc_ptr_eq_null(*((xl->right)))), ==(treap_min_key(xl), @\int_min(*((xl->key)), treap_min_key(*((xl->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl->left))), @_vcc_ptr_neq_null(*((xl->right)))), ==(treap_min_key(xl), @\int_min(*((xl->key)), treap_min_key(*((xl->right)))))))); 
                assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#xl, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#xl, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl), ==(treap_prios(xl), @_vcc_intset_union(@_vcc_intset_singleton(*((xl->prio))), @_vcc_intset_union(treap_prios(*((xl->left))), treap_prios(*((xl->right))))))); 
                assume $non_null($phys_ptr_cast(L#xl, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(L#xl, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(L#xl, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#xl, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#xl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), ==(treap(x), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x->left))), treap(*((x->right)))), unchecked!(@_vcc_oset_in(x, @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->key)), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->prio)), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))), @_vcc_oset_disjoint(treap_reach(*((x->left))), treap_reach(*((x->right))))), @_vcc_intset_disjoint(treap_keys(*((x->left))), treap_keys(*((x->right))))), @_vcc_intset_disjoint(treap_prios(*((x->left))), treap_prios(*((x->right))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_key(*((x->left))), *((x->key))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(*((x->key)), treap_min_key(*((x->right)))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_prio(*((x->left))), *((x->prio))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(treap_max_prio(*((x->right))), *((x->prio))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap($s, $phys_ptr_cast(P#x, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(P#x, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_reach(x), @_vcc_oset_union(@_vcc_oset_singleton(x), @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(P#x, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(P#x, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_keys(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->key))), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), @\int_max(treap_max_key(*((x->left))), treap_max_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->right)))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), @\int_max(treap_max_prio(*((x->left))), treap_max_prio(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->right)))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), @\int_min(treap_min_key(*((x->left))), treap_min_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->right)))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_prios(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->prio))), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), ==(treap(tmp), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((tmp->left))), treap(*((tmp->right)))), unchecked!(@_vcc_oset_in(tmp, @_vcc_oset_union(treap_reach(*((tmp->left))), treap_reach(*((tmp->right))))))), unchecked!(@_vcc_intset_in(*((tmp->key)), @_vcc_intset_union(treap_keys(*((tmp->left))), treap_keys(*((tmp->right))))))), unchecked!(@_vcc_intset_in(*((tmp->prio)), @_vcc_intset_union(treap_prios(*((tmp->left))), treap_prios(*((tmp->right))))))), @_vcc_oset_disjoint(treap_reach(*((tmp->left))), treap_reach(*((tmp->right))))), @_vcc_intset_disjoint(treap_keys(*((tmp->left))), treap_keys(*((tmp->right))))), @_vcc_intset_disjoint(treap_prios(*((tmp->left))), treap_prios(*((tmp->right))))), ==>(@_vcc_ptr_neq_null(*((tmp->left))), <(treap_max_key(*((tmp->left))), *((tmp->key))))), ==>(@_vcc_ptr_neq_null(*((tmp->right))), <(*((tmp->key)), treap_min_key(*((tmp->right)))))), ==>(@_vcc_ptr_neq_null(*((tmp->left))), <(treap_max_prio(*((tmp->left))), *((tmp->prio))))), ==>(@_vcc_ptr_neq_null(*((tmp->right))), <(treap_max_prio(*((tmp->right))), *((tmp->prio))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> F#treap($s, $phys_ptr_cast(L#tmp, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(L#tmp, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), ==(treap_reach(tmp), @_vcc_oset_union(@_vcc_oset_singleton(tmp), @_vcc_oset_union(treap_reach(*((tmp->left))), treap_reach(*((tmp->right))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(L#tmp, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(L#tmp, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), ==(treap_keys(tmp), @_vcc_intset_union(@_vcc_intset_singleton(*((tmp->key))), @_vcc_intset_union(treap_keys(*((tmp->left))), treap_keys(*((tmp->right))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(L#tmp, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_max_key(tmp), @\int_max(*((tmp->key)), @\int_max(treap_max_key(*((tmp->left))), treap_max_key(*((tmp->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_eq_null(*((tmp->right)))), ==(treap_max_key(tmp), @\int_max(*((tmp->key)), treap_max_key(*((tmp->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_max_key(tmp), @\int_max(*((tmp->key)), treap_max_key(*((tmp->right)))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_max_prio(tmp), @\int_max(*((tmp->prio)), @\int_max(treap_max_prio(*((tmp->left))), treap_max_prio(*((tmp->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_eq_null(*((tmp->right)))), ==(treap_max_prio(tmp), @\int_max(*((tmp->prio)), treap_max_prio(*((tmp->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_max_prio(tmp), @\int_max(*((tmp->prio)), treap_max_prio(*((tmp->right)))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_min_key(tmp), @\int_min(*((tmp->key)), @\int_min(treap_min_key(*((tmp->left))), treap_min_key(*((tmp->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp->left))), @_vcc_ptr_eq_null(*((tmp->right)))), ==(treap_min_key(tmp), @\int_min(*((tmp->key)), treap_min_key(*((tmp->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp->left))), @_vcc_ptr_neq_null(*((tmp->right)))), ==(treap_min_key(tmp), @\int_min(*((tmp->key)), treap_min_key(*((tmp->right)))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#tmp, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#tmp, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp), ==(treap_prios(tmp), @_vcc_intset_union(@_vcc_intset_singleton(*((tmp->prio))), @_vcc_intset_union(treap_prios(*((tmp->left))), treap_prios(*((tmp->right))))))); 
                assume $non_null($phys_ptr_cast(L#tmp, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(L#tmp, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(L#tmp, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#tmp, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#tmp, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), ==(treap(x), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x->left))), treap(*((x->right)))), unchecked!(@_vcc_oset_in(x, @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->key)), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->prio)), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))), @_vcc_oset_disjoint(treap_reach(*((x->left))), treap_reach(*((x->right))))), @_vcc_intset_disjoint(treap_keys(*((x->left))), treap_keys(*((x->right))))), @_vcc_intset_disjoint(treap_prios(*((x->left))), treap_prios(*((x->right))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_key(*((x->left))), *((x->key))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(*((x->key)), treap_min_key(*((x->right)))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_prio(*((x->left))), *((x->prio))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(treap_max_prio(*((x->right))), *((x->prio))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap($s, $phys_ptr_cast(P#x, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(P#x, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_reach(x), @_vcc_oset_union(@_vcc_oset_singleton(x), @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(P#x, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(P#x, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_keys(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->key))), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), @\int_max(treap_max_key(*((x->left))), treap_max_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->right)))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), @\int_max(treap_max_prio(*((x->left))), treap_max_prio(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->right)))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), @\int_min(treap_min_key(*((x->left))), treap_min_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->right)))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_prios(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->prio))), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // return tmp; 
                $result := $phys_ptr_cast(L#tmp, ^b_node);
                assume true;
                assert $position_marker();
                goto #exit;
            }
        }
        else
        {
          anon7:
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap(x), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x->left))), treap(*((x->right)))), unchecked!(@_vcc_oset_in(x, @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->key)), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->prio)), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))), @_vcc_oset_disjoint(treap_reach(*((x->left))), treap_reach(*((x->right))))), @_vcc_intset_disjoint(treap_keys(*((x->left))), treap_keys(*((x->right))))), @_vcc_intset_disjoint(treap_prios(*((x->left))), treap_prios(*((x->right))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_key(*((x->left))), *((x->key))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(*((x->key)), treap_min_key(*((x->right)))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_prio(*((x->left))), *((x->prio))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(treap_max_prio(*((x->right))), *((x->prio))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap($s, $phys_ptr_cast(P#x, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(P#x, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_reach(x), @_vcc_oset_union(@_vcc_oset_singleton(x), @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(P#x, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(P#x, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_keys(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->key))), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), @\int_max(treap_max_key(*((x->left))), treap_max_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), @\int_max(treap_max_prio(*((x->left))), treap_max_prio(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), @\int_min(treap_min_key(*((x->left))), treap_min_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_prios(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->prio))), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // struct b_node* tmp#8; 
            // struct b_node* xl#9; 
            // struct b_node* xr#10; 
            // struct b_node* x0#11; 
            // x0#11 := x; 
            x0#11 := $phys_ptr_cast(P#x, ^b_node);
            // struct b_node* stmtexpr0#26; 
            // stmtexpr0#26 := x0#11; 
            stmtexpr0#26 := $phys_ptr_cast(x0#11, ^b_node);
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap(x), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x->left))), treap(*((x->right)))), unchecked!(@_vcc_oset_in(x, @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->key)), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->prio)), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))), @_vcc_oset_disjoint(treap_reach(*((x->left))), treap_reach(*((x->right))))), @_vcc_intset_disjoint(treap_keys(*((x->left))), treap_keys(*((x->right))))), @_vcc_intset_disjoint(treap_prios(*((x->left))), treap_prios(*((x->right))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_key(*((x->left))), *((x->key))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(*((x->key)), treap_min_key(*((x->right)))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_prio(*((x->left))), *((x->prio))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(treap_max_prio(*((x->right))), *((x->prio))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap($s, $phys_ptr_cast(P#x, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(P#x, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_reach(x), @_vcc_oset_union(@_vcc_oset_singleton(x), @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(P#x, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(P#x, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_keys(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->key))), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), @\int_max(treap_max_key(*((x->left))), treap_max_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), @\int_max(treap_max_prio(*((x->left))), treap_max_prio(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), @\int_min(treap_min_key(*((x->left))), treap_min_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_prios(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->prio))), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assert @reads_check_normal((x->right)); 
            assert $thread_local($s, $phys_ptr_cast(P#x, ^b_node));
            // xr#10 := *((x->right)); 
            xr#10 := $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node);
            // assume ==>(@_vcc_ptr_neq_null(xr#10), ==(treap(xr#10), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((xr#10->left))), treap(*((xr#10->right)))), unchecked!(@_vcc_oset_in(xr#10, @_vcc_oset_union(treap_reach(*((xr#10->left))), treap_reach(*((xr#10->right))))))), unchecked!(@_vcc_intset_in(*((xr#10->key)), @_vcc_intset_union(treap_keys(*((xr#10->left))), treap_keys(*((xr#10->right))))))), unchecked!(@_vcc_intset_in(*((xr#10->prio)), @_vcc_intset_union(treap_prios(*((xr#10->left))), treap_prios(*((xr#10->right))))))), @_vcc_oset_disjoint(treap_reach(*((xr#10->left))), treap_reach(*((xr#10->right))))), @_vcc_intset_disjoint(treap_keys(*((xr#10->left))), treap_keys(*((xr#10->right))))), @_vcc_intset_disjoint(treap_prios(*((xr#10->left))), treap_prios(*((xr#10->right))))), ==>(@_vcc_ptr_neq_null(*((xr#10->left))), <(treap_max_key(*((xr#10->left))), *((xr#10->key))))), ==>(@_vcc_ptr_neq_null(*((xr#10->right))), <(*((xr#10->key)), treap_min_key(*((xr#10->right)))))), ==>(@_vcc_ptr_neq_null(*((xr#10->left))), <(treap_max_prio(*((xr#10->left))), *((xr#10->prio))))), ==>(@_vcc_ptr_neq_null(*((xr#10->right))), <(treap_max_prio(*((xr#10->right))), *((xr#10->prio))))))); 
            assume $non_null($phys_ptr_cast(xr#10, ^b_node)) ==> F#treap($s, $phys_ptr_cast(xr#10, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(xr#10, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr#10), ==(treap_reach(xr#10), @_vcc_oset_union(@_vcc_oset_singleton(xr#10), @_vcc_oset_union(treap_reach(*((xr#10->left))), treap_reach(*((xr#10->right))))))); 
            assume $non_null($phys_ptr_cast(xr#10, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(xr#10, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(xr#10, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr#10), ==(treap_keys(xr#10), @_vcc_intset_union(@_vcc_intset_singleton(*((xr#10->key))), @_vcc_intset_union(treap_keys(*((xr#10->left))), treap_keys(*((xr#10->right))))))); 
            assume $non_null($phys_ptr_cast(xr#10, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(xr#10, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr#10), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr#10->left))), @_vcc_ptr_neq_null(*((xr#10->right)))), ==(treap_max_key(xr#10), @\int_max(*((xr#10->key)), @\int_max(treap_max_key(*((xr#10->left))), treap_max_key(*((xr#10->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr#10->left))), @_vcc_ptr_eq_null(*((xr#10->right)))), ==(treap_max_key(xr#10), @\int_max(*((xr#10->key)), treap_max_key(*((xr#10->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr#10->left))), @_vcc_ptr_neq_null(*((xr#10->right)))), ==(treap_max_key(xr#10), @\int_max(*((xr#10->key)), treap_max_key(*((xr#10->right)))))))); 
            assume $non_null($phys_ptr_cast(xr#10, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr#10), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr#10->left))), @_vcc_ptr_neq_null(*((xr#10->right)))), ==(treap_max_prio(xr#10), @\int_max(*((xr#10->prio)), @\int_max(treap_max_prio(*((xr#10->left))), treap_max_prio(*((xr#10->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr#10->left))), @_vcc_ptr_eq_null(*((xr#10->right)))), ==(treap_max_prio(xr#10), @\int_max(*((xr#10->prio)), treap_max_prio(*((xr#10->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr#10->left))), @_vcc_ptr_neq_null(*((xr#10->right)))), ==(treap_max_prio(xr#10), @\int_max(*((xr#10->prio)), treap_max_prio(*((xr#10->right)))))))); 
            assume $non_null($phys_ptr_cast(xr#10, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr#10), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr#10->left))), @_vcc_ptr_neq_null(*((xr#10->right)))), ==(treap_min_key(xr#10), @\int_min(*((xr#10->key)), @\int_min(treap_min_key(*((xr#10->left))), treap_min_key(*((xr#10->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr#10->left))), @_vcc_ptr_eq_null(*((xr#10->right)))), ==(treap_min_key(xr#10), @\int_min(*((xr#10->key)), treap_min_key(*((xr#10->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr#10->left))), @_vcc_ptr_neq_null(*((xr#10->right)))), ==(treap_min_key(xr#10), @\int_min(*((xr#10->key)), treap_min_key(*((xr#10->right)))))))); 
            assume $non_null($phys_ptr_cast(xr#10, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr#10), ==(treap_prios(xr#10), @_vcc_intset_union(@_vcc_intset_singleton(*((xr#10->prio))), @_vcc_intset_union(treap_prios(*((xr#10->left))), treap_prios(*((xr#10->right))))))); 
            assume $non_null($phys_ptr_cast(xr#10, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(xr#10, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap(x), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x->left))), treap(*((x->right)))), unchecked!(@_vcc_oset_in(x, @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->key)), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->prio)), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))), @_vcc_oset_disjoint(treap_reach(*((x->left))), treap_reach(*((x->right))))), @_vcc_intset_disjoint(treap_keys(*((x->left))), treap_keys(*((x->right))))), @_vcc_intset_disjoint(treap_prios(*((x->left))), treap_prios(*((x->right))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_key(*((x->left))), *((x->key))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(*((x->key)), treap_min_key(*((x->right)))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_prio(*((x->left))), *((x->prio))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(treap_max_prio(*((x->right))), *((x->prio))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap($s, $phys_ptr_cast(P#x, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(P#x, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_reach(x), @_vcc_oset_union(@_vcc_oset_singleton(x), @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(P#x, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(P#x, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_keys(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->key))), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), @\int_max(treap_max_key(*((x->left))), treap_max_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), @\int_max(treap_max_prio(*((x->left))), treap_max_prio(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), @\int_min(treap_min_key(*((x->left))), treap_min_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_prios(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->prio))), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // struct b_node* x1#12; 
            // x1#12 := x; 
            x1#12 := $phys_ptr_cast(P#x, ^b_node);
            // struct b_node* stmtexpr1#27; 
            // stmtexpr1#27 := x1#12; 
            stmtexpr1#27 := $phys_ptr_cast(x1#12, ^b_node);
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap(x), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x->left))), treap(*((x->right)))), unchecked!(@_vcc_oset_in(x, @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->key)), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->prio)), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))), @_vcc_oset_disjoint(treap_reach(*((x->left))), treap_reach(*((x->right))))), @_vcc_intset_disjoint(treap_keys(*((x->left))), treap_keys(*((x->right))))), @_vcc_intset_disjoint(treap_prios(*((x->left))), treap_prios(*((x->right))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_key(*((x->left))), *((x->key))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(*((x->key)), treap_min_key(*((x->right)))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_prio(*((x->left))), *((x->prio))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(treap_max_prio(*((x->right))), *((x->prio))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap($s, $phys_ptr_cast(P#x, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(P#x, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_reach(x), @_vcc_oset_union(@_vcc_oset_singleton(x), @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(P#x, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(P#x, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_keys(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->key))), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), @\int_max(treap_max_key(*((x->left))), treap_max_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), @\int_max(treap_max_prio(*((x->left))), treap_max_prio(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), @\int_min(treap_min_key(*((x->left))), treap_min_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_prios(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->prio))), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assert @reads_check_normal((x->left)); 
            assert $thread_local($s, $phys_ptr_cast(P#x, ^b_node));
            // xl#9 := *((x->left)); 
            xl#9 := $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node);
            // assume ==>(@_vcc_ptr_neq_null(xl#9), ==(treap(xl#9), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((xl#9->left))), treap(*((xl#9->right)))), unchecked!(@_vcc_oset_in(xl#9, @_vcc_oset_union(treap_reach(*((xl#9->left))), treap_reach(*((xl#9->right))))))), unchecked!(@_vcc_intset_in(*((xl#9->key)), @_vcc_intset_union(treap_keys(*((xl#9->left))), treap_keys(*((xl#9->right))))))), unchecked!(@_vcc_intset_in(*((xl#9->prio)), @_vcc_intset_union(treap_prios(*((xl#9->left))), treap_prios(*((xl#9->right))))))), @_vcc_oset_disjoint(treap_reach(*((xl#9->left))), treap_reach(*((xl#9->right))))), @_vcc_intset_disjoint(treap_keys(*((xl#9->left))), treap_keys(*((xl#9->right))))), @_vcc_intset_disjoint(treap_prios(*((xl#9->left))), treap_prios(*((xl#9->right))))), ==>(@_vcc_ptr_neq_null(*((xl#9->left))), <(treap_max_key(*((xl#9->left))), *((xl#9->key))))), ==>(@_vcc_ptr_neq_null(*((xl#9->right))), <(*((xl#9->key)), treap_min_key(*((xl#9->right)))))), ==>(@_vcc_ptr_neq_null(*((xl#9->left))), <(treap_max_prio(*((xl#9->left))), *((xl#9->prio))))), ==>(@_vcc_ptr_neq_null(*((xl#9->right))), <(treap_max_prio(*((xl#9->right))), *((xl#9->prio))))))); 
            assume $non_null($phys_ptr_cast(xl#9, ^b_node)) ==> F#treap($s, $phys_ptr_cast(xl#9, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(xl#9, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl#9), ==(treap_reach(xl#9), @_vcc_oset_union(@_vcc_oset_singleton(xl#9), @_vcc_oset_union(treap_reach(*((xl#9->left))), treap_reach(*((xl#9->right))))))); 
            assume $non_null($phys_ptr_cast(xl#9, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(xl#9, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(xl#9, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl#9), ==(treap_keys(xl#9), @_vcc_intset_union(@_vcc_intset_singleton(*((xl#9->key))), @_vcc_intset_union(treap_keys(*((xl#9->left))), treap_keys(*((xl#9->right))))))); 
            assume $non_null($phys_ptr_cast(xl#9, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(xl#9, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl#9), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl#9->left))), @_vcc_ptr_neq_null(*((xl#9->right)))), ==(treap_max_key(xl#9), @\int_max(*((xl#9->key)), @\int_max(treap_max_key(*((xl#9->left))), treap_max_key(*((xl#9->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl#9->left))), @_vcc_ptr_eq_null(*((xl#9->right)))), ==(treap_max_key(xl#9), @\int_max(*((xl#9->key)), treap_max_key(*((xl#9->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl#9->left))), @_vcc_ptr_neq_null(*((xl#9->right)))), ==(treap_max_key(xl#9), @\int_max(*((xl#9->key)), treap_max_key(*((xl#9->right)))))))); 
            assume $non_null($phys_ptr_cast(xl#9, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl#9), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl#9->left))), @_vcc_ptr_neq_null(*((xl#9->right)))), ==(treap_max_prio(xl#9), @\int_max(*((xl#9->prio)), @\int_max(treap_max_prio(*((xl#9->left))), treap_max_prio(*((xl#9->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl#9->left))), @_vcc_ptr_eq_null(*((xl#9->right)))), ==(treap_max_prio(xl#9), @\int_max(*((xl#9->prio)), treap_max_prio(*((xl#9->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl#9->left))), @_vcc_ptr_neq_null(*((xl#9->right)))), ==(treap_max_prio(xl#9), @\int_max(*((xl#9->prio)), treap_max_prio(*((xl#9->right)))))))); 
            assume $non_null($phys_ptr_cast(xl#9, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl#9), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl#9->left))), @_vcc_ptr_neq_null(*((xl#9->right)))), ==(treap_min_key(xl#9), @\int_min(*((xl#9->key)), @\int_min(treap_min_key(*((xl#9->left))), treap_min_key(*((xl#9->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl#9->left))), @_vcc_ptr_eq_null(*((xl#9->right)))), ==(treap_min_key(xl#9), @\int_min(*((xl#9->key)), treap_min_key(*((xl#9->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl#9->left))), @_vcc_ptr_neq_null(*((xl#9->right)))), ==(treap_min_key(xl#9), @\int_min(*((xl#9->key)), treap_min_key(*((xl#9->right)))))))); 
            assume $non_null($phys_ptr_cast(xl#9, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl#9), ==(treap_prios(xl#9), @_vcc_intset_union(@_vcc_intset_singleton(*((xl#9->prio))), @_vcc_intset_union(treap_prios(*((xl#9->left))), treap_prios(*((xl#9->right))))))); 
            assume $non_null($phys_ptr_cast(xl#9, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(xl#9, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap(x), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x->left))), treap(*((x->right)))), unchecked!(@_vcc_oset_in(x, @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->key)), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->prio)), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))), @_vcc_oset_disjoint(treap_reach(*((x->left))), treap_reach(*((x->right))))), @_vcc_intset_disjoint(treap_keys(*((x->left))), treap_keys(*((x->right))))), @_vcc_intset_disjoint(treap_prios(*((x->left))), treap_prios(*((x->right))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_key(*((x->left))), *((x->key))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(*((x->key)), treap_min_key(*((x->right)))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_prio(*((x->left))), *((x->prio))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(treap_max_prio(*((x->right))), *((x->prio))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap($s, $phys_ptr_cast(P#x, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(P#x, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_reach(x), @_vcc_oset_union(@_vcc_oset_singleton(x), @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(P#x, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(P#x, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_keys(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->key))), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), @\int_max(treap_max_key(*((x->left))), treap_max_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), @\int_max(treap_max_prio(*((x->left))), treap_max_prio(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), @\int_min(treap_min_key(*((x->left))), treap_min_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_prios(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->prio))), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // _math \state _dryad_S0#13; 
            // _dryad_S0#13 := @_vcc_current_state(@state); 
            _dryad_S0#13 := $current_state($s);
            // _math \state stmtexpr2#28; 
            // stmtexpr2#28 := _dryad_S0#13; 
            stmtexpr2#28 := _dryad_S0#13;
            // non-pure function
            // tmp#8 := treap_insert_rec(xr#10, k, p); 
            call tmp#8 := treap_insert_rec($phys_ptr_cast(xr#10, ^b_node), P#k, P#p);
            assume $full_stop_ext(#tok$3^69.21, $s);
            // _math \state _dryad_S1#14; 
            // _dryad_S1#14 := @_vcc_current_state(@state); 
            _dryad_S1#14 := $current_state($s);
            // _math \state stmtexpr3#29; 
            // stmtexpr3#29 := _dryad_S1#14; 
            stmtexpr3#29 := _dryad_S1#14;
            // assume @_vcc_oset_disjoint(treap_reach(tmp#8), @_vcc_oset_diff(_dryad_G1, old(_dryad_S0#13, treap_reach(xr#10)))); 
            assume $oset_disjoint(F#treap_reach($s, $phys_ptr_cast(tmp#8, ^b_node)), $oset_diff(SL#_dryad_G1, F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node))));
            // _math \oset res_treap_reach#2; 
            // res_treap_reach#2 := treap_reach(tmp#8); 
            call res_treap_reach#2 := treap_reach($phys_ptr_cast(tmp#8, ^b_node));
            assume $full_stop_ext(#tok$4^0.0, $s);
            // _dryad_G1 := @_vcc_oset_union(res_treap_reach#2, @_vcc_oset_diff(_dryad_G1, pure(old(_dryad_S0#13, treap_reach(xr#10))))); 
            SL#_dryad_G1 := $oset_union(res_treap_reach#2, $oset_diff(SL#_dryad_G1, F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node))));
            // _math \oset stmtexpr4#30; 
            // stmtexpr4#30 := _dryad_G1; 
            stmtexpr4#30 := SL#_dryad_G1;
            // assume ==(glob_reach(), _dryad_G1); 
            assume F#glob_reach() == SL#_dryad_G1;
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#13, treap_reach(xr#10)), old(_dryad_S0#13, treap_reach(x1#12))), ==(old(_dryad_S0#13, treap(x1#12)), old(_dryad_S1#14, treap(x1#12)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node)), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(x1#12, ^b_node))) ==> F#treap(_dryad_S0#13, $phys_ptr_cast(x1#12, ^b_node)) == F#treap(_dryad_S1#14, $phys_ptr_cast(x1#12, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#13, treap_reach(xr#10)), old(_dryad_S0#13, treap_reach(x1#12))), ==(old(_dryad_S0#13, treap_reach(x1#12)), old(_dryad_S1#14, treap_reach(x1#12)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node)), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(x1#12, ^b_node))) ==> F#treap_reach(_dryad_S0#13, $phys_ptr_cast(x1#12, ^b_node)) == F#treap_reach(_dryad_S1#14, $phys_ptr_cast(x1#12, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#13, treap_reach(xr#10)), old(_dryad_S0#13, treap_reach(x1#12))), ==(old(_dryad_S0#13, treap_keys(x1#12)), old(_dryad_S1#14, treap_keys(x1#12)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node)), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(x1#12, ^b_node))) ==> F#treap_keys(_dryad_S0#13, $phys_ptr_cast(x1#12, ^b_node)) == F#treap_keys(_dryad_S1#14, $phys_ptr_cast(x1#12, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#13, treap_reach(xr#10)), old(_dryad_S0#13, treap_reach(x1#12))), ==(old(_dryad_S0#13, treap_max_key(x1#12)), old(_dryad_S1#14, treap_max_key(x1#12)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node)), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(x1#12, ^b_node))) ==> F#treap_max_key(_dryad_S0#13, $phys_ptr_cast(x1#12, ^b_node)) == F#treap_max_key(_dryad_S1#14, $phys_ptr_cast(x1#12, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#13, treap_reach(xr#10)), old(_dryad_S0#13, treap_reach(x1#12))), ==(old(_dryad_S0#13, treap_max_prio(x1#12)), old(_dryad_S1#14, treap_max_prio(x1#12)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node)), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(x1#12, ^b_node))) ==> F#treap_max_prio(_dryad_S0#13, $phys_ptr_cast(x1#12, ^b_node)) == F#treap_max_prio(_dryad_S1#14, $phys_ptr_cast(x1#12, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#13, treap_reach(xr#10)), old(_dryad_S0#13, treap_reach(x1#12))), ==(old(_dryad_S0#13, treap_min_key(x1#12)), old(_dryad_S1#14, treap_min_key(x1#12)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node)), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(x1#12, ^b_node))) ==> F#treap_min_key(_dryad_S0#13, $phys_ptr_cast(x1#12, ^b_node)) == F#treap_min_key(_dryad_S1#14, $phys_ptr_cast(x1#12, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#13, treap_reach(xr#10)), old(_dryad_S0#13, treap_reach(x1#12))), ==(old(_dryad_S0#13, treap_prios(x1#12)), old(_dryad_S1#14, treap_prios(x1#12)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node)), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(x1#12, ^b_node))) ==> F#treap_prios(_dryad_S0#13, $phys_ptr_cast(x1#12, ^b_node)) == F#treap_prios(_dryad_S1#14, $phys_ptr_cast(x1#12, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#13, treap_reach(xr#10)), old(_dryad_S0#13, treap_reach(x0#11))), ==(old(_dryad_S0#13, treap(x0#11)), old(_dryad_S1#14, treap(x0#11)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node)), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(x0#11, ^b_node))) ==> F#treap(_dryad_S0#13, $phys_ptr_cast(x0#11, ^b_node)) == F#treap(_dryad_S1#14, $phys_ptr_cast(x0#11, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#13, treap_reach(xr#10)), old(_dryad_S0#13, treap_reach(x0#11))), ==(old(_dryad_S0#13, treap_reach(x0#11)), old(_dryad_S1#14, treap_reach(x0#11)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node)), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(x0#11, ^b_node))) ==> F#treap_reach(_dryad_S0#13, $phys_ptr_cast(x0#11, ^b_node)) == F#treap_reach(_dryad_S1#14, $phys_ptr_cast(x0#11, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#13, treap_reach(xr#10)), old(_dryad_S0#13, treap_reach(x0#11))), ==(old(_dryad_S0#13, treap_keys(x0#11)), old(_dryad_S1#14, treap_keys(x0#11)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node)), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(x0#11, ^b_node))) ==> F#treap_keys(_dryad_S0#13, $phys_ptr_cast(x0#11, ^b_node)) == F#treap_keys(_dryad_S1#14, $phys_ptr_cast(x0#11, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#13, treap_reach(xr#10)), old(_dryad_S0#13, treap_reach(x0#11))), ==(old(_dryad_S0#13, treap_max_key(x0#11)), old(_dryad_S1#14, treap_max_key(x0#11)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node)), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(x0#11, ^b_node))) ==> F#treap_max_key(_dryad_S0#13, $phys_ptr_cast(x0#11, ^b_node)) == F#treap_max_key(_dryad_S1#14, $phys_ptr_cast(x0#11, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#13, treap_reach(xr#10)), old(_dryad_S0#13, treap_reach(x0#11))), ==(old(_dryad_S0#13, treap_max_prio(x0#11)), old(_dryad_S1#14, treap_max_prio(x0#11)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node)), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(x0#11, ^b_node))) ==> F#treap_max_prio(_dryad_S0#13, $phys_ptr_cast(x0#11, ^b_node)) == F#treap_max_prio(_dryad_S1#14, $phys_ptr_cast(x0#11, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#13, treap_reach(xr#10)), old(_dryad_S0#13, treap_reach(x0#11))), ==(old(_dryad_S0#13, treap_min_key(x0#11)), old(_dryad_S1#14, treap_min_key(x0#11)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node)), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(x0#11, ^b_node))) ==> F#treap_min_key(_dryad_S0#13, $phys_ptr_cast(x0#11, ^b_node)) == F#treap_min_key(_dryad_S1#14, $phys_ptr_cast(x0#11, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#13, treap_reach(xr#10)), old(_dryad_S0#13, treap_reach(x0#11))), ==(old(_dryad_S0#13, treap_prios(x0#11)), old(_dryad_S1#14, treap_prios(x0#11)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node)), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(x0#11, ^b_node))) ==> F#treap_prios(_dryad_S0#13, $phys_ptr_cast(x0#11, ^b_node)) == F#treap_prios(_dryad_S1#14, $phys_ptr_cast(x0#11, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#13, treap_reach(xr#10)), old(_dryad_S0#13, treap_reach(xr#10))), ==(old(_dryad_S0#13, treap(xr#10)), old(_dryad_S1#14, treap(xr#10)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node)), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node))) ==> F#treap(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node)) == F#treap(_dryad_S1#14, $phys_ptr_cast(xr#10, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#13, treap_reach(xr#10)), old(_dryad_S0#13, treap_reach(xr#10))), ==(old(_dryad_S0#13, treap_reach(xr#10)), old(_dryad_S1#14, treap_reach(xr#10)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node)), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node))) ==> F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node)) == F#treap_reach(_dryad_S1#14, $phys_ptr_cast(xr#10, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#13, treap_reach(xr#10)), old(_dryad_S0#13, treap_reach(xr#10))), ==(old(_dryad_S0#13, treap_keys(xr#10)), old(_dryad_S1#14, treap_keys(xr#10)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node)), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node))) ==> F#treap_keys(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node)) == F#treap_keys(_dryad_S1#14, $phys_ptr_cast(xr#10, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#13, treap_reach(xr#10)), old(_dryad_S0#13, treap_reach(xr#10))), ==(old(_dryad_S0#13, treap_max_key(xr#10)), old(_dryad_S1#14, treap_max_key(xr#10)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node)), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node))) ==> F#treap_max_key(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node)) == F#treap_max_key(_dryad_S1#14, $phys_ptr_cast(xr#10, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#13, treap_reach(xr#10)), old(_dryad_S0#13, treap_reach(xr#10))), ==(old(_dryad_S0#13, treap_max_prio(xr#10)), old(_dryad_S1#14, treap_max_prio(xr#10)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node)), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node))) ==> F#treap_max_prio(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node)) == F#treap_max_prio(_dryad_S1#14, $phys_ptr_cast(xr#10, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#13, treap_reach(xr#10)), old(_dryad_S0#13, treap_reach(xr#10))), ==(old(_dryad_S0#13, treap_min_key(xr#10)), old(_dryad_S1#14, treap_min_key(xr#10)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node)), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node))) ==> F#treap_min_key(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node)) == F#treap_min_key(_dryad_S1#14, $phys_ptr_cast(xr#10, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#13, treap_reach(xr#10)), old(_dryad_S0#13, treap_reach(xr#10))), ==(old(_dryad_S0#13, treap_prios(xr#10)), old(_dryad_S1#14, treap_prios(xr#10)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node)), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node))) ==> F#treap_prios(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node)) == F#treap_prios(_dryad_S1#14, $phys_ptr_cast(xr#10, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#13, treap_reach(xr#10)), old(_dryad_S0#13, treap_reach(xl#9))), ==(old(_dryad_S0#13, treap(xl#9)), old(_dryad_S1#14, treap(xl#9)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node)), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xl#9, ^b_node))) ==> F#treap(_dryad_S0#13, $phys_ptr_cast(xl#9, ^b_node)) == F#treap(_dryad_S1#14, $phys_ptr_cast(xl#9, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#13, treap_reach(xr#10)), old(_dryad_S0#13, treap_reach(xl#9))), ==(old(_dryad_S0#13, treap_reach(xl#9)), old(_dryad_S1#14, treap_reach(xl#9)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node)), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xl#9, ^b_node))) ==> F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xl#9, ^b_node)) == F#treap_reach(_dryad_S1#14, $phys_ptr_cast(xl#9, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#13, treap_reach(xr#10)), old(_dryad_S0#13, treap_reach(xl#9))), ==(old(_dryad_S0#13, treap_keys(xl#9)), old(_dryad_S1#14, treap_keys(xl#9)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node)), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xl#9, ^b_node))) ==> F#treap_keys(_dryad_S0#13, $phys_ptr_cast(xl#9, ^b_node)) == F#treap_keys(_dryad_S1#14, $phys_ptr_cast(xl#9, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#13, treap_reach(xr#10)), old(_dryad_S0#13, treap_reach(xl#9))), ==(old(_dryad_S0#13, treap_max_key(xl#9)), old(_dryad_S1#14, treap_max_key(xl#9)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node)), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xl#9, ^b_node))) ==> F#treap_max_key(_dryad_S0#13, $phys_ptr_cast(xl#9, ^b_node)) == F#treap_max_key(_dryad_S1#14, $phys_ptr_cast(xl#9, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#13, treap_reach(xr#10)), old(_dryad_S0#13, treap_reach(xl#9))), ==(old(_dryad_S0#13, treap_max_prio(xl#9)), old(_dryad_S1#14, treap_max_prio(xl#9)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node)), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xl#9, ^b_node))) ==> F#treap_max_prio(_dryad_S0#13, $phys_ptr_cast(xl#9, ^b_node)) == F#treap_max_prio(_dryad_S1#14, $phys_ptr_cast(xl#9, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#13, treap_reach(xr#10)), old(_dryad_S0#13, treap_reach(xl#9))), ==(old(_dryad_S0#13, treap_min_key(xl#9)), old(_dryad_S1#14, treap_min_key(xl#9)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node)), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xl#9, ^b_node))) ==> F#treap_min_key(_dryad_S0#13, $phys_ptr_cast(xl#9, ^b_node)) == F#treap_min_key(_dryad_S1#14, $phys_ptr_cast(xl#9, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#13, treap_reach(xr#10)), old(_dryad_S0#13, treap_reach(xl#9))), ==(old(_dryad_S0#13, treap_prios(xl#9)), old(_dryad_S1#14, treap_prios(xl#9)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node)), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xl#9, ^b_node))) ==> F#treap_prios(_dryad_S0#13, $phys_ptr_cast(xl#9, ^b_node)) == F#treap_prios(_dryad_S1#14, $phys_ptr_cast(xl#9, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#13, treap_reach(xr#10)), old(_dryad_S0#13, treap_reach(x))), ==(old(_dryad_S0#13, treap(x)), old(_dryad_S1#14, treap(x)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node)), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap(_dryad_S0#13, $phys_ptr_cast(P#x, ^b_node)) == F#treap(_dryad_S1#14, $phys_ptr_cast(P#x, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#13, treap_reach(xr#10)), old(_dryad_S0#13, treap_reach(x))), ==(old(_dryad_S0#13, treap_reach(x)), old(_dryad_S1#14, treap_reach(x)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node)), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_reach(_dryad_S0#13, $phys_ptr_cast(P#x, ^b_node)) == F#treap_reach(_dryad_S1#14, $phys_ptr_cast(P#x, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#13, treap_reach(xr#10)), old(_dryad_S0#13, treap_reach(x))), ==(old(_dryad_S0#13, treap_keys(x)), old(_dryad_S1#14, treap_keys(x)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node)), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_keys(_dryad_S0#13, $phys_ptr_cast(P#x, ^b_node)) == F#treap_keys(_dryad_S1#14, $phys_ptr_cast(P#x, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#13, treap_reach(xr#10)), old(_dryad_S0#13, treap_reach(x))), ==(old(_dryad_S0#13, treap_max_key(x)), old(_dryad_S1#14, treap_max_key(x)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node)), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_max_key(_dryad_S0#13, $phys_ptr_cast(P#x, ^b_node)) == F#treap_max_key(_dryad_S1#14, $phys_ptr_cast(P#x, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#13, treap_reach(xr#10)), old(_dryad_S0#13, treap_reach(x))), ==(old(_dryad_S0#13, treap_max_prio(x)), old(_dryad_S1#14, treap_max_prio(x)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node)), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_max_prio(_dryad_S0#13, $phys_ptr_cast(P#x, ^b_node)) == F#treap_max_prio(_dryad_S1#14, $phys_ptr_cast(P#x, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#13, treap_reach(xr#10)), old(_dryad_S0#13, treap_reach(x))), ==(old(_dryad_S0#13, treap_min_key(x)), old(_dryad_S1#14, treap_min_key(x)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node)), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_min_key(_dryad_S0#13, $phys_ptr_cast(P#x, ^b_node)) == F#treap_min_key(_dryad_S1#14, $phys_ptr_cast(P#x, ^b_node));
            // assume ==>(@_vcc_oset_disjoint(old(_dryad_S0#13, treap_reach(xr#10)), old(_dryad_S0#13, treap_reach(x))), ==(old(_dryad_S0#13, treap_prios(x)), old(_dryad_S1#14, treap_prios(x)))); 
            assume $oset_disjoint(F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node)), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_prios(_dryad_S0#13, $phys_ptr_cast(P#x, ^b_node)) == F#treap_prios(_dryad_S1#14, $phys_ptr_cast(P#x, ^b_node));
            // assume ==>(@_vcc_ptr_neq_null(x1#12), ==(treap(x1#12), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x1#12->left))), treap(*((x1#12->right)))), unchecked!(@_vcc_oset_in(x1#12, @_vcc_oset_union(treap_reach(*((x1#12->left))), treap_reach(*((x1#12->right))))))), unchecked!(@_vcc_intset_in(*((x1#12->key)), @_vcc_intset_union(treap_keys(*((x1#12->left))), treap_keys(*((x1#12->right))))))), unchecked!(@_vcc_intset_in(*((x1#12->prio)), @_vcc_intset_union(treap_prios(*((x1#12->left))), treap_prios(*((x1#12->right))))))), @_vcc_oset_disjoint(treap_reach(*((x1#12->left))), treap_reach(*((x1#12->right))))), @_vcc_intset_disjoint(treap_keys(*((x1#12->left))), treap_keys(*((x1#12->right))))), @_vcc_intset_disjoint(treap_prios(*((x1#12->left))), treap_prios(*((x1#12->right))))), ==>(@_vcc_ptr_neq_null(*((x1#12->left))), <(treap_max_key(*((x1#12->left))), *((x1#12->key))))), ==>(@_vcc_ptr_neq_null(*((x1#12->right))), <(*((x1#12->key)), treap_min_key(*((x1#12->right)))))), ==>(@_vcc_ptr_neq_null(*((x1#12->left))), <(treap_max_prio(*((x1#12->left))), *((x1#12->prio))))), ==>(@_vcc_ptr_neq_null(*((x1#12->right))), <(treap_max_prio(*((x1#12->right))), *((x1#12->prio))))))); 
            assume $non_null($phys_ptr_cast(x1#12, ^b_node)) ==> F#treap($s, $phys_ptr_cast(x1#12, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(x1#12, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(x1#12, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(x1#12, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(x1#12, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x1#12), ==(treap_reach(x1#12), @_vcc_oset_union(@_vcc_oset_singleton(x1#12), @_vcc_oset_union(treap_reach(*((x1#12->left))), treap_reach(*((x1#12->right))))))); 
            assume $non_null($phys_ptr_cast(x1#12, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(x1#12, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(x1#12, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x1#12), ==(treap_keys(x1#12), @_vcc_intset_union(@_vcc_intset_singleton(*((x1#12->key))), @_vcc_intset_union(treap_keys(*((x1#12->left))), treap_keys(*((x1#12->right))))))); 
            assume $non_null($phys_ptr_cast(x1#12, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(x1#12, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x1#12), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x1#12->left))), @_vcc_ptr_neq_null(*((x1#12->right)))), ==(treap_max_key(x1#12), @\int_max(*((x1#12->key)), @\int_max(treap_max_key(*((x1#12->left))), treap_max_key(*((x1#12->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x1#12->left))), @_vcc_ptr_eq_null(*((x1#12->right)))), ==(treap_max_key(x1#12), @\int_max(*((x1#12->key)), treap_max_key(*((x1#12->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x1#12->left))), @_vcc_ptr_neq_null(*((x1#12->right)))), ==(treap_max_key(x1#12), @\int_max(*((x1#12->key)), treap_max_key(*((x1#12->right)))))))); 
            assume $non_null($phys_ptr_cast(x1#12, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x1#12), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x1#12->left))), @_vcc_ptr_neq_null(*((x1#12->right)))), ==(treap_max_prio(x1#12), @\int_max(*((x1#12->prio)), @\int_max(treap_max_prio(*((x1#12->left))), treap_max_prio(*((x1#12->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x1#12->left))), @_vcc_ptr_eq_null(*((x1#12->right)))), ==(treap_max_prio(x1#12), @\int_max(*((x1#12->prio)), treap_max_prio(*((x1#12->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x1#12->left))), @_vcc_ptr_neq_null(*((x1#12->right)))), ==(treap_max_prio(x1#12), @\int_max(*((x1#12->prio)), treap_max_prio(*((x1#12->right)))))))); 
            assume $non_null($phys_ptr_cast(x1#12, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(x1#12, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(x1#12, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(x1#12, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x1#12), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x1#12->left))), @_vcc_ptr_neq_null(*((x1#12->right)))), ==(treap_min_key(x1#12), @\int_min(*((x1#12->key)), @\int_min(treap_min_key(*((x1#12->left))), treap_min_key(*((x1#12->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x1#12->left))), @_vcc_ptr_eq_null(*((x1#12->right)))), ==(treap_min_key(x1#12), @\int_min(*((x1#12->key)), treap_min_key(*((x1#12->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x1#12->left))), @_vcc_ptr_neq_null(*((x1#12->right)))), ==(treap_min_key(x1#12), @\int_min(*((x1#12->key)), treap_min_key(*((x1#12->right)))))))); 
            assume $non_null($phys_ptr_cast(x1#12, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x1#12), ==(treap_prios(x1#12), @_vcc_intset_union(@_vcc_intset_singleton(*((x1#12->prio))), @_vcc_intset_union(treap_prios(*((x1#12->left))), treap_prios(*((x1#12->right))))))); 
            assume $non_null($phys_ptr_cast(x1#12, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(x1#12, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(x1#12, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x0#11), ==(treap(x0#11), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x0#11->left))), treap(*((x0#11->right)))), unchecked!(@_vcc_oset_in(x0#11, @_vcc_oset_union(treap_reach(*((x0#11->left))), treap_reach(*((x0#11->right))))))), unchecked!(@_vcc_intset_in(*((x0#11->key)), @_vcc_intset_union(treap_keys(*((x0#11->left))), treap_keys(*((x0#11->right))))))), unchecked!(@_vcc_intset_in(*((x0#11->prio)), @_vcc_intset_union(treap_prios(*((x0#11->left))), treap_prios(*((x0#11->right))))))), @_vcc_oset_disjoint(treap_reach(*((x0#11->left))), treap_reach(*((x0#11->right))))), @_vcc_intset_disjoint(treap_keys(*((x0#11->left))), treap_keys(*((x0#11->right))))), @_vcc_intset_disjoint(treap_prios(*((x0#11->left))), treap_prios(*((x0#11->right))))), ==>(@_vcc_ptr_neq_null(*((x0#11->left))), <(treap_max_key(*((x0#11->left))), *((x0#11->key))))), ==>(@_vcc_ptr_neq_null(*((x0#11->right))), <(*((x0#11->key)), treap_min_key(*((x0#11->right)))))), ==>(@_vcc_ptr_neq_null(*((x0#11->left))), <(treap_max_prio(*((x0#11->left))), *((x0#11->prio))))), ==>(@_vcc_ptr_neq_null(*((x0#11->right))), <(treap_max_prio(*((x0#11->right))), *((x0#11->prio))))))); 
            assume $non_null($phys_ptr_cast(x0#11, ^b_node)) ==> F#treap($s, $phys_ptr_cast(x0#11, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(x0#11, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(x0#11, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(x0#11, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(x0#11, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x0#11), ==(treap_reach(x0#11), @_vcc_oset_union(@_vcc_oset_singleton(x0#11), @_vcc_oset_union(treap_reach(*((x0#11->left))), treap_reach(*((x0#11->right))))))); 
            assume $non_null($phys_ptr_cast(x0#11, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(x0#11, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(x0#11, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x0#11), ==(treap_keys(x0#11), @_vcc_intset_union(@_vcc_intset_singleton(*((x0#11->key))), @_vcc_intset_union(treap_keys(*((x0#11->left))), treap_keys(*((x0#11->right))))))); 
            assume $non_null($phys_ptr_cast(x0#11, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(x0#11, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x0#11), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x0#11->left))), @_vcc_ptr_neq_null(*((x0#11->right)))), ==(treap_max_key(x0#11), @\int_max(*((x0#11->key)), @\int_max(treap_max_key(*((x0#11->left))), treap_max_key(*((x0#11->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x0#11->left))), @_vcc_ptr_eq_null(*((x0#11->right)))), ==(treap_max_key(x0#11), @\int_max(*((x0#11->key)), treap_max_key(*((x0#11->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x0#11->left))), @_vcc_ptr_neq_null(*((x0#11->right)))), ==(treap_max_key(x0#11), @\int_max(*((x0#11->key)), treap_max_key(*((x0#11->right)))))))); 
            assume $non_null($phys_ptr_cast(x0#11, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x0#11), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x0#11->left))), @_vcc_ptr_neq_null(*((x0#11->right)))), ==(treap_max_prio(x0#11), @\int_max(*((x0#11->prio)), @\int_max(treap_max_prio(*((x0#11->left))), treap_max_prio(*((x0#11->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x0#11->left))), @_vcc_ptr_eq_null(*((x0#11->right)))), ==(treap_max_prio(x0#11), @\int_max(*((x0#11->prio)), treap_max_prio(*((x0#11->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x0#11->left))), @_vcc_ptr_neq_null(*((x0#11->right)))), ==(treap_max_prio(x0#11), @\int_max(*((x0#11->prio)), treap_max_prio(*((x0#11->right)))))))); 
            assume $non_null($phys_ptr_cast(x0#11, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(x0#11, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(x0#11, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(x0#11, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x0#11), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x0#11->left))), @_vcc_ptr_neq_null(*((x0#11->right)))), ==(treap_min_key(x0#11), @\int_min(*((x0#11->key)), @\int_min(treap_min_key(*((x0#11->left))), treap_min_key(*((x0#11->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x0#11->left))), @_vcc_ptr_eq_null(*((x0#11->right)))), ==(treap_min_key(x0#11), @\int_min(*((x0#11->key)), treap_min_key(*((x0#11->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x0#11->left))), @_vcc_ptr_neq_null(*((x0#11->right)))), ==(treap_min_key(x0#11), @\int_min(*((x0#11->key)), treap_min_key(*((x0#11->right)))))))); 
            assume $non_null($phys_ptr_cast(x0#11, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x0#11), ==(treap_prios(x0#11), @_vcc_intset_union(@_vcc_intset_singleton(*((x0#11->prio))), @_vcc_intset_union(treap_prios(*((x0#11->left))), treap_prios(*((x0#11->right))))))); 
            assume $non_null($phys_ptr_cast(x0#11, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(x0#11, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(x0#11, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr#10), ==(treap(xr#10), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((xr#10->left))), treap(*((xr#10->right)))), unchecked!(@_vcc_oset_in(xr#10, @_vcc_oset_union(treap_reach(*((xr#10->left))), treap_reach(*((xr#10->right))))))), unchecked!(@_vcc_intset_in(*((xr#10->key)), @_vcc_intset_union(treap_keys(*((xr#10->left))), treap_keys(*((xr#10->right))))))), unchecked!(@_vcc_intset_in(*((xr#10->prio)), @_vcc_intset_union(treap_prios(*((xr#10->left))), treap_prios(*((xr#10->right))))))), @_vcc_oset_disjoint(treap_reach(*((xr#10->left))), treap_reach(*((xr#10->right))))), @_vcc_intset_disjoint(treap_keys(*((xr#10->left))), treap_keys(*((xr#10->right))))), @_vcc_intset_disjoint(treap_prios(*((xr#10->left))), treap_prios(*((xr#10->right))))), ==>(@_vcc_ptr_neq_null(*((xr#10->left))), <(treap_max_key(*((xr#10->left))), *((xr#10->key))))), ==>(@_vcc_ptr_neq_null(*((xr#10->right))), <(*((xr#10->key)), treap_min_key(*((xr#10->right)))))), ==>(@_vcc_ptr_neq_null(*((xr#10->left))), <(treap_max_prio(*((xr#10->left))), *((xr#10->prio))))), ==>(@_vcc_ptr_neq_null(*((xr#10->right))), <(treap_max_prio(*((xr#10->right))), *((xr#10->prio))))))); 
            assume $non_null($phys_ptr_cast(xr#10, ^b_node)) ==> F#treap($s, $phys_ptr_cast(xr#10, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(xr#10, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr#10), ==(treap_reach(xr#10), @_vcc_oset_union(@_vcc_oset_singleton(xr#10), @_vcc_oset_union(treap_reach(*((xr#10->left))), treap_reach(*((xr#10->right))))))); 
            assume $non_null($phys_ptr_cast(xr#10, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(xr#10, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(xr#10, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr#10), ==(treap_keys(xr#10), @_vcc_intset_union(@_vcc_intset_singleton(*((xr#10->key))), @_vcc_intset_union(treap_keys(*((xr#10->left))), treap_keys(*((xr#10->right))))))); 
            assume $non_null($phys_ptr_cast(xr#10, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(xr#10, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr#10), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr#10->left))), @_vcc_ptr_neq_null(*((xr#10->right)))), ==(treap_max_key(xr#10), @\int_max(*((xr#10->key)), @\int_max(treap_max_key(*((xr#10->left))), treap_max_key(*((xr#10->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr#10->left))), @_vcc_ptr_eq_null(*((xr#10->right)))), ==(treap_max_key(xr#10), @\int_max(*((xr#10->key)), treap_max_key(*((xr#10->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr#10->left))), @_vcc_ptr_neq_null(*((xr#10->right)))), ==(treap_max_key(xr#10), @\int_max(*((xr#10->key)), treap_max_key(*((xr#10->right)))))))); 
            assume $non_null($phys_ptr_cast(xr#10, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr#10), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr#10->left))), @_vcc_ptr_neq_null(*((xr#10->right)))), ==(treap_max_prio(xr#10), @\int_max(*((xr#10->prio)), @\int_max(treap_max_prio(*((xr#10->left))), treap_max_prio(*((xr#10->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr#10->left))), @_vcc_ptr_eq_null(*((xr#10->right)))), ==(treap_max_prio(xr#10), @\int_max(*((xr#10->prio)), treap_max_prio(*((xr#10->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr#10->left))), @_vcc_ptr_neq_null(*((xr#10->right)))), ==(treap_max_prio(xr#10), @\int_max(*((xr#10->prio)), treap_max_prio(*((xr#10->right)))))))); 
            assume $non_null($phys_ptr_cast(xr#10, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr#10), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr#10->left))), @_vcc_ptr_neq_null(*((xr#10->right)))), ==(treap_min_key(xr#10), @\int_min(*((xr#10->key)), @\int_min(treap_min_key(*((xr#10->left))), treap_min_key(*((xr#10->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr#10->left))), @_vcc_ptr_eq_null(*((xr#10->right)))), ==(treap_min_key(xr#10), @\int_min(*((xr#10->key)), treap_min_key(*((xr#10->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr#10->left))), @_vcc_ptr_neq_null(*((xr#10->right)))), ==(treap_min_key(xr#10), @\int_min(*((xr#10->key)), treap_min_key(*((xr#10->right)))))))); 
            assume $non_null($phys_ptr_cast(xr#10, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xr#10), ==(treap_prios(xr#10), @_vcc_intset_union(@_vcc_intset_singleton(*((xr#10->prio))), @_vcc_intset_union(treap_prios(*((xr#10->left))), treap_prios(*((xr#10->right))))))); 
            assume $non_null($phys_ptr_cast(xr#10, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(xr#10, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl#9), ==(treap(xl#9), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((xl#9->left))), treap(*((xl#9->right)))), unchecked!(@_vcc_oset_in(xl#9, @_vcc_oset_union(treap_reach(*((xl#9->left))), treap_reach(*((xl#9->right))))))), unchecked!(@_vcc_intset_in(*((xl#9->key)), @_vcc_intset_union(treap_keys(*((xl#9->left))), treap_keys(*((xl#9->right))))))), unchecked!(@_vcc_intset_in(*((xl#9->prio)), @_vcc_intset_union(treap_prios(*((xl#9->left))), treap_prios(*((xl#9->right))))))), @_vcc_oset_disjoint(treap_reach(*((xl#9->left))), treap_reach(*((xl#9->right))))), @_vcc_intset_disjoint(treap_keys(*((xl#9->left))), treap_keys(*((xl#9->right))))), @_vcc_intset_disjoint(treap_prios(*((xl#9->left))), treap_prios(*((xl#9->right))))), ==>(@_vcc_ptr_neq_null(*((xl#9->left))), <(treap_max_key(*((xl#9->left))), *((xl#9->key))))), ==>(@_vcc_ptr_neq_null(*((xl#9->right))), <(*((xl#9->key)), treap_min_key(*((xl#9->right)))))), ==>(@_vcc_ptr_neq_null(*((xl#9->left))), <(treap_max_prio(*((xl#9->left))), *((xl#9->prio))))), ==>(@_vcc_ptr_neq_null(*((xl#9->right))), <(treap_max_prio(*((xl#9->right))), *((xl#9->prio))))))); 
            assume $non_null($phys_ptr_cast(xl#9, ^b_node)) ==> F#treap($s, $phys_ptr_cast(xl#9, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(xl#9, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl#9), ==(treap_reach(xl#9), @_vcc_oset_union(@_vcc_oset_singleton(xl#9), @_vcc_oset_union(treap_reach(*((xl#9->left))), treap_reach(*((xl#9->right))))))); 
            assume $non_null($phys_ptr_cast(xl#9, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(xl#9, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(xl#9, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl#9), ==(treap_keys(xl#9), @_vcc_intset_union(@_vcc_intset_singleton(*((xl#9->key))), @_vcc_intset_union(treap_keys(*((xl#9->left))), treap_keys(*((xl#9->right))))))); 
            assume $non_null($phys_ptr_cast(xl#9, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(xl#9, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl#9), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl#9->left))), @_vcc_ptr_neq_null(*((xl#9->right)))), ==(treap_max_key(xl#9), @\int_max(*((xl#9->key)), @\int_max(treap_max_key(*((xl#9->left))), treap_max_key(*((xl#9->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl#9->left))), @_vcc_ptr_eq_null(*((xl#9->right)))), ==(treap_max_key(xl#9), @\int_max(*((xl#9->key)), treap_max_key(*((xl#9->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl#9->left))), @_vcc_ptr_neq_null(*((xl#9->right)))), ==(treap_max_key(xl#9), @\int_max(*((xl#9->key)), treap_max_key(*((xl#9->right)))))))); 
            assume $non_null($phys_ptr_cast(xl#9, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl#9), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl#9->left))), @_vcc_ptr_neq_null(*((xl#9->right)))), ==(treap_max_prio(xl#9), @\int_max(*((xl#9->prio)), @\int_max(treap_max_prio(*((xl#9->left))), treap_max_prio(*((xl#9->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl#9->left))), @_vcc_ptr_eq_null(*((xl#9->right)))), ==(treap_max_prio(xl#9), @\int_max(*((xl#9->prio)), treap_max_prio(*((xl#9->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl#9->left))), @_vcc_ptr_neq_null(*((xl#9->right)))), ==(treap_max_prio(xl#9), @\int_max(*((xl#9->prio)), treap_max_prio(*((xl#9->right)))))))); 
            assume $non_null($phys_ptr_cast(xl#9, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl#9), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl#9->left))), @_vcc_ptr_neq_null(*((xl#9->right)))), ==(treap_min_key(xl#9), @\int_min(*((xl#9->key)), @\int_min(treap_min_key(*((xl#9->left))), treap_min_key(*((xl#9->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl#9->left))), @_vcc_ptr_eq_null(*((xl#9->right)))), ==(treap_min_key(xl#9), @\int_min(*((xl#9->key)), treap_min_key(*((xl#9->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl#9->left))), @_vcc_ptr_neq_null(*((xl#9->right)))), ==(treap_min_key(xl#9), @\int_min(*((xl#9->key)), treap_min_key(*((xl#9->right)))))))); 
            assume $non_null($phys_ptr_cast(xl#9, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(xl#9), ==(treap_prios(xl#9), @_vcc_intset_union(@_vcc_intset_singleton(*((xl#9->prio))), @_vcc_intset_union(treap_prios(*((xl#9->left))), treap_prios(*((xl#9->right))))))); 
            assume $non_null($phys_ptr_cast(xl#9, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(xl#9, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(tmp#8), ==(treap(tmp#8), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((tmp#8->left))), treap(*((tmp#8->right)))), unchecked!(@_vcc_oset_in(tmp#8, @_vcc_oset_union(treap_reach(*((tmp#8->left))), treap_reach(*((tmp#8->right))))))), unchecked!(@_vcc_intset_in(*((tmp#8->key)), @_vcc_intset_union(treap_keys(*((tmp#8->left))), treap_keys(*((tmp#8->right))))))), unchecked!(@_vcc_intset_in(*((tmp#8->prio)), @_vcc_intset_union(treap_prios(*((tmp#8->left))), treap_prios(*((tmp#8->right))))))), @_vcc_oset_disjoint(treap_reach(*((tmp#8->left))), treap_reach(*((tmp#8->right))))), @_vcc_intset_disjoint(treap_keys(*((tmp#8->left))), treap_keys(*((tmp#8->right))))), @_vcc_intset_disjoint(treap_prios(*((tmp#8->left))), treap_prios(*((tmp#8->right))))), ==>(@_vcc_ptr_neq_null(*((tmp#8->left))), <(treap_max_key(*((tmp#8->left))), *((tmp#8->key))))), ==>(@_vcc_ptr_neq_null(*((tmp#8->right))), <(*((tmp#8->key)), treap_min_key(*((tmp#8->right)))))), ==>(@_vcc_ptr_neq_null(*((tmp#8->left))), <(treap_max_prio(*((tmp#8->left))), *((tmp#8->prio))))), ==>(@_vcc_ptr_neq_null(*((tmp#8->right))), <(treap_max_prio(*((tmp#8->right))), *((tmp#8->prio))))))); 
            assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> F#treap($s, $phys_ptr_cast(tmp#8, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(tmp#8, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(tmp#8), ==(treap_reach(tmp#8), @_vcc_oset_union(@_vcc_oset_singleton(tmp#8), @_vcc_oset_union(treap_reach(*((tmp#8->left))), treap_reach(*((tmp#8->right))))))); 
            assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(tmp#8, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(tmp#8, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(tmp#8), ==(treap_keys(tmp#8), @_vcc_intset_union(@_vcc_intset_singleton(*((tmp#8->key))), @_vcc_intset_union(treap_keys(*((tmp#8->left))), treap_keys(*((tmp#8->right))))))); 
            assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(tmp#8, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(tmp#8), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_max_key(tmp#8), @\int_max(*((tmp#8->key)), @\int_max(treap_max_key(*((tmp#8->left))), treap_max_key(*((tmp#8->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_eq_null(*((tmp#8->right)))), ==(treap_max_key(tmp#8), @\int_max(*((tmp#8->key)), treap_max_key(*((tmp#8->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_max_key(tmp#8), @\int_max(*((tmp#8->key)), treap_max_key(*((tmp#8->right)))))))); 
            assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(tmp#8), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_max_prio(tmp#8), @\int_max(*((tmp#8->prio)), @\int_max(treap_max_prio(*((tmp#8->left))), treap_max_prio(*((tmp#8->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_eq_null(*((tmp#8->right)))), ==(treap_max_prio(tmp#8), @\int_max(*((tmp#8->prio)), treap_max_prio(*((tmp#8->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_max_prio(tmp#8), @\int_max(*((tmp#8->prio)), treap_max_prio(*((tmp#8->right)))))))); 
            assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(tmp#8), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_min_key(tmp#8), @\int_min(*((tmp#8->key)), @\int_min(treap_min_key(*((tmp#8->left))), treap_min_key(*((tmp#8->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_eq_null(*((tmp#8->right)))), ==(treap_min_key(tmp#8), @\int_min(*((tmp#8->key)), treap_min_key(*((tmp#8->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_min_key(tmp#8), @\int_min(*((tmp#8->key)), treap_min_key(*((tmp#8->right)))))))); 
            assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(tmp#8), ==(treap_prios(tmp#8), @_vcc_intset_union(@_vcc_intset_singleton(*((tmp#8->prio))), @_vcc_intset_union(treap_prios(*((tmp#8->left))), treap_prios(*((tmp#8->right))))))); 
            assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(tmp#8, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap(x), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x->left))), treap(*((x->right)))), unchecked!(@_vcc_oset_in(x, @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->key)), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->prio)), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))), @_vcc_oset_disjoint(treap_reach(*((x->left))), treap_reach(*((x->right))))), @_vcc_intset_disjoint(treap_keys(*((x->left))), treap_keys(*((x->right))))), @_vcc_intset_disjoint(treap_prios(*((x->left))), treap_prios(*((x->right))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_key(*((x->left))), *((x->key))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(*((x->key)), treap_min_key(*((x->right)))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_prio(*((x->left))), *((x->prio))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(treap_max_prio(*((x->right))), *((x->prio))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap($s, $phys_ptr_cast(P#x, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(P#x, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_reach(x), @_vcc_oset_union(@_vcc_oset_singleton(x), @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(P#x, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(P#x, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_keys(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->key))), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), @\int_max(treap_max_key(*((x->left))), treap_max_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), @\int_max(treap_max_prio(*((x->left))), treap_max_prio(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), @\int_min(treap_min_key(*((x->left))), treap_min_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->right)))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_prios(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->prio))), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))); 
            assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
            // assume ==>(!(@_vcc_oset_in(x1#12, old(_dryad_S0#13, treap_reach(xr#10)))), @_vcc_ptr_eq_pure(*((x1#12->left)), old(_dryad_S0#13, *((x1#12->left))))); 
            assume !$oset_in($phys_ptr_cast(x1#12, ^b_node), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node))) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S0#13, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_oset_in(x1#12, old(_dryad_S0#13, treap_reach(xr#10)))), @_vcc_ptr_eq_pure(*((x1#12->right)), old(_dryad_S0#13, *((x1#12->right))))); 
            assume !$oset_in($phys_ptr_cast(x1#12, ^b_node), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node))) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S0#13, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_oset_in(x1#12, old(_dryad_S0#13, treap_reach(xr#10)))), ==(*((x1#12->key)), old(_dryad_S0#13, *((x1#12->key))))); 
            assume !$oset_in($phys_ptr_cast(x1#12, ^b_node), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node))) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)) == $rd_inv(_dryad_S0#13, b_node.key, $phys_ptr_cast(x1#12, ^b_node));
            // assume ==>(!(@_vcc_oset_in(x1#12, old(_dryad_S0#13, treap_reach(xr#10)))), ==(*((x1#12->prio)), old(_dryad_S0#13, *((x1#12->prio))))); 
            assume !$oset_in($phys_ptr_cast(x1#12, ^b_node), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node))) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(x1#12, ^b_node)) == $rd_inv(_dryad_S0#13, b_node.prio, $phys_ptr_cast(x1#12, ^b_node));
            // assume ==>(!(@_vcc_oset_in(x0#11, old(_dryad_S0#13, treap_reach(xr#10)))), @_vcc_ptr_eq_pure(*((x0#11->left)), old(_dryad_S0#13, *((x0#11->left))))); 
            assume !$oset_in($phys_ptr_cast(x0#11, ^b_node), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node))) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S0#13, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_oset_in(x0#11, old(_dryad_S0#13, treap_reach(xr#10)))), @_vcc_ptr_eq_pure(*((x0#11->right)), old(_dryad_S0#13, *((x0#11->right))))); 
            assume !$oset_in($phys_ptr_cast(x0#11, ^b_node), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node))) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S0#13, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_oset_in(x0#11, old(_dryad_S0#13, treap_reach(xr#10)))), ==(*((x0#11->key)), old(_dryad_S0#13, *((x0#11->key))))); 
            assume !$oset_in($phys_ptr_cast(x0#11, ^b_node), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node))) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)) == $rd_inv(_dryad_S0#13, b_node.key, $phys_ptr_cast(x0#11, ^b_node));
            // assume ==>(!(@_vcc_oset_in(x0#11, old(_dryad_S0#13, treap_reach(xr#10)))), ==(*((x0#11->prio)), old(_dryad_S0#13, *((x0#11->prio))))); 
            assume !$oset_in($phys_ptr_cast(x0#11, ^b_node), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node))) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(x0#11, ^b_node)) == $rd_inv(_dryad_S0#13, b_node.prio, $phys_ptr_cast(x0#11, ^b_node));
            // assume ==>(!(@_vcc_oset_in(xr#10, old(_dryad_S0#13, treap_reach(xr#10)))), @_vcc_ptr_eq_pure(*((xr#10->left)), old(_dryad_S0#13, *((xr#10->left))))); 
            assume !$oset_in($phys_ptr_cast(xr#10, ^b_node), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node))) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S0#13, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_oset_in(xr#10, old(_dryad_S0#13, treap_reach(xr#10)))), @_vcc_ptr_eq_pure(*((xr#10->right)), old(_dryad_S0#13, *((xr#10->right))))); 
            assume !$oset_in($phys_ptr_cast(xr#10, ^b_node), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node))) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S0#13, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_oset_in(xr#10, old(_dryad_S0#13, treap_reach(xr#10)))), ==(*((xr#10->key)), old(_dryad_S0#13, *((xr#10->key))))); 
            assume !$oset_in($phys_ptr_cast(xr#10, ^b_node), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node))) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)) == $rd_inv(_dryad_S0#13, b_node.key, $phys_ptr_cast(xr#10, ^b_node));
            // assume ==>(!(@_vcc_oset_in(xr#10, old(_dryad_S0#13, treap_reach(xr#10)))), ==(*((xr#10->prio)), old(_dryad_S0#13, *((xr#10->prio))))); 
            assume !$oset_in($phys_ptr_cast(xr#10, ^b_node), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node))) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node)) == $rd_inv(_dryad_S0#13, b_node.prio, $phys_ptr_cast(xr#10, ^b_node));
            // assume ==>(!(@_vcc_oset_in(xl#9, old(_dryad_S0#13, treap_reach(xr#10)))), @_vcc_ptr_eq_pure(*((xl#9->left)), old(_dryad_S0#13, *((xl#9->left))))); 
            assume !$oset_in($phys_ptr_cast(xl#9, ^b_node), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node))) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S0#13, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_oset_in(xl#9, old(_dryad_S0#13, treap_reach(xr#10)))), @_vcc_ptr_eq_pure(*((xl#9->right)), old(_dryad_S0#13, *((xl#9->right))))); 
            assume !$oset_in($phys_ptr_cast(xl#9, ^b_node), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node))) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S0#13, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_oset_in(xl#9, old(_dryad_S0#13, treap_reach(xr#10)))), ==(*((xl#9->key)), old(_dryad_S0#13, *((xl#9->key))))); 
            assume !$oset_in($phys_ptr_cast(xl#9, ^b_node), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node))) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)) == $rd_inv(_dryad_S0#13, b_node.key, $phys_ptr_cast(xl#9, ^b_node));
            // assume ==>(!(@_vcc_oset_in(xl#9, old(_dryad_S0#13, treap_reach(xr#10)))), ==(*((xl#9->prio)), old(_dryad_S0#13, *((xl#9->prio))))); 
            assume !$oset_in($phys_ptr_cast(xl#9, ^b_node), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node))) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node)) == $rd_inv(_dryad_S0#13, b_node.prio, $phys_ptr_cast(xl#9, ^b_node));
            // assume ==>(!(@_vcc_oset_in(x, old(_dryad_S0#13, treap_reach(xr#10)))), @_vcc_ptr_eq_pure(*((x->left)), old(_dryad_S0#13, *((x->left))))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node))) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S0#13, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_oset_in(x, old(_dryad_S0#13, treap_reach(xr#10)))), @_vcc_ptr_eq_pure(*((x->right)), old(_dryad_S0#13, *((x->right))))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node))) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S0#13, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node);
            // assume ==>(!(@_vcc_oset_in(x, old(_dryad_S0#13, treap_reach(xr#10)))), ==(*((x->key)), old(_dryad_S0#13, *((x->key))))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node))) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) == $rd_inv(_dryad_S0#13, b_node.key, $phys_ptr_cast(P#x, ^b_node));
            // assume ==>(!(@_vcc_oset_in(x, old(_dryad_S0#13, treap_reach(xr#10)))), ==(*((x->prio)), old(_dryad_S0#13, *((x->prio))))); 
            assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S0#13, $phys_ptr_cast(xr#10, ^b_node))) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)) == $rd_inv(_dryad_S0#13, b_node.prio, $phys_ptr_cast(P#x, ^b_node));
            // assume ==>(@_vcc_ptr_neq_null(tmp#8), &&(@_vcc_mutable(@state, tmp#8), @writes_check(tmp#8))); 
            assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> $mutable($s, $phys_ptr_cast(tmp#8, ^b_node)) && $top_writable($s, #wrTime$3^5.3, $phys_ptr_cast(tmp#8, ^b_node));
            // assert @reads_check_normal((tmp#8->prio)); 
            assert $thread_local($s, $phys_ptr_cast(tmp#8, ^b_node));
            // assert @reads_check_normal((x->prio)); 
            assert $thread_local($s, $phys_ptr_cast(P#x, ^b_node));
            assume true;
            // if (<=(*((tmp#8->prio)), *((x->prio)))) ...
            if ($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node)) <= $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)))
            {
              anon5:
                // assume ==>(@_vcc_ptr_neq_null(x1#12), ==(treap(x1#12), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x1#12->left))), treap(*((x1#12->right)))), unchecked!(@_vcc_oset_in(x1#12, @_vcc_oset_union(treap_reach(*((x1#12->left))), treap_reach(*((x1#12->right))))))), unchecked!(@_vcc_intset_in(*((x1#12->key)), @_vcc_intset_union(treap_keys(*((x1#12->left))), treap_keys(*((x1#12->right))))))), unchecked!(@_vcc_intset_in(*((x1#12->prio)), @_vcc_intset_union(treap_prios(*((x1#12->left))), treap_prios(*((x1#12->right))))))), @_vcc_oset_disjoint(treap_reach(*((x1#12->left))), treap_reach(*((x1#12->right))))), @_vcc_intset_disjoint(treap_keys(*((x1#12->left))), treap_keys(*((x1#12->right))))), @_vcc_intset_disjoint(treap_prios(*((x1#12->left))), treap_prios(*((x1#12->right))))), ==>(@_vcc_ptr_neq_null(*((x1#12->left))), <(treap_max_key(*((x1#12->left))), *((x1#12->key))))), ==>(@_vcc_ptr_neq_null(*((x1#12->right))), <(*((x1#12->key)), treap_min_key(*((x1#12->right)))))), ==>(@_vcc_ptr_neq_null(*((x1#12->left))), <(treap_max_prio(*((x1#12->left))), *((x1#12->prio))))), ==>(@_vcc_ptr_neq_null(*((x1#12->right))), <(treap_max_prio(*((x1#12->right))), *((x1#12->prio))))))); 
                assume $non_null($phys_ptr_cast(x1#12, ^b_node)) ==> F#treap($s, $phys_ptr_cast(x1#12, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(x1#12, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(x1#12, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(x1#12, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(x1#12, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1#12), ==(treap_reach(x1#12), @_vcc_oset_union(@_vcc_oset_singleton(x1#12), @_vcc_oset_union(treap_reach(*((x1#12->left))), treap_reach(*((x1#12->right))))))); 
                assume $non_null($phys_ptr_cast(x1#12, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(x1#12, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(x1#12, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1#12), ==(treap_keys(x1#12), @_vcc_intset_union(@_vcc_intset_singleton(*((x1#12->key))), @_vcc_intset_union(treap_keys(*((x1#12->left))), treap_keys(*((x1#12->right))))))); 
                assume $non_null($phys_ptr_cast(x1#12, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(x1#12, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1#12), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x1#12->left))), @_vcc_ptr_neq_null(*((x1#12->right)))), ==(treap_max_key(x1#12), @\int_max(*((x1#12->key)), @\int_max(treap_max_key(*((x1#12->left))), treap_max_key(*((x1#12->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x1#12->left))), @_vcc_ptr_eq_null(*((x1#12->right)))), ==(treap_max_key(x1#12), @\int_max(*((x1#12->key)), treap_max_key(*((x1#12->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x1#12->left))), @_vcc_ptr_neq_null(*((x1#12->right)))), ==(treap_max_key(x1#12), @\int_max(*((x1#12->key)), treap_max_key(*((x1#12->right)))))))); 
                assume $non_null($phys_ptr_cast(x1#12, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1#12), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x1#12->left))), @_vcc_ptr_neq_null(*((x1#12->right)))), ==(treap_max_prio(x1#12), @\int_max(*((x1#12->prio)), @\int_max(treap_max_prio(*((x1#12->left))), treap_max_prio(*((x1#12->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x1#12->left))), @_vcc_ptr_eq_null(*((x1#12->right)))), ==(treap_max_prio(x1#12), @\int_max(*((x1#12->prio)), treap_max_prio(*((x1#12->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x1#12->left))), @_vcc_ptr_neq_null(*((x1#12->right)))), ==(treap_max_prio(x1#12), @\int_max(*((x1#12->prio)), treap_max_prio(*((x1#12->right)))))))); 
                assume $non_null($phys_ptr_cast(x1#12, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(x1#12, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(x1#12, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(x1#12, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1#12), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x1#12->left))), @_vcc_ptr_neq_null(*((x1#12->right)))), ==(treap_min_key(x1#12), @\int_min(*((x1#12->key)), @\int_min(treap_min_key(*((x1#12->left))), treap_min_key(*((x1#12->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x1#12->left))), @_vcc_ptr_eq_null(*((x1#12->right)))), ==(treap_min_key(x1#12), @\int_min(*((x1#12->key)), treap_min_key(*((x1#12->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x1#12->left))), @_vcc_ptr_neq_null(*((x1#12->right)))), ==(treap_min_key(x1#12), @\int_min(*((x1#12->key)), treap_min_key(*((x1#12->right)))))))); 
                assume $non_null($phys_ptr_cast(x1#12, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1#12), ==(treap_prios(x1#12), @_vcc_intset_union(@_vcc_intset_singleton(*((x1#12->prio))), @_vcc_intset_union(treap_prios(*((x1#12->left))), treap_prios(*((x1#12->right))))))); 
                assume $non_null($phys_ptr_cast(x1#12, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(x1#12, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(x1#12, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0#11), ==(treap(x0#11), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x0#11->left))), treap(*((x0#11->right)))), unchecked!(@_vcc_oset_in(x0#11, @_vcc_oset_union(treap_reach(*((x0#11->left))), treap_reach(*((x0#11->right))))))), unchecked!(@_vcc_intset_in(*((x0#11->key)), @_vcc_intset_union(treap_keys(*((x0#11->left))), treap_keys(*((x0#11->right))))))), unchecked!(@_vcc_intset_in(*((x0#11->prio)), @_vcc_intset_union(treap_prios(*((x0#11->left))), treap_prios(*((x0#11->right))))))), @_vcc_oset_disjoint(treap_reach(*((x0#11->left))), treap_reach(*((x0#11->right))))), @_vcc_intset_disjoint(treap_keys(*((x0#11->left))), treap_keys(*((x0#11->right))))), @_vcc_intset_disjoint(treap_prios(*((x0#11->left))), treap_prios(*((x0#11->right))))), ==>(@_vcc_ptr_neq_null(*((x0#11->left))), <(treap_max_key(*((x0#11->left))), *((x0#11->key))))), ==>(@_vcc_ptr_neq_null(*((x0#11->right))), <(*((x0#11->key)), treap_min_key(*((x0#11->right)))))), ==>(@_vcc_ptr_neq_null(*((x0#11->left))), <(treap_max_prio(*((x0#11->left))), *((x0#11->prio))))), ==>(@_vcc_ptr_neq_null(*((x0#11->right))), <(treap_max_prio(*((x0#11->right))), *((x0#11->prio))))))); 
                assume $non_null($phys_ptr_cast(x0#11, ^b_node)) ==> F#treap($s, $phys_ptr_cast(x0#11, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(x0#11, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(x0#11, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(x0#11, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(x0#11, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0#11), ==(treap_reach(x0#11), @_vcc_oset_union(@_vcc_oset_singleton(x0#11), @_vcc_oset_union(treap_reach(*((x0#11->left))), treap_reach(*((x0#11->right))))))); 
                assume $non_null($phys_ptr_cast(x0#11, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(x0#11, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(x0#11, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0#11), ==(treap_keys(x0#11), @_vcc_intset_union(@_vcc_intset_singleton(*((x0#11->key))), @_vcc_intset_union(treap_keys(*((x0#11->left))), treap_keys(*((x0#11->right))))))); 
                assume $non_null($phys_ptr_cast(x0#11, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(x0#11, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0#11), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x0#11->left))), @_vcc_ptr_neq_null(*((x0#11->right)))), ==(treap_max_key(x0#11), @\int_max(*((x0#11->key)), @\int_max(treap_max_key(*((x0#11->left))), treap_max_key(*((x0#11->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x0#11->left))), @_vcc_ptr_eq_null(*((x0#11->right)))), ==(treap_max_key(x0#11), @\int_max(*((x0#11->key)), treap_max_key(*((x0#11->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x0#11->left))), @_vcc_ptr_neq_null(*((x0#11->right)))), ==(treap_max_key(x0#11), @\int_max(*((x0#11->key)), treap_max_key(*((x0#11->right)))))))); 
                assume $non_null($phys_ptr_cast(x0#11, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0#11), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x0#11->left))), @_vcc_ptr_neq_null(*((x0#11->right)))), ==(treap_max_prio(x0#11), @\int_max(*((x0#11->prio)), @\int_max(treap_max_prio(*((x0#11->left))), treap_max_prio(*((x0#11->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x0#11->left))), @_vcc_ptr_eq_null(*((x0#11->right)))), ==(treap_max_prio(x0#11), @\int_max(*((x0#11->prio)), treap_max_prio(*((x0#11->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x0#11->left))), @_vcc_ptr_neq_null(*((x0#11->right)))), ==(treap_max_prio(x0#11), @\int_max(*((x0#11->prio)), treap_max_prio(*((x0#11->right)))))))); 
                assume $non_null($phys_ptr_cast(x0#11, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(x0#11, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(x0#11, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(x0#11, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0#11), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x0#11->left))), @_vcc_ptr_neq_null(*((x0#11->right)))), ==(treap_min_key(x0#11), @\int_min(*((x0#11->key)), @\int_min(treap_min_key(*((x0#11->left))), treap_min_key(*((x0#11->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x0#11->left))), @_vcc_ptr_eq_null(*((x0#11->right)))), ==(treap_min_key(x0#11), @\int_min(*((x0#11->key)), treap_min_key(*((x0#11->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x0#11->left))), @_vcc_ptr_neq_null(*((x0#11->right)))), ==(treap_min_key(x0#11), @\int_min(*((x0#11->key)), treap_min_key(*((x0#11->right)))))))); 
                assume $non_null($phys_ptr_cast(x0#11, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0#11), ==(treap_prios(x0#11), @_vcc_intset_union(@_vcc_intset_singleton(*((x0#11->prio))), @_vcc_intset_union(treap_prios(*((x0#11->left))), treap_prios(*((x0#11->right))))))); 
                assume $non_null($phys_ptr_cast(x0#11, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(x0#11, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(x0#11, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr#10), ==(treap(xr#10), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((xr#10->left))), treap(*((xr#10->right)))), unchecked!(@_vcc_oset_in(xr#10, @_vcc_oset_union(treap_reach(*((xr#10->left))), treap_reach(*((xr#10->right))))))), unchecked!(@_vcc_intset_in(*((xr#10->key)), @_vcc_intset_union(treap_keys(*((xr#10->left))), treap_keys(*((xr#10->right))))))), unchecked!(@_vcc_intset_in(*((xr#10->prio)), @_vcc_intset_union(treap_prios(*((xr#10->left))), treap_prios(*((xr#10->right))))))), @_vcc_oset_disjoint(treap_reach(*((xr#10->left))), treap_reach(*((xr#10->right))))), @_vcc_intset_disjoint(treap_keys(*((xr#10->left))), treap_keys(*((xr#10->right))))), @_vcc_intset_disjoint(treap_prios(*((xr#10->left))), treap_prios(*((xr#10->right))))), ==>(@_vcc_ptr_neq_null(*((xr#10->left))), <(treap_max_key(*((xr#10->left))), *((xr#10->key))))), ==>(@_vcc_ptr_neq_null(*((xr#10->right))), <(*((xr#10->key)), treap_min_key(*((xr#10->right)))))), ==>(@_vcc_ptr_neq_null(*((xr#10->left))), <(treap_max_prio(*((xr#10->left))), *((xr#10->prio))))), ==>(@_vcc_ptr_neq_null(*((xr#10->right))), <(treap_max_prio(*((xr#10->right))), *((xr#10->prio))))))); 
                assume $non_null($phys_ptr_cast(xr#10, ^b_node)) ==> F#treap($s, $phys_ptr_cast(xr#10, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(xr#10, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr#10), ==(treap_reach(xr#10), @_vcc_oset_union(@_vcc_oset_singleton(xr#10), @_vcc_oset_union(treap_reach(*((xr#10->left))), treap_reach(*((xr#10->right))))))); 
                assume $non_null($phys_ptr_cast(xr#10, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(xr#10, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(xr#10, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr#10), ==(treap_keys(xr#10), @_vcc_intset_union(@_vcc_intset_singleton(*((xr#10->key))), @_vcc_intset_union(treap_keys(*((xr#10->left))), treap_keys(*((xr#10->right))))))); 
                assume $non_null($phys_ptr_cast(xr#10, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(xr#10, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr#10), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr#10->left))), @_vcc_ptr_neq_null(*((xr#10->right)))), ==(treap_max_key(xr#10), @\int_max(*((xr#10->key)), @\int_max(treap_max_key(*((xr#10->left))), treap_max_key(*((xr#10->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr#10->left))), @_vcc_ptr_eq_null(*((xr#10->right)))), ==(treap_max_key(xr#10), @\int_max(*((xr#10->key)), treap_max_key(*((xr#10->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr#10->left))), @_vcc_ptr_neq_null(*((xr#10->right)))), ==(treap_max_key(xr#10), @\int_max(*((xr#10->key)), treap_max_key(*((xr#10->right)))))))); 
                assume $non_null($phys_ptr_cast(xr#10, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr#10), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr#10->left))), @_vcc_ptr_neq_null(*((xr#10->right)))), ==(treap_max_prio(xr#10), @\int_max(*((xr#10->prio)), @\int_max(treap_max_prio(*((xr#10->left))), treap_max_prio(*((xr#10->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr#10->left))), @_vcc_ptr_eq_null(*((xr#10->right)))), ==(treap_max_prio(xr#10), @\int_max(*((xr#10->prio)), treap_max_prio(*((xr#10->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr#10->left))), @_vcc_ptr_neq_null(*((xr#10->right)))), ==(treap_max_prio(xr#10), @\int_max(*((xr#10->prio)), treap_max_prio(*((xr#10->right)))))))); 
                assume $non_null($phys_ptr_cast(xr#10, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr#10), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr#10->left))), @_vcc_ptr_neq_null(*((xr#10->right)))), ==(treap_min_key(xr#10), @\int_min(*((xr#10->key)), @\int_min(treap_min_key(*((xr#10->left))), treap_min_key(*((xr#10->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr#10->left))), @_vcc_ptr_eq_null(*((xr#10->right)))), ==(treap_min_key(xr#10), @\int_min(*((xr#10->key)), treap_min_key(*((xr#10->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr#10->left))), @_vcc_ptr_neq_null(*((xr#10->right)))), ==(treap_min_key(xr#10), @\int_min(*((xr#10->key)), treap_min_key(*((xr#10->right)))))))); 
                assume $non_null($phys_ptr_cast(xr#10, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr#10), ==(treap_prios(xr#10), @_vcc_intset_union(@_vcc_intset_singleton(*((xr#10->prio))), @_vcc_intset_union(treap_prios(*((xr#10->left))), treap_prios(*((xr#10->right))))))); 
                assume $non_null($phys_ptr_cast(xr#10, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(xr#10, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl#9), ==(treap(xl#9), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((xl#9->left))), treap(*((xl#9->right)))), unchecked!(@_vcc_oset_in(xl#9, @_vcc_oset_union(treap_reach(*((xl#9->left))), treap_reach(*((xl#9->right))))))), unchecked!(@_vcc_intset_in(*((xl#9->key)), @_vcc_intset_union(treap_keys(*((xl#9->left))), treap_keys(*((xl#9->right))))))), unchecked!(@_vcc_intset_in(*((xl#9->prio)), @_vcc_intset_union(treap_prios(*((xl#9->left))), treap_prios(*((xl#9->right))))))), @_vcc_oset_disjoint(treap_reach(*((xl#9->left))), treap_reach(*((xl#9->right))))), @_vcc_intset_disjoint(treap_keys(*((xl#9->left))), treap_keys(*((xl#9->right))))), @_vcc_intset_disjoint(treap_prios(*((xl#9->left))), treap_prios(*((xl#9->right))))), ==>(@_vcc_ptr_neq_null(*((xl#9->left))), <(treap_max_key(*((xl#9->left))), *((xl#9->key))))), ==>(@_vcc_ptr_neq_null(*((xl#9->right))), <(*((xl#9->key)), treap_min_key(*((xl#9->right)))))), ==>(@_vcc_ptr_neq_null(*((xl#9->left))), <(treap_max_prio(*((xl#9->left))), *((xl#9->prio))))), ==>(@_vcc_ptr_neq_null(*((xl#9->right))), <(treap_max_prio(*((xl#9->right))), *((xl#9->prio))))))); 
                assume $non_null($phys_ptr_cast(xl#9, ^b_node)) ==> F#treap($s, $phys_ptr_cast(xl#9, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(xl#9, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl#9), ==(treap_reach(xl#9), @_vcc_oset_union(@_vcc_oset_singleton(xl#9), @_vcc_oset_union(treap_reach(*((xl#9->left))), treap_reach(*((xl#9->right))))))); 
                assume $non_null($phys_ptr_cast(xl#9, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(xl#9, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(xl#9, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl#9), ==(treap_keys(xl#9), @_vcc_intset_union(@_vcc_intset_singleton(*((xl#9->key))), @_vcc_intset_union(treap_keys(*((xl#9->left))), treap_keys(*((xl#9->right))))))); 
                assume $non_null($phys_ptr_cast(xl#9, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(xl#9, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl#9), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl#9->left))), @_vcc_ptr_neq_null(*((xl#9->right)))), ==(treap_max_key(xl#9), @\int_max(*((xl#9->key)), @\int_max(treap_max_key(*((xl#9->left))), treap_max_key(*((xl#9->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl#9->left))), @_vcc_ptr_eq_null(*((xl#9->right)))), ==(treap_max_key(xl#9), @\int_max(*((xl#9->key)), treap_max_key(*((xl#9->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl#9->left))), @_vcc_ptr_neq_null(*((xl#9->right)))), ==(treap_max_key(xl#9), @\int_max(*((xl#9->key)), treap_max_key(*((xl#9->right)))))))); 
                assume $non_null($phys_ptr_cast(xl#9, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl#9), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl#9->left))), @_vcc_ptr_neq_null(*((xl#9->right)))), ==(treap_max_prio(xl#9), @\int_max(*((xl#9->prio)), @\int_max(treap_max_prio(*((xl#9->left))), treap_max_prio(*((xl#9->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl#9->left))), @_vcc_ptr_eq_null(*((xl#9->right)))), ==(treap_max_prio(xl#9), @\int_max(*((xl#9->prio)), treap_max_prio(*((xl#9->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl#9->left))), @_vcc_ptr_neq_null(*((xl#9->right)))), ==(treap_max_prio(xl#9), @\int_max(*((xl#9->prio)), treap_max_prio(*((xl#9->right)))))))); 
                assume $non_null($phys_ptr_cast(xl#9, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl#9), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl#9->left))), @_vcc_ptr_neq_null(*((xl#9->right)))), ==(treap_min_key(xl#9), @\int_min(*((xl#9->key)), @\int_min(treap_min_key(*((xl#9->left))), treap_min_key(*((xl#9->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl#9->left))), @_vcc_ptr_eq_null(*((xl#9->right)))), ==(treap_min_key(xl#9), @\int_min(*((xl#9->key)), treap_min_key(*((xl#9->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl#9->left))), @_vcc_ptr_neq_null(*((xl#9->right)))), ==(treap_min_key(xl#9), @\int_min(*((xl#9->key)), treap_min_key(*((xl#9->right)))))))); 
                assume $non_null($phys_ptr_cast(xl#9, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl#9), ==(treap_prios(xl#9), @_vcc_intset_union(@_vcc_intset_singleton(*((xl#9->prio))), @_vcc_intset_union(treap_prios(*((xl#9->left))), treap_prios(*((xl#9->right))))))); 
                assume $non_null($phys_ptr_cast(xl#9, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(xl#9, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), ==(treap(tmp#8), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((tmp#8->left))), treap(*((tmp#8->right)))), unchecked!(@_vcc_oset_in(tmp#8, @_vcc_oset_union(treap_reach(*((tmp#8->left))), treap_reach(*((tmp#8->right))))))), unchecked!(@_vcc_intset_in(*((tmp#8->key)), @_vcc_intset_union(treap_keys(*((tmp#8->left))), treap_keys(*((tmp#8->right))))))), unchecked!(@_vcc_intset_in(*((tmp#8->prio)), @_vcc_intset_union(treap_prios(*((tmp#8->left))), treap_prios(*((tmp#8->right))))))), @_vcc_oset_disjoint(treap_reach(*((tmp#8->left))), treap_reach(*((tmp#8->right))))), @_vcc_intset_disjoint(treap_keys(*((tmp#8->left))), treap_keys(*((tmp#8->right))))), @_vcc_intset_disjoint(treap_prios(*((tmp#8->left))), treap_prios(*((tmp#8->right))))), ==>(@_vcc_ptr_neq_null(*((tmp#8->left))), <(treap_max_key(*((tmp#8->left))), *((tmp#8->key))))), ==>(@_vcc_ptr_neq_null(*((tmp#8->right))), <(*((tmp#8->key)), treap_min_key(*((tmp#8->right)))))), ==>(@_vcc_ptr_neq_null(*((tmp#8->left))), <(treap_max_prio(*((tmp#8->left))), *((tmp#8->prio))))), ==>(@_vcc_ptr_neq_null(*((tmp#8->right))), <(treap_max_prio(*((tmp#8->right))), *((tmp#8->prio))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> F#treap($s, $phys_ptr_cast(tmp#8, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(tmp#8, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), ==(treap_reach(tmp#8), @_vcc_oset_union(@_vcc_oset_singleton(tmp#8), @_vcc_oset_union(treap_reach(*((tmp#8->left))), treap_reach(*((tmp#8->right))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(tmp#8, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(tmp#8, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), ==(treap_keys(tmp#8), @_vcc_intset_union(@_vcc_intset_singleton(*((tmp#8->key))), @_vcc_intset_union(treap_keys(*((tmp#8->left))), treap_keys(*((tmp#8->right))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(tmp#8, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_max_key(tmp#8), @\int_max(*((tmp#8->key)), @\int_max(treap_max_key(*((tmp#8->left))), treap_max_key(*((tmp#8->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_eq_null(*((tmp#8->right)))), ==(treap_max_key(tmp#8), @\int_max(*((tmp#8->key)), treap_max_key(*((tmp#8->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_max_key(tmp#8), @\int_max(*((tmp#8->key)), treap_max_key(*((tmp#8->right)))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_max_prio(tmp#8), @\int_max(*((tmp#8->prio)), @\int_max(treap_max_prio(*((tmp#8->left))), treap_max_prio(*((tmp#8->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_eq_null(*((tmp#8->right)))), ==(treap_max_prio(tmp#8), @\int_max(*((tmp#8->prio)), treap_max_prio(*((tmp#8->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_max_prio(tmp#8), @\int_max(*((tmp#8->prio)), treap_max_prio(*((tmp#8->right)))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_min_key(tmp#8), @\int_min(*((tmp#8->key)), @\int_min(treap_min_key(*((tmp#8->left))), treap_min_key(*((tmp#8->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_eq_null(*((tmp#8->right)))), ==(treap_min_key(tmp#8), @\int_min(*((tmp#8->key)), treap_min_key(*((tmp#8->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_min_key(tmp#8), @\int_min(*((tmp#8->key)), treap_min_key(*((tmp#8->right)))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), ==(treap_prios(tmp#8), @_vcc_intset_union(@_vcc_intset_singleton(*((tmp#8->prio))), @_vcc_intset_union(treap_prios(*((tmp#8->left))), treap_prios(*((tmp#8->right))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(tmp#8, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), ==(treap(x), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x->left))), treap(*((x->right)))), unchecked!(@_vcc_oset_in(x, @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->key)), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->prio)), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))), @_vcc_oset_disjoint(treap_reach(*((x->left))), treap_reach(*((x->right))))), @_vcc_intset_disjoint(treap_keys(*((x->left))), treap_keys(*((x->right))))), @_vcc_intset_disjoint(treap_prios(*((x->left))), treap_prios(*((x->right))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_key(*((x->left))), *((x->key))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(*((x->key)), treap_min_key(*((x->right)))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_prio(*((x->left))), *((x->prio))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(treap_max_prio(*((x->right))), *((x->prio))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap($s, $phys_ptr_cast(P#x, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(P#x, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_reach(x), @_vcc_oset_union(@_vcc_oset_singleton(x), @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(P#x, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(P#x, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_keys(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->key))), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), @\int_max(treap_max_key(*((x->left))), treap_max_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->right)))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), @\int_max(treap_max_prio(*((x->left))), treap_max_prio(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->right)))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), @\int_min(treap_min_key(*((x->left))), treap_min_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->right)))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_prios(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->prio))), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // _math \state _dryad_S2#15; 
                // _dryad_S2#15 := @_vcc_current_state(@state); 
                _dryad_S2#15 := $current_state($s);
                // _math \state stmtexpr0#31; 
                // stmtexpr0#31 := _dryad_S2#15; 
                stmtexpr0#31 := _dryad_S2#15;
                // assert @prim_writes_check((x->right)); 
                assert $writable_prim($s, #wrTime$3^5.3, $dot($phys_ptr_cast(P#x, ^b_node), b_node.right));
                // *(x->right) := tmp#8; 
                call $write_int(b_node.right, $phys_ptr_cast(P#x, ^b_node), $ptr_to_int($phys_ptr_cast(tmp#8, ^b_node)));
                assume $full_stop_ext(#tok$3^74.9, $s);
                // _math \state _dryad_S3#16; 
                // _dryad_S3#16 := @_vcc_current_state(@state); 
                _dryad_S3#16 := $current_state($s);
                // _math \state stmtexpr1#32; 
                // stmtexpr1#32 := _dryad_S3#16; 
                stmtexpr1#32 := _dryad_S3#16;
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#15, treap_reach(*((x->left)))))), ==(old(_dryad_S2#15, treap(*((x->left)))), old(_dryad_S3#16, treap(*((x->left)))))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#15, $rd_phys_ptr(_dryad_S2#15, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node))) ==> F#treap(_dryad_S2#15, $rd_phys_ptr(_dryad_S2#15, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) == F#treap(_dryad_S3#16, $rd_phys_ptr(_dryad_S3#16, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#15, treap_reach(*((x->left)))))), ==(old(_dryad_S2#15, treap_reach(*((x->left)))), old(_dryad_S3#16, treap_reach(*((x->left)))))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#15, $rd_phys_ptr(_dryad_S2#15, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node))) ==> F#treap_reach(_dryad_S2#15, $rd_phys_ptr(_dryad_S2#15, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) == F#treap_reach(_dryad_S3#16, $rd_phys_ptr(_dryad_S3#16, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#15, treap_reach(*((x->left)))))), ==(old(_dryad_S2#15, treap_keys(*((x->left)))), old(_dryad_S3#16, treap_keys(*((x->left)))))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#15, $rd_phys_ptr(_dryad_S2#15, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node))) ==> F#treap_keys(_dryad_S2#15, $rd_phys_ptr(_dryad_S2#15, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) == F#treap_keys(_dryad_S3#16, $rd_phys_ptr(_dryad_S3#16, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#15, treap_reach(*((x->left)))))), ==(old(_dryad_S2#15, treap_max_key(*((x->left)))), old(_dryad_S3#16, treap_max_key(*((x->left)))))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#15, $rd_phys_ptr(_dryad_S2#15, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node))) ==> F#treap_max_key(_dryad_S2#15, $rd_phys_ptr(_dryad_S2#15, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) == F#treap_max_key(_dryad_S3#16, $rd_phys_ptr(_dryad_S3#16, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#15, treap_reach(*((x->left)))))), ==(old(_dryad_S2#15, treap_max_prio(*((x->left)))), old(_dryad_S3#16, treap_max_prio(*((x->left)))))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#15, $rd_phys_ptr(_dryad_S2#15, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node))) ==> F#treap_max_prio(_dryad_S2#15, $rd_phys_ptr(_dryad_S2#15, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) == F#treap_max_prio(_dryad_S3#16, $rd_phys_ptr(_dryad_S3#16, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#15, treap_reach(*((x->left)))))), ==(old(_dryad_S2#15, treap_min_key(*((x->left)))), old(_dryad_S3#16, treap_min_key(*((x->left)))))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#15, $rd_phys_ptr(_dryad_S2#15, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node))) ==> F#treap_min_key(_dryad_S2#15, $rd_phys_ptr(_dryad_S2#15, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) == F#treap_min_key(_dryad_S3#16, $rd_phys_ptr(_dryad_S3#16, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#15, treap_reach(*((x->left)))))), ==(old(_dryad_S2#15, treap_prios(*((x->left)))), old(_dryad_S3#16, treap_prios(*((x->left)))))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#15, $rd_phys_ptr(_dryad_S2#15, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node))) ==> F#treap_prios(_dryad_S2#15, $rd_phys_ptr(_dryad_S2#15, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) == F#treap_prios(_dryad_S3#16, $rd_phys_ptr(_dryad_S3#16, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#15, treap_reach(x1#12)))), ==(old(_dryad_S2#15, treap(x1#12)), old(_dryad_S3#16, treap(x1#12)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#15, $phys_ptr_cast(x1#12, ^b_node))) ==> F#treap(_dryad_S2#15, $phys_ptr_cast(x1#12, ^b_node)) == F#treap(_dryad_S3#16, $phys_ptr_cast(x1#12, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#15, treap_reach(x1#12)))), ==(old(_dryad_S2#15, treap_reach(x1#12)), old(_dryad_S3#16, treap_reach(x1#12)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#15, $phys_ptr_cast(x1#12, ^b_node))) ==> F#treap_reach(_dryad_S2#15, $phys_ptr_cast(x1#12, ^b_node)) == F#treap_reach(_dryad_S3#16, $phys_ptr_cast(x1#12, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#15, treap_reach(x1#12)))), ==(old(_dryad_S2#15, treap_keys(x1#12)), old(_dryad_S3#16, treap_keys(x1#12)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#15, $phys_ptr_cast(x1#12, ^b_node))) ==> F#treap_keys(_dryad_S2#15, $phys_ptr_cast(x1#12, ^b_node)) == F#treap_keys(_dryad_S3#16, $phys_ptr_cast(x1#12, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#15, treap_reach(x1#12)))), ==(old(_dryad_S2#15, treap_max_key(x1#12)), old(_dryad_S3#16, treap_max_key(x1#12)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#15, $phys_ptr_cast(x1#12, ^b_node))) ==> F#treap_max_key(_dryad_S2#15, $phys_ptr_cast(x1#12, ^b_node)) == F#treap_max_key(_dryad_S3#16, $phys_ptr_cast(x1#12, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#15, treap_reach(x1#12)))), ==(old(_dryad_S2#15, treap_max_prio(x1#12)), old(_dryad_S3#16, treap_max_prio(x1#12)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#15, $phys_ptr_cast(x1#12, ^b_node))) ==> F#treap_max_prio(_dryad_S2#15, $phys_ptr_cast(x1#12, ^b_node)) == F#treap_max_prio(_dryad_S3#16, $phys_ptr_cast(x1#12, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#15, treap_reach(x1#12)))), ==(old(_dryad_S2#15, treap_min_key(x1#12)), old(_dryad_S3#16, treap_min_key(x1#12)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#15, $phys_ptr_cast(x1#12, ^b_node))) ==> F#treap_min_key(_dryad_S2#15, $phys_ptr_cast(x1#12, ^b_node)) == F#treap_min_key(_dryad_S3#16, $phys_ptr_cast(x1#12, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#15, treap_reach(x1#12)))), ==(old(_dryad_S2#15, treap_prios(x1#12)), old(_dryad_S3#16, treap_prios(x1#12)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#15, $phys_ptr_cast(x1#12, ^b_node))) ==> F#treap_prios(_dryad_S2#15, $phys_ptr_cast(x1#12, ^b_node)) == F#treap_prios(_dryad_S3#16, $phys_ptr_cast(x1#12, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#15, treap_reach(x0#11)))), ==(old(_dryad_S2#15, treap(x0#11)), old(_dryad_S3#16, treap(x0#11)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#15, $phys_ptr_cast(x0#11, ^b_node))) ==> F#treap(_dryad_S2#15, $phys_ptr_cast(x0#11, ^b_node)) == F#treap(_dryad_S3#16, $phys_ptr_cast(x0#11, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#15, treap_reach(x0#11)))), ==(old(_dryad_S2#15, treap_reach(x0#11)), old(_dryad_S3#16, treap_reach(x0#11)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#15, $phys_ptr_cast(x0#11, ^b_node))) ==> F#treap_reach(_dryad_S2#15, $phys_ptr_cast(x0#11, ^b_node)) == F#treap_reach(_dryad_S3#16, $phys_ptr_cast(x0#11, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#15, treap_reach(x0#11)))), ==(old(_dryad_S2#15, treap_keys(x0#11)), old(_dryad_S3#16, treap_keys(x0#11)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#15, $phys_ptr_cast(x0#11, ^b_node))) ==> F#treap_keys(_dryad_S2#15, $phys_ptr_cast(x0#11, ^b_node)) == F#treap_keys(_dryad_S3#16, $phys_ptr_cast(x0#11, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#15, treap_reach(x0#11)))), ==(old(_dryad_S2#15, treap_max_key(x0#11)), old(_dryad_S3#16, treap_max_key(x0#11)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#15, $phys_ptr_cast(x0#11, ^b_node))) ==> F#treap_max_key(_dryad_S2#15, $phys_ptr_cast(x0#11, ^b_node)) == F#treap_max_key(_dryad_S3#16, $phys_ptr_cast(x0#11, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#15, treap_reach(x0#11)))), ==(old(_dryad_S2#15, treap_max_prio(x0#11)), old(_dryad_S3#16, treap_max_prio(x0#11)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#15, $phys_ptr_cast(x0#11, ^b_node))) ==> F#treap_max_prio(_dryad_S2#15, $phys_ptr_cast(x0#11, ^b_node)) == F#treap_max_prio(_dryad_S3#16, $phys_ptr_cast(x0#11, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#15, treap_reach(x0#11)))), ==(old(_dryad_S2#15, treap_min_key(x0#11)), old(_dryad_S3#16, treap_min_key(x0#11)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#15, $phys_ptr_cast(x0#11, ^b_node))) ==> F#treap_min_key(_dryad_S2#15, $phys_ptr_cast(x0#11, ^b_node)) == F#treap_min_key(_dryad_S3#16, $phys_ptr_cast(x0#11, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#15, treap_reach(x0#11)))), ==(old(_dryad_S2#15, treap_prios(x0#11)), old(_dryad_S3#16, treap_prios(x0#11)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#15, $phys_ptr_cast(x0#11, ^b_node))) ==> F#treap_prios(_dryad_S2#15, $phys_ptr_cast(x0#11, ^b_node)) == F#treap_prios(_dryad_S3#16, $phys_ptr_cast(x0#11, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#15, treap_reach(xr#10)))), ==(old(_dryad_S2#15, treap(xr#10)), old(_dryad_S3#16, treap(xr#10)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#15, $phys_ptr_cast(xr#10, ^b_node))) ==> F#treap(_dryad_S2#15, $phys_ptr_cast(xr#10, ^b_node)) == F#treap(_dryad_S3#16, $phys_ptr_cast(xr#10, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#15, treap_reach(xr#10)))), ==(old(_dryad_S2#15, treap_reach(xr#10)), old(_dryad_S3#16, treap_reach(xr#10)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#15, $phys_ptr_cast(xr#10, ^b_node))) ==> F#treap_reach(_dryad_S2#15, $phys_ptr_cast(xr#10, ^b_node)) == F#treap_reach(_dryad_S3#16, $phys_ptr_cast(xr#10, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#15, treap_reach(xr#10)))), ==(old(_dryad_S2#15, treap_keys(xr#10)), old(_dryad_S3#16, treap_keys(xr#10)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#15, $phys_ptr_cast(xr#10, ^b_node))) ==> F#treap_keys(_dryad_S2#15, $phys_ptr_cast(xr#10, ^b_node)) == F#treap_keys(_dryad_S3#16, $phys_ptr_cast(xr#10, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#15, treap_reach(xr#10)))), ==(old(_dryad_S2#15, treap_max_key(xr#10)), old(_dryad_S3#16, treap_max_key(xr#10)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#15, $phys_ptr_cast(xr#10, ^b_node))) ==> F#treap_max_key(_dryad_S2#15, $phys_ptr_cast(xr#10, ^b_node)) == F#treap_max_key(_dryad_S3#16, $phys_ptr_cast(xr#10, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#15, treap_reach(xr#10)))), ==(old(_dryad_S2#15, treap_max_prio(xr#10)), old(_dryad_S3#16, treap_max_prio(xr#10)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#15, $phys_ptr_cast(xr#10, ^b_node))) ==> F#treap_max_prio(_dryad_S2#15, $phys_ptr_cast(xr#10, ^b_node)) == F#treap_max_prio(_dryad_S3#16, $phys_ptr_cast(xr#10, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#15, treap_reach(xr#10)))), ==(old(_dryad_S2#15, treap_min_key(xr#10)), old(_dryad_S3#16, treap_min_key(xr#10)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#15, $phys_ptr_cast(xr#10, ^b_node))) ==> F#treap_min_key(_dryad_S2#15, $phys_ptr_cast(xr#10, ^b_node)) == F#treap_min_key(_dryad_S3#16, $phys_ptr_cast(xr#10, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#15, treap_reach(xr#10)))), ==(old(_dryad_S2#15, treap_prios(xr#10)), old(_dryad_S3#16, treap_prios(xr#10)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#15, $phys_ptr_cast(xr#10, ^b_node))) ==> F#treap_prios(_dryad_S2#15, $phys_ptr_cast(xr#10, ^b_node)) == F#treap_prios(_dryad_S3#16, $phys_ptr_cast(xr#10, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#15, treap_reach(xl#9)))), ==(old(_dryad_S2#15, treap(xl#9)), old(_dryad_S3#16, treap(xl#9)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#15, $phys_ptr_cast(xl#9, ^b_node))) ==> F#treap(_dryad_S2#15, $phys_ptr_cast(xl#9, ^b_node)) == F#treap(_dryad_S3#16, $phys_ptr_cast(xl#9, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#15, treap_reach(xl#9)))), ==(old(_dryad_S2#15, treap_reach(xl#9)), old(_dryad_S3#16, treap_reach(xl#9)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#15, $phys_ptr_cast(xl#9, ^b_node))) ==> F#treap_reach(_dryad_S2#15, $phys_ptr_cast(xl#9, ^b_node)) == F#treap_reach(_dryad_S3#16, $phys_ptr_cast(xl#9, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#15, treap_reach(xl#9)))), ==(old(_dryad_S2#15, treap_keys(xl#9)), old(_dryad_S3#16, treap_keys(xl#9)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#15, $phys_ptr_cast(xl#9, ^b_node))) ==> F#treap_keys(_dryad_S2#15, $phys_ptr_cast(xl#9, ^b_node)) == F#treap_keys(_dryad_S3#16, $phys_ptr_cast(xl#9, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#15, treap_reach(xl#9)))), ==(old(_dryad_S2#15, treap_max_key(xl#9)), old(_dryad_S3#16, treap_max_key(xl#9)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#15, $phys_ptr_cast(xl#9, ^b_node))) ==> F#treap_max_key(_dryad_S2#15, $phys_ptr_cast(xl#9, ^b_node)) == F#treap_max_key(_dryad_S3#16, $phys_ptr_cast(xl#9, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#15, treap_reach(xl#9)))), ==(old(_dryad_S2#15, treap_max_prio(xl#9)), old(_dryad_S3#16, treap_max_prio(xl#9)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#15, $phys_ptr_cast(xl#9, ^b_node))) ==> F#treap_max_prio(_dryad_S2#15, $phys_ptr_cast(xl#9, ^b_node)) == F#treap_max_prio(_dryad_S3#16, $phys_ptr_cast(xl#9, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#15, treap_reach(xl#9)))), ==(old(_dryad_S2#15, treap_min_key(xl#9)), old(_dryad_S3#16, treap_min_key(xl#9)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#15, $phys_ptr_cast(xl#9, ^b_node))) ==> F#treap_min_key(_dryad_S2#15, $phys_ptr_cast(xl#9, ^b_node)) == F#treap_min_key(_dryad_S3#16, $phys_ptr_cast(xl#9, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#15, treap_reach(xl#9)))), ==(old(_dryad_S2#15, treap_prios(xl#9)), old(_dryad_S3#16, treap_prios(xl#9)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#15, $phys_ptr_cast(xl#9, ^b_node))) ==> F#treap_prios(_dryad_S2#15, $phys_ptr_cast(xl#9, ^b_node)) == F#treap_prios(_dryad_S3#16, $phys_ptr_cast(xl#9, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#15, treap_reach(tmp#8)))), ==(old(_dryad_S2#15, treap(tmp#8)), old(_dryad_S3#16, treap(tmp#8)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#15, $phys_ptr_cast(tmp#8, ^b_node))) ==> F#treap(_dryad_S2#15, $phys_ptr_cast(tmp#8, ^b_node)) == F#treap(_dryad_S3#16, $phys_ptr_cast(tmp#8, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#15, treap_reach(tmp#8)))), ==(old(_dryad_S2#15, treap_reach(tmp#8)), old(_dryad_S3#16, treap_reach(tmp#8)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#15, $phys_ptr_cast(tmp#8, ^b_node))) ==> F#treap_reach(_dryad_S2#15, $phys_ptr_cast(tmp#8, ^b_node)) == F#treap_reach(_dryad_S3#16, $phys_ptr_cast(tmp#8, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#15, treap_reach(tmp#8)))), ==(old(_dryad_S2#15, treap_keys(tmp#8)), old(_dryad_S3#16, treap_keys(tmp#8)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#15, $phys_ptr_cast(tmp#8, ^b_node))) ==> F#treap_keys(_dryad_S2#15, $phys_ptr_cast(tmp#8, ^b_node)) == F#treap_keys(_dryad_S3#16, $phys_ptr_cast(tmp#8, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#15, treap_reach(tmp#8)))), ==(old(_dryad_S2#15, treap_max_key(tmp#8)), old(_dryad_S3#16, treap_max_key(tmp#8)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#15, $phys_ptr_cast(tmp#8, ^b_node))) ==> F#treap_max_key(_dryad_S2#15, $phys_ptr_cast(tmp#8, ^b_node)) == F#treap_max_key(_dryad_S3#16, $phys_ptr_cast(tmp#8, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#15, treap_reach(tmp#8)))), ==(old(_dryad_S2#15, treap_max_prio(tmp#8)), old(_dryad_S3#16, treap_max_prio(tmp#8)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#15, $phys_ptr_cast(tmp#8, ^b_node))) ==> F#treap_max_prio(_dryad_S2#15, $phys_ptr_cast(tmp#8, ^b_node)) == F#treap_max_prio(_dryad_S3#16, $phys_ptr_cast(tmp#8, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#15, treap_reach(tmp#8)))), ==(old(_dryad_S2#15, treap_min_key(tmp#8)), old(_dryad_S3#16, treap_min_key(tmp#8)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#15, $phys_ptr_cast(tmp#8, ^b_node))) ==> F#treap_min_key(_dryad_S2#15, $phys_ptr_cast(tmp#8, ^b_node)) == F#treap_min_key(_dryad_S3#16, $phys_ptr_cast(tmp#8, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#15, treap_reach(tmp#8)))), ==(old(_dryad_S2#15, treap_prios(tmp#8)), old(_dryad_S3#16, treap_prios(tmp#8)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#15, $phys_ptr_cast(tmp#8, ^b_node))) ==> F#treap_prios(_dryad_S2#15, $phys_ptr_cast(tmp#8, ^b_node)) == F#treap_prios(_dryad_S3#16, $phys_ptr_cast(tmp#8, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(x, x1#12)), @_vcc_ptr_eq_pure(*((x1#12->left)), old(_dryad_S2#15, *((x1#12->left))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(x1#12, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#15, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(x, x1#12)), @_vcc_ptr_eq_pure(*((x1#12->right)), old(_dryad_S2#15, *((x1#12->right))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(x1#12, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#15, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(x, x1#12)), ==(*((x1#12->key)), old(_dryad_S2#15, *((x1#12->key))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(x1#12, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)) == $rd_inv(_dryad_S2#15, b_node.key, $phys_ptr_cast(x1#12, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(x, x1#12)), ==(*((x1#12->prio)), old(_dryad_S2#15, *((x1#12->prio))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(x1#12, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(x1#12, ^b_node)) == $rd_inv(_dryad_S2#15, b_node.prio, $phys_ptr_cast(x1#12, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(x, x0#11)), @_vcc_ptr_eq_pure(*((x0#11->left)), old(_dryad_S2#15, *((x0#11->left))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(x0#11, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#15, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(x, x0#11)), @_vcc_ptr_eq_pure(*((x0#11->right)), old(_dryad_S2#15, *((x0#11->right))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(x0#11, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#15, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(x, x0#11)), ==(*((x0#11->key)), old(_dryad_S2#15, *((x0#11->key))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(x0#11, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)) == $rd_inv(_dryad_S2#15, b_node.key, $phys_ptr_cast(x0#11, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(x, x0#11)), ==(*((x0#11->prio)), old(_dryad_S2#15, *((x0#11->prio))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(x0#11, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(x0#11, ^b_node)) == $rd_inv(_dryad_S2#15, b_node.prio, $phys_ptr_cast(x0#11, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(x, xr#10)), @_vcc_ptr_eq_pure(*((xr#10->left)), old(_dryad_S2#15, *((xr#10->left))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(xr#10, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#15, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(x, xr#10)), @_vcc_ptr_eq_pure(*((xr#10->right)), old(_dryad_S2#15, *((xr#10->right))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(xr#10, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#15, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(x, xr#10)), ==(*((xr#10->key)), old(_dryad_S2#15, *((xr#10->key))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(xr#10, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)) == $rd_inv(_dryad_S2#15, b_node.key, $phys_ptr_cast(xr#10, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(x, xr#10)), ==(*((xr#10->prio)), old(_dryad_S2#15, *((xr#10->prio))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(xr#10, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node)) == $rd_inv(_dryad_S2#15, b_node.prio, $phys_ptr_cast(xr#10, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(x, xl#9)), @_vcc_ptr_eq_pure(*((xl#9->left)), old(_dryad_S2#15, *((xl#9->left))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(xl#9, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#15, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(x, xl#9)), @_vcc_ptr_eq_pure(*((xl#9->right)), old(_dryad_S2#15, *((xl#9->right))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(xl#9, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#15, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(x, xl#9)), ==(*((xl#9->key)), old(_dryad_S2#15, *((xl#9->key))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(xl#9, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)) == $rd_inv(_dryad_S2#15, b_node.key, $phys_ptr_cast(xl#9, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(x, xl#9)), ==(*((xl#9->prio)), old(_dryad_S2#15, *((xl#9->prio))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(xl#9, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node)) == $rd_inv(_dryad_S2#15, b_node.prio, $phys_ptr_cast(xl#9, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(x, tmp#8)), @_vcc_ptr_eq_pure(*((tmp#8->left)), old(_dryad_S2#15, *((tmp#8->left))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(tmp#8, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#15, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(x, tmp#8)), @_vcc_ptr_eq_pure(*((tmp#8->right)), old(_dryad_S2#15, *((tmp#8->right))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(tmp#8, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#15, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(x, tmp#8)), ==(*((tmp#8->key)), old(_dryad_S2#15, *((tmp#8->key))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(tmp#8, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)) == $rd_inv(_dryad_S2#15, b_node.key, $phys_ptr_cast(tmp#8, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(x, tmp#8)), ==(*((tmp#8->prio)), old(_dryad_S2#15, *((tmp#8->prio))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(tmp#8, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node)) == $rd_inv(_dryad_S2#15, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node));
                // assume ==>(@_vcc_ptr_neq_null(x1#12), ==(treap(x1#12), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x1#12->left))), treap(*((x1#12->right)))), unchecked!(@_vcc_oset_in(x1#12, @_vcc_oset_union(treap_reach(*((x1#12->left))), treap_reach(*((x1#12->right))))))), unchecked!(@_vcc_intset_in(*((x1#12->key)), @_vcc_intset_union(treap_keys(*((x1#12->left))), treap_keys(*((x1#12->right))))))), unchecked!(@_vcc_intset_in(*((x1#12->prio)), @_vcc_intset_union(treap_prios(*((x1#12->left))), treap_prios(*((x1#12->right))))))), @_vcc_oset_disjoint(treap_reach(*((x1#12->left))), treap_reach(*((x1#12->right))))), @_vcc_intset_disjoint(treap_keys(*((x1#12->left))), treap_keys(*((x1#12->right))))), @_vcc_intset_disjoint(treap_prios(*((x1#12->left))), treap_prios(*((x1#12->right))))), ==>(@_vcc_ptr_neq_null(*((x1#12->left))), <(treap_max_key(*((x1#12->left))), *((x1#12->key))))), ==>(@_vcc_ptr_neq_null(*((x1#12->right))), <(*((x1#12->key)), treap_min_key(*((x1#12->right)))))), ==>(@_vcc_ptr_neq_null(*((x1#12->left))), <(treap_max_prio(*((x1#12->left))), *((x1#12->prio))))), ==>(@_vcc_ptr_neq_null(*((x1#12->right))), <(treap_max_prio(*((x1#12->right))), *((x1#12->prio))))))); 
                assume $non_null($phys_ptr_cast(x1#12, ^b_node)) ==> F#treap($s, $phys_ptr_cast(x1#12, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(x1#12, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(x1#12, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(x1#12, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(x1#12, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1#12), ==(treap_reach(x1#12), @_vcc_oset_union(@_vcc_oset_singleton(x1#12), @_vcc_oset_union(treap_reach(*((x1#12->left))), treap_reach(*((x1#12->right))))))); 
                assume $non_null($phys_ptr_cast(x1#12, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(x1#12, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(x1#12, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1#12), ==(treap_keys(x1#12), @_vcc_intset_union(@_vcc_intset_singleton(*((x1#12->key))), @_vcc_intset_union(treap_keys(*((x1#12->left))), treap_keys(*((x1#12->right))))))); 
                assume $non_null($phys_ptr_cast(x1#12, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(x1#12, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1#12), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x1#12->left))), @_vcc_ptr_neq_null(*((x1#12->right)))), ==(treap_max_key(x1#12), @\int_max(*((x1#12->key)), @\int_max(treap_max_key(*((x1#12->left))), treap_max_key(*((x1#12->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x1#12->left))), @_vcc_ptr_eq_null(*((x1#12->right)))), ==(treap_max_key(x1#12), @\int_max(*((x1#12->key)), treap_max_key(*((x1#12->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x1#12->left))), @_vcc_ptr_neq_null(*((x1#12->right)))), ==(treap_max_key(x1#12), @\int_max(*((x1#12->key)), treap_max_key(*((x1#12->right)))))))); 
                assume $non_null($phys_ptr_cast(x1#12, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1#12), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x1#12->left))), @_vcc_ptr_neq_null(*((x1#12->right)))), ==(treap_max_prio(x1#12), @\int_max(*((x1#12->prio)), @\int_max(treap_max_prio(*((x1#12->left))), treap_max_prio(*((x1#12->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x1#12->left))), @_vcc_ptr_eq_null(*((x1#12->right)))), ==(treap_max_prio(x1#12), @\int_max(*((x1#12->prio)), treap_max_prio(*((x1#12->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x1#12->left))), @_vcc_ptr_neq_null(*((x1#12->right)))), ==(treap_max_prio(x1#12), @\int_max(*((x1#12->prio)), treap_max_prio(*((x1#12->right)))))))); 
                assume $non_null($phys_ptr_cast(x1#12, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(x1#12, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(x1#12, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(x1#12, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1#12), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x1#12->left))), @_vcc_ptr_neq_null(*((x1#12->right)))), ==(treap_min_key(x1#12), @\int_min(*((x1#12->key)), @\int_min(treap_min_key(*((x1#12->left))), treap_min_key(*((x1#12->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x1#12->left))), @_vcc_ptr_eq_null(*((x1#12->right)))), ==(treap_min_key(x1#12), @\int_min(*((x1#12->key)), treap_min_key(*((x1#12->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x1#12->left))), @_vcc_ptr_neq_null(*((x1#12->right)))), ==(treap_min_key(x1#12), @\int_min(*((x1#12->key)), treap_min_key(*((x1#12->right)))))))); 
                assume $non_null($phys_ptr_cast(x1#12, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1#12), ==(treap_prios(x1#12), @_vcc_intset_union(@_vcc_intset_singleton(*((x1#12->prio))), @_vcc_intset_union(treap_prios(*((x1#12->left))), treap_prios(*((x1#12->right))))))); 
                assume $non_null($phys_ptr_cast(x1#12, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(x1#12, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(x1#12, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0#11), ==(treap(x0#11), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x0#11->left))), treap(*((x0#11->right)))), unchecked!(@_vcc_oset_in(x0#11, @_vcc_oset_union(treap_reach(*((x0#11->left))), treap_reach(*((x0#11->right))))))), unchecked!(@_vcc_intset_in(*((x0#11->key)), @_vcc_intset_union(treap_keys(*((x0#11->left))), treap_keys(*((x0#11->right))))))), unchecked!(@_vcc_intset_in(*((x0#11->prio)), @_vcc_intset_union(treap_prios(*((x0#11->left))), treap_prios(*((x0#11->right))))))), @_vcc_oset_disjoint(treap_reach(*((x0#11->left))), treap_reach(*((x0#11->right))))), @_vcc_intset_disjoint(treap_keys(*((x0#11->left))), treap_keys(*((x0#11->right))))), @_vcc_intset_disjoint(treap_prios(*((x0#11->left))), treap_prios(*((x0#11->right))))), ==>(@_vcc_ptr_neq_null(*((x0#11->left))), <(treap_max_key(*((x0#11->left))), *((x0#11->key))))), ==>(@_vcc_ptr_neq_null(*((x0#11->right))), <(*((x0#11->key)), treap_min_key(*((x0#11->right)))))), ==>(@_vcc_ptr_neq_null(*((x0#11->left))), <(treap_max_prio(*((x0#11->left))), *((x0#11->prio))))), ==>(@_vcc_ptr_neq_null(*((x0#11->right))), <(treap_max_prio(*((x0#11->right))), *((x0#11->prio))))))); 
                assume $non_null($phys_ptr_cast(x0#11, ^b_node)) ==> F#treap($s, $phys_ptr_cast(x0#11, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(x0#11, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(x0#11, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(x0#11, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(x0#11, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0#11), ==(treap_reach(x0#11), @_vcc_oset_union(@_vcc_oset_singleton(x0#11), @_vcc_oset_union(treap_reach(*((x0#11->left))), treap_reach(*((x0#11->right))))))); 
                assume $non_null($phys_ptr_cast(x0#11, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(x0#11, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(x0#11, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0#11), ==(treap_keys(x0#11), @_vcc_intset_union(@_vcc_intset_singleton(*((x0#11->key))), @_vcc_intset_union(treap_keys(*((x0#11->left))), treap_keys(*((x0#11->right))))))); 
                assume $non_null($phys_ptr_cast(x0#11, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(x0#11, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0#11), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x0#11->left))), @_vcc_ptr_neq_null(*((x0#11->right)))), ==(treap_max_key(x0#11), @\int_max(*((x0#11->key)), @\int_max(treap_max_key(*((x0#11->left))), treap_max_key(*((x0#11->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x0#11->left))), @_vcc_ptr_eq_null(*((x0#11->right)))), ==(treap_max_key(x0#11), @\int_max(*((x0#11->key)), treap_max_key(*((x0#11->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x0#11->left))), @_vcc_ptr_neq_null(*((x0#11->right)))), ==(treap_max_key(x0#11), @\int_max(*((x0#11->key)), treap_max_key(*((x0#11->right)))))))); 
                assume $non_null($phys_ptr_cast(x0#11, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0#11), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x0#11->left))), @_vcc_ptr_neq_null(*((x0#11->right)))), ==(treap_max_prio(x0#11), @\int_max(*((x0#11->prio)), @\int_max(treap_max_prio(*((x0#11->left))), treap_max_prio(*((x0#11->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x0#11->left))), @_vcc_ptr_eq_null(*((x0#11->right)))), ==(treap_max_prio(x0#11), @\int_max(*((x0#11->prio)), treap_max_prio(*((x0#11->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x0#11->left))), @_vcc_ptr_neq_null(*((x0#11->right)))), ==(treap_max_prio(x0#11), @\int_max(*((x0#11->prio)), treap_max_prio(*((x0#11->right)))))))); 
                assume $non_null($phys_ptr_cast(x0#11, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(x0#11, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(x0#11, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(x0#11, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0#11), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x0#11->left))), @_vcc_ptr_neq_null(*((x0#11->right)))), ==(treap_min_key(x0#11), @\int_min(*((x0#11->key)), @\int_min(treap_min_key(*((x0#11->left))), treap_min_key(*((x0#11->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x0#11->left))), @_vcc_ptr_eq_null(*((x0#11->right)))), ==(treap_min_key(x0#11), @\int_min(*((x0#11->key)), treap_min_key(*((x0#11->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x0#11->left))), @_vcc_ptr_neq_null(*((x0#11->right)))), ==(treap_min_key(x0#11), @\int_min(*((x0#11->key)), treap_min_key(*((x0#11->right)))))))); 
                assume $non_null($phys_ptr_cast(x0#11, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0#11), ==(treap_prios(x0#11), @_vcc_intset_union(@_vcc_intset_singleton(*((x0#11->prio))), @_vcc_intset_union(treap_prios(*((x0#11->left))), treap_prios(*((x0#11->right))))))); 
                assume $non_null($phys_ptr_cast(x0#11, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(x0#11, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(x0#11, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr#10), ==(treap(xr#10), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((xr#10->left))), treap(*((xr#10->right)))), unchecked!(@_vcc_oset_in(xr#10, @_vcc_oset_union(treap_reach(*((xr#10->left))), treap_reach(*((xr#10->right))))))), unchecked!(@_vcc_intset_in(*((xr#10->key)), @_vcc_intset_union(treap_keys(*((xr#10->left))), treap_keys(*((xr#10->right))))))), unchecked!(@_vcc_intset_in(*((xr#10->prio)), @_vcc_intset_union(treap_prios(*((xr#10->left))), treap_prios(*((xr#10->right))))))), @_vcc_oset_disjoint(treap_reach(*((xr#10->left))), treap_reach(*((xr#10->right))))), @_vcc_intset_disjoint(treap_keys(*((xr#10->left))), treap_keys(*((xr#10->right))))), @_vcc_intset_disjoint(treap_prios(*((xr#10->left))), treap_prios(*((xr#10->right))))), ==>(@_vcc_ptr_neq_null(*((xr#10->left))), <(treap_max_key(*((xr#10->left))), *((xr#10->key))))), ==>(@_vcc_ptr_neq_null(*((xr#10->right))), <(*((xr#10->key)), treap_min_key(*((xr#10->right)))))), ==>(@_vcc_ptr_neq_null(*((xr#10->left))), <(treap_max_prio(*((xr#10->left))), *((xr#10->prio))))), ==>(@_vcc_ptr_neq_null(*((xr#10->right))), <(treap_max_prio(*((xr#10->right))), *((xr#10->prio))))))); 
                assume $non_null($phys_ptr_cast(xr#10, ^b_node)) ==> F#treap($s, $phys_ptr_cast(xr#10, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(xr#10, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr#10), ==(treap_reach(xr#10), @_vcc_oset_union(@_vcc_oset_singleton(xr#10), @_vcc_oset_union(treap_reach(*((xr#10->left))), treap_reach(*((xr#10->right))))))); 
                assume $non_null($phys_ptr_cast(xr#10, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(xr#10, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(xr#10, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr#10), ==(treap_keys(xr#10), @_vcc_intset_union(@_vcc_intset_singleton(*((xr#10->key))), @_vcc_intset_union(treap_keys(*((xr#10->left))), treap_keys(*((xr#10->right))))))); 
                assume $non_null($phys_ptr_cast(xr#10, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(xr#10, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr#10), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr#10->left))), @_vcc_ptr_neq_null(*((xr#10->right)))), ==(treap_max_key(xr#10), @\int_max(*((xr#10->key)), @\int_max(treap_max_key(*((xr#10->left))), treap_max_key(*((xr#10->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr#10->left))), @_vcc_ptr_eq_null(*((xr#10->right)))), ==(treap_max_key(xr#10), @\int_max(*((xr#10->key)), treap_max_key(*((xr#10->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr#10->left))), @_vcc_ptr_neq_null(*((xr#10->right)))), ==(treap_max_key(xr#10), @\int_max(*((xr#10->key)), treap_max_key(*((xr#10->right)))))))); 
                assume $non_null($phys_ptr_cast(xr#10, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr#10), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr#10->left))), @_vcc_ptr_neq_null(*((xr#10->right)))), ==(treap_max_prio(xr#10), @\int_max(*((xr#10->prio)), @\int_max(treap_max_prio(*((xr#10->left))), treap_max_prio(*((xr#10->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr#10->left))), @_vcc_ptr_eq_null(*((xr#10->right)))), ==(treap_max_prio(xr#10), @\int_max(*((xr#10->prio)), treap_max_prio(*((xr#10->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr#10->left))), @_vcc_ptr_neq_null(*((xr#10->right)))), ==(treap_max_prio(xr#10), @\int_max(*((xr#10->prio)), treap_max_prio(*((xr#10->right)))))))); 
                assume $non_null($phys_ptr_cast(xr#10, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr#10), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr#10->left))), @_vcc_ptr_neq_null(*((xr#10->right)))), ==(treap_min_key(xr#10), @\int_min(*((xr#10->key)), @\int_min(treap_min_key(*((xr#10->left))), treap_min_key(*((xr#10->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr#10->left))), @_vcc_ptr_eq_null(*((xr#10->right)))), ==(treap_min_key(xr#10), @\int_min(*((xr#10->key)), treap_min_key(*((xr#10->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr#10->left))), @_vcc_ptr_neq_null(*((xr#10->right)))), ==(treap_min_key(xr#10), @\int_min(*((xr#10->key)), treap_min_key(*((xr#10->right)))))))); 
                assume $non_null($phys_ptr_cast(xr#10, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr#10), ==(treap_prios(xr#10), @_vcc_intset_union(@_vcc_intset_singleton(*((xr#10->prio))), @_vcc_intset_union(treap_prios(*((xr#10->left))), treap_prios(*((xr#10->right))))))); 
                assume $non_null($phys_ptr_cast(xr#10, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(xr#10, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl#9), ==(treap(xl#9), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((xl#9->left))), treap(*((xl#9->right)))), unchecked!(@_vcc_oset_in(xl#9, @_vcc_oset_union(treap_reach(*((xl#9->left))), treap_reach(*((xl#9->right))))))), unchecked!(@_vcc_intset_in(*((xl#9->key)), @_vcc_intset_union(treap_keys(*((xl#9->left))), treap_keys(*((xl#9->right))))))), unchecked!(@_vcc_intset_in(*((xl#9->prio)), @_vcc_intset_union(treap_prios(*((xl#9->left))), treap_prios(*((xl#9->right))))))), @_vcc_oset_disjoint(treap_reach(*((xl#9->left))), treap_reach(*((xl#9->right))))), @_vcc_intset_disjoint(treap_keys(*((xl#9->left))), treap_keys(*((xl#9->right))))), @_vcc_intset_disjoint(treap_prios(*((xl#9->left))), treap_prios(*((xl#9->right))))), ==>(@_vcc_ptr_neq_null(*((xl#9->left))), <(treap_max_key(*((xl#9->left))), *((xl#9->key))))), ==>(@_vcc_ptr_neq_null(*((xl#9->right))), <(*((xl#9->key)), treap_min_key(*((xl#9->right)))))), ==>(@_vcc_ptr_neq_null(*((xl#9->left))), <(treap_max_prio(*((xl#9->left))), *((xl#9->prio))))), ==>(@_vcc_ptr_neq_null(*((xl#9->right))), <(treap_max_prio(*((xl#9->right))), *((xl#9->prio))))))); 
                assume $non_null($phys_ptr_cast(xl#9, ^b_node)) ==> F#treap($s, $phys_ptr_cast(xl#9, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(xl#9, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl#9), ==(treap_reach(xl#9), @_vcc_oset_union(@_vcc_oset_singleton(xl#9), @_vcc_oset_union(treap_reach(*((xl#9->left))), treap_reach(*((xl#9->right))))))); 
                assume $non_null($phys_ptr_cast(xl#9, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(xl#9, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(xl#9, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl#9), ==(treap_keys(xl#9), @_vcc_intset_union(@_vcc_intset_singleton(*((xl#9->key))), @_vcc_intset_union(treap_keys(*((xl#9->left))), treap_keys(*((xl#9->right))))))); 
                assume $non_null($phys_ptr_cast(xl#9, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(xl#9, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl#9), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl#9->left))), @_vcc_ptr_neq_null(*((xl#9->right)))), ==(treap_max_key(xl#9), @\int_max(*((xl#9->key)), @\int_max(treap_max_key(*((xl#9->left))), treap_max_key(*((xl#9->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl#9->left))), @_vcc_ptr_eq_null(*((xl#9->right)))), ==(treap_max_key(xl#9), @\int_max(*((xl#9->key)), treap_max_key(*((xl#9->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl#9->left))), @_vcc_ptr_neq_null(*((xl#9->right)))), ==(treap_max_key(xl#9), @\int_max(*((xl#9->key)), treap_max_key(*((xl#9->right)))))))); 
                assume $non_null($phys_ptr_cast(xl#9, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl#9), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl#9->left))), @_vcc_ptr_neq_null(*((xl#9->right)))), ==(treap_max_prio(xl#9), @\int_max(*((xl#9->prio)), @\int_max(treap_max_prio(*((xl#9->left))), treap_max_prio(*((xl#9->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl#9->left))), @_vcc_ptr_eq_null(*((xl#9->right)))), ==(treap_max_prio(xl#9), @\int_max(*((xl#9->prio)), treap_max_prio(*((xl#9->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl#9->left))), @_vcc_ptr_neq_null(*((xl#9->right)))), ==(treap_max_prio(xl#9), @\int_max(*((xl#9->prio)), treap_max_prio(*((xl#9->right)))))))); 
                assume $non_null($phys_ptr_cast(xl#9, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl#9), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl#9->left))), @_vcc_ptr_neq_null(*((xl#9->right)))), ==(treap_min_key(xl#9), @\int_min(*((xl#9->key)), @\int_min(treap_min_key(*((xl#9->left))), treap_min_key(*((xl#9->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl#9->left))), @_vcc_ptr_eq_null(*((xl#9->right)))), ==(treap_min_key(xl#9), @\int_min(*((xl#9->key)), treap_min_key(*((xl#9->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl#9->left))), @_vcc_ptr_neq_null(*((xl#9->right)))), ==(treap_min_key(xl#9), @\int_min(*((xl#9->key)), treap_min_key(*((xl#9->right)))))))); 
                assume $non_null($phys_ptr_cast(xl#9, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl#9), ==(treap_prios(xl#9), @_vcc_intset_union(@_vcc_intset_singleton(*((xl#9->prio))), @_vcc_intset_union(treap_prios(*((xl#9->left))), treap_prios(*((xl#9->right))))))); 
                assume $non_null($phys_ptr_cast(xl#9, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(xl#9, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), ==(treap(tmp#8), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((tmp#8->left))), treap(*((tmp#8->right)))), unchecked!(@_vcc_oset_in(tmp#8, @_vcc_oset_union(treap_reach(*((tmp#8->left))), treap_reach(*((tmp#8->right))))))), unchecked!(@_vcc_intset_in(*((tmp#8->key)), @_vcc_intset_union(treap_keys(*((tmp#8->left))), treap_keys(*((tmp#8->right))))))), unchecked!(@_vcc_intset_in(*((tmp#8->prio)), @_vcc_intset_union(treap_prios(*((tmp#8->left))), treap_prios(*((tmp#8->right))))))), @_vcc_oset_disjoint(treap_reach(*((tmp#8->left))), treap_reach(*((tmp#8->right))))), @_vcc_intset_disjoint(treap_keys(*((tmp#8->left))), treap_keys(*((tmp#8->right))))), @_vcc_intset_disjoint(treap_prios(*((tmp#8->left))), treap_prios(*((tmp#8->right))))), ==>(@_vcc_ptr_neq_null(*((tmp#8->left))), <(treap_max_key(*((tmp#8->left))), *((tmp#8->key))))), ==>(@_vcc_ptr_neq_null(*((tmp#8->right))), <(*((tmp#8->key)), treap_min_key(*((tmp#8->right)))))), ==>(@_vcc_ptr_neq_null(*((tmp#8->left))), <(treap_max_prio(*((tmp#8->left))), *((tmp#8->prio))))), ==>(@_vcc_ptr_neq_null(*((tmp#8->right))), <(treap_max_prio(*((tmp#8->right))), *((tmp#8->prio))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> F#treap($s, $phys_ptr_cast(tmp#8, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(tmp#8, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), ==(treap_reach(tmp#8), @_vcc_oset_union(@_vcc_oset_singleton(tmp#8), @_vcc_oset_union(treap_reach(*((tmp#8->left))), treap_reach(*((tmp#8->right))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(tmp#8, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(tmp#8, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), ==(treap_keys(tmp#8), @_vcc_intset_union(@_vcc_intset_singleton(*((tmp#8->key))), @_vcc_intset_union(treap_keys(*((tmp#8->left))), treap_keys(*((tmp#8->right))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(tmp#8, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_max_key(tmp#8), @\int_max(*((tmp#8->key)), @\int_max(treap_max_key(*((tmp#8->left))), treap_max_key(*((tmp#8->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_eq_null(*((tmp#8->right)))), ==(treap_max_key(tmp#8), @\int_max(*((tmp#8->key)), treap_max_key(*((tmp#8->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_max_key(tmp#8), @\int_max(*((tmp#8->key)), treap_max_key(*((tmp#8->right)))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_max_prio(tmp#8), @\int_max(*((tmp#8->prio)), @\int_max(treap_max_prio(*((tmp#8->left))), treap_max_prio(*((tmp#8->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_eq_null(*((tmp#8->right)))), ==(treap_max_prio(tmp#8), @\int_max(*((tmp#8->prio)), treap_max_prio(*((tmp#8->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_max_prio(tmp#8), @\int_max(*((tmp#8->prio)), treap_max_prio(*((tmp#8->right)))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_min_key(tmp#8), @\int_min(*((tmp#8->key)), @\int_min(treap_min_key(*((tmp#8->left))), treap_min_key(*((tmp#8->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_eq_null(*((tmp#8->right)))), ==(treap_min_key(tmp#8), @\int_min(*((tmp#8->key)), treap_min_key(*((tmp#8->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_min_key(tmp#8), @\int_min(*((tmp#8->key)), treap_min_key(*((tmp#8->right)))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), ==(treap_prios(tmp#8), @_vcc_intset_union(@_vcc_intset_singleton(*((tmp#8->prio))), @_vcc_intset_union(treap_prios(*((tmp#8->left))), treap_prios(*((tmp#8->right))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(tmp#8, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), ==(treap(x), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x->left))), treap(*((x->right)))), unchecked!(@_vcc_oset_in(x, @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->key)), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->prio)), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))), @_vcc_oset_disjoint(treap_reach(*((x->left))), treap_reach(*((x->right))))), @_vcc_intset_disjoint(treap_keys(*((x->left))), treap_keys(*((x->right))))), @_vcc_intset_disjoint(treap_prios(*((x->left))), treap_prios(*((x->right))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_key(*((x->left))), *((x->key))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(*((x->key)), treap_min_key(*((x->right)))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_prio(*((x->left))), *((x->prio))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(treap_max_prio(*((x->right))), *((x->prio))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap($s, $phys_ptr_cast(P#x, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(P#x, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_reach(x), @_vcc_oset_union(@_vcc_oset_singleton(x), @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(P#x, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(P#x, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_keys(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->key))), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), @\int_max(treap_max_key(*((x->left))), treap_max_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->right)))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), @\int_max(treap_max_prio(*((x->left))), treap_max_prio(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->right)))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), @\int_min(treap_min_key(*((x->left))), treap_min_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->right)))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_prios(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->prio))), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), ==(treap(tmp#8), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((tmp#8->left))), treap(*((tmp#8->right)))), unchecked!(@_vcc_oset_in(tmp#8, @_vcc_oset_union(treap_reach(*((tmp#8->left))), treap_reach(*((tmp#8->right))))))), unchecked!(@_vcc_intset_in(*((tmp#8->key)), @_vcc_intset_union(treap_keys(*((tmp#8->left))), treap_keys(*((tmp#8->right))))))), unchecked!(@_vcc_intset_in(*((tmp#8->prio)), @_vcc_intset_union(treap_prios(*((tmp#8->left))), treap_prios(*((tmp#8->right))))))), @_vcc_oset_disjoint(treap_reach(*((tmp#8->left))), treap_reach(*((tmp#8->right))))), @_vcc_intset_disjoint(treap_keys(*((tmp#8->left))), treap_keys(*((tmp#8->right))))), @_vcc_intset_disjoint(treap_prios(*((tmp#8->left))), treap_prios(*((tmp#8->right))))), ==>(@_vcc_ptr_neq_null(*((tmp#8->left))), <(treap_max_key(*((tmp#8->left))), *((tmp#8->key))))), ==>(@_vcc_ptr_neq_null(*((tmp#8->right))), <(*((tmp#8->key)), treap_min_key(*((tmp#8->right)))))), ==>(@_vcc_ptr_neq_null(*((tmp#8->left))), <(treap_max_prio(*((tmp#8->left))), *((tmp#8->prio))))), ==>(@_vcc_ptr_neq_null(*((tmp#8->right))), <(treap_max_prio(*((tmp#8->right))), *((tmp#8->prio))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> F#treap($s, $phys_ptr_cast(tmp#8, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(tmp#8, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), ==(treap_reach(tmp#8), @_vcc_oset_union(@_vcc_oset_singleton(tmp#8), @_vcc_oset_union(treap_reach(*((tmp#8->left))), treap_reach(*((tmp#8->right))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(tmp#8, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(tmp#8, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), ==(treap_keys(tmp#8), @_vcc_intset_union(@_vcc_intset_singleton(*((tmp#8->key))), @_vcc_intset_union(treap_keys(*((tmp#8->left))), treap_keys(*((tmp#8->right))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(tmp#8, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_max_key(tmp#8), @\int_max(*((tmp#8->key)), @\int_max(treap_max_key(*((tmp#8->left))), treap_max_key(*((tmp#8->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_eq_null(*((tmp#8->right)))), ==(treap_max_key(tmp#8), @\int_max(*((tmp#8->key)), treap_max_key(*((tmp#8->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_max_key(tmp#8), @\int_max(*((tmp#8->key)), treap_max_key(*((tmp#8->right)))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_max_prio(tmp#8), @\int_max(*((tmp#8->prio)), @\int_max(treap_max_prio(*((tmp#8->left))), treap_max_prio(*((tmp#8->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_eq_null(*((tmp#8->right)))), ==(treap_max_prio(tmp#8), @\int_max(*((tmp#8->prio)), treap_max_prio(*((tmp#8->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_max_prio(tmp#8), @\int_max(*((tmp#8->prio)), treap_max_prio(*((tmp#8->right)))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_min_key(tmp#8), @\int_min(*((tmp#8->key)), @\int_min(treap_min_key(*((tmp#8->left))), treap_min_key(*((tmp#8->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_eq_null(*((tmp#8->right)))), ==(treap_min_key(tmp#8), @\int_min(*((tmp#8->key)), treap_min_key(*((tmp#8->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_min_key(tmp#8), @\int_min(*((tmp#8->key)), treap_min_key(*((tmp#8->right)))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), ==(treap_prios(tmp#8), @_vcc_intset_union(@_vcc_intset_singleton(*((tmp#8->prio))), @_vcc_intset_union(treap_prios(*((tmp#8->left))), treap_prios(*((tmp#8->right))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(tmp#8, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
                // return x; 
                $result := $phys_ptr_cast(P#x, ^b_node);
                assume true;
                assert $position_marker();
                goto #exit;
            }
            else
            {
              anon6:
                // assume ==>(@_vcc_ptr_neq_null(x1#12), ==(treap(x1#12), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x1#12->left))), treap(*((x1#12->right)))), unchecked!(@_vcc_oset_in(x1#12, @_vcc_oset_union(treap_reach(*((x1#12->left))), treap_reach(*((x1#12->right))))))), unchecked!(@_vcc_intset_in(*((x1#12->key)), @_vcc_intset_union(treap_keys(*((x1#12->left))), treap_keys(*((x1#12->right))))))), unchecked!(@_vcc_intset_in(*((x1#12->prio)), @_vcc_intset_union(treap_prios(*((x1#12->left))), treap_prios(*((x1#12->right))))))), @_vcc_oset_disjoint(treap_reach(*((x1#12->left))), treap_reach(*((x1#12->right))))), @_vcc_intset_disjoint(treap_keys(*((x1#12->left))), treap_keys(*((x1#12->right))))), @_vcc_intset_disjoint(treap_prios(*((x1#12->left))), treap_prios(*((x1#12->right))))), ==>(@_vcc_ptr_neq_null(*((x1#12->left))), <(treap_max_key(*((x1#12->left))), *((x1#12->key))))), ==>(@_vcc_ptr_neq_null(*((x1#12->right))), <(*((x1#12->key)), treap_min_key(*((x1#12->right)))))), ==>(@_vcc_ptr_neq_null(*((x1#12->left))), <(treap_max_prio(*((x1#12->left))), *((x1#12->prio))))), ==>(@_vcc_ptr_neq_null(*((x1#12->right))), <(treap_max_prio(*((x1#12->right))), *((x1#12->prio))))))); 
                assume $non_null($phys_ptr_cast(x1#12, ^b_node)) ==> F#treap($s, $phys_ptr_cast(x1#12, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(x1#12, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(x1#12, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(x1#12, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(x1#12, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1#12), ==(treap_reach(x1#12), @_vcc_oset_union(@_vcc_oset_singleton(x1#12), @_vcc_oset_union(treap_reach(*((x1#12->left))), treap_reach(*((x1#12->right))))))); 
                assume $non_null($phys_ptr_cast(x1#12, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(x1#12, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(x1#12, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1#12), ==(treap_keys(x1#12), @_vcc_intset_union(@_vcc_intset_singleton(*((x1#12->key))), @_vcc_intset_union(treap_keys(*((x1#12->left))), treap_keys(*((x1#12->right))))))); 
                assume $non_null($phys_ptr_cast(x1#12, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(x1#12, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1#12), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x1#12->left))), @_vcc_ptr_neq_null(*((x1#12->right)))), ==(treap_max_key(x1#12), @\int_max(*((x1#12->key)), @\int_max(treap_max_key(*((x1#12->left))), treap_max_key(*((x1#12->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x1#12->left))), @_vcc_ptr_eq_null(*((x1#12->right)))), ==(treap_max_key(x1#12), @\int_max(*((x1#12->key)), treap_max_key(*((x1#12->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x1#12->left))), @_vcc_ptr_neq_null(*((x1#12->right)))), ==(treap_max_key(x1#12), @\int_max(*((x1#12->key)), treap_max_key(*((x1#12->right)))))))); 
                assume $non_null($phys_ptr_cast(x1#12, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1#12), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x1#12->left))), @_vcc_ptr_neq_null(*((x1#12->right)))), ==(treap_max_prio(x1#12), @\int_max(*((x1#12->prio)), @\int_max(treap_max_prio(*((x1#12->left))), treap_max_prio(*((x1#12->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x1#12->left))), @_vcc_ptr_eq_null(*((x1#12->right)))), ==(treap_max_prio(x1#12), @\int_max(*((x1#12->prio)), treap_max_prio(*((x1#12->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x1#12->left))), @_vcc_ptr_neq_null(*((x1#12->right)))), ==(treap_max_prio(x1#12), @\int_max(*((x1#12->prio)), treap_max_prio(*((x1#12->right)))))))); 
                assume $non_null($phys_ptr_cast(x1#12, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(x1#12, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(x1#12, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(x1#12, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1#12), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x1#12->left))), @_vcc_ptr_neq_null(*((x1#12->right)))), ==(treap_min_key(x1#12), @\int_min(*((x1#12->key)), @\int_min(treap_min_key(*((x1#12->left))), treap_min_key(*((x1#12->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x1#12->left))), @_vcc_ptr_eq_null(*((x1#12->right)))), ==(treap_min_key(x1#12), @\int_min(*((x1#12->key)), treap_min_key(*((x1#12->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x1#12->left))), @_vcc_ptr_neq_null(*((x1#12->right)))), ==(treap_min_key(x1#12), @\int_min(*((x1#12->key)), treap_min_key(*((x1#12->right)))))))); 
                assume $non_null($phys_ptr_cast(x1#12, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1#12), ==(treap_prios(x1#12), @_vcc_intset_union(@_vcc_intset_singleton(*((x1#12->prio))), @_vcc_intset_union(treap_prios(*((x1#12->left))), treap_prios(*((x1#12->right))))))); 
                assume $non_null($phys_ptr_cast(x1#12, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(x1#12, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(x1#12, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0#11), ==(treap(x0#11), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x0#11->left))), treap(*((x0#11->right)))), unchecked!(@_vcc_oset_in(x0#11, @_vcc_oset_union(treap_reach(*((x0#11->left))), treap_reach(*((x0#11->right))))))), unchecked!(@_vcc_intset_in(*((x0#11->key)), @_vcc_intset_union(treap_keys(*((x0#11->left))), treap_keys(*((x0#11->right))))))), unchecked!(@_vcc_intset_in(*((x0#11->prio)), @_vcc_intset_union(treap_prios(*((x0#11->left))), treap_prios(*((x0#11->right))))))), @_vcc_oset_disjoint(treap_reach(*((x0#11->left))), treap_reach(*((x0#11->right))))), @_vcc_intset_disjoint(treap_keys(*((x0#11->left))), treap_keys(*((x0#11->right))))), @_vcc_intset_disjoint(treap_prios(*((x0#11->left))), treap_prios(*((x0#11->right))))), ==>(@_vcc_ptr_neq_null(*((x0#11->left))), <(treap_max_key(*((x0#11->left))), *((x0#11->key))))), ==>(@_vcc_ptr_neq_null(*((x0#11->right))), <(*((x0#11->key)), treap_min_key(*((x0#11->right)))))), ==>(@_vcc_ptr_neq_null(*((x0#11->left))), <(treap_max_prio(*((x0#11->left))), *((x0#11->prio))))), ==>(@_vcc_ptr_neq_null(*((x0#11->right))), <(treap_max_prio(*((x0#11->right))), *((x0#11->prio))))))); 
                assume $non_null($phys_ptr_cast(x0#11, ^b_node)) ==> F#treap($s, $phys_ptr_cast(x0#11, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(x0#11, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(x0#11, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(x0#11, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(x0#11, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0#11), ==(treap_reach(x0#11), @_vcc_oset_union(@_vcc_oset_singleton(x0#11), @_vcc_oset_union(treap_reach(*((x0#11->left))), treap_reach(*((x0#11->right))))))); 
                assume $non_null($phys_ptr_cast(x0#11, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(x0#11, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(x0#11, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0#11), ==(treap_keys(x0#11), @_vcc_intset_union(@_vcc_intset_singleton(*((x0#11->key))), @_vcc_intset_union(treap_keys(*((x0#11->left))), treap_keys(*((x0#11->right))))))); 
                assume $non_null($phys_ptr_cast(x0#11, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(x0#11, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0#11), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x0#11->left))), @_vcc_ptr_neq_null(*((x0#11->right)))), ==(treap_max_key(x0#11), @\int_max(*((x0#11->key)), @\int_max(treap_max_key(*((x0#11->left))), treap_max_key(*((x0#11->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x0#11->left))), @_vcc_ptr_eq_null(*((x0#11->right)))), ==(treap_max_key(x0#11), @\int_max(*((x0#11->key)), treap_max_key(*((x0#11->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x0#11->left))), @_vcc_ptr_neq_null(*((x0#11->right)))), ==(treap_max_key(x0#11), @\int_max(*((x0#11->key)), treap_max_key(*((x0#11->right)))))))); 
                assume $non_null($phys_ptr_cast(x0#11, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0#11), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x0#11->left))), @_vcc_ptr_neq_null(*((x0#11->right)))), ==(treap_max_prio(x0#11), @\int_max(*((x0#11->prio)), @\int_max(treap_max_prio(*((x0#11->left))), treap_max_prio(*((x0#11->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x0#11->left))), @_vcc_ptr_eq_null(*((x0#11->right)))), ==(treap_max_prio(x0#11), @\int_max(*((x0#11->prio)), treap_max_prio(*((x0#11->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x0#11->left))), @_vcc_ptr_neq_null(*((x0#11->right)))), ==(treap_max_prio(x0#11), @\int_max(*((x0#11->prio)), treap_max_prio(*((x0#11->right)))))))); 
                assume $non_null($phys_ptr_cast(x0#11, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(x0#11, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(x0#11, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(x0#11, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0#11), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x0#11->left))), @_vcc_ptr_neq_null(*((x0#11->right)))), ==(treap_min_key(x0#11), @\int_min(*((x0#11->key)), @\int_min(treap_min_key(*((x0#11->left))), treap_min_key(*((x0#11->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x0#11->left))), @_vcc_ptr_eq_null(*((x0#11->right)))), ==(treap_min_key(x0#11), @\int_min(*((x0#11->key)), treap_min_key(*((x0#11->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x0#11->left))), @_vcc_ptr_neq_null(*((x0#11->right)))), ==(treap_min_key(x0#11), @\int_min(*((x0#11->key)), treap_min_key(*((x0#11->right)))))))); 
                assume $non_null($phys_ptr_cast(x0#11, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0#11), ==(treap_prios(x0#11), @_vcc_intset_union(@_vcc_intset_singleton(*((x0#11->prio))), @_vcc_intset_union(treap_prios(*((x0#11->left))), treap_prios(*((x0#11->right))))))); 
                assume $non_null($phys_ptr_cast(x0#11, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(x0#11, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(x0#11, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr#10), ==(treap(xr#10), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((xr#10->left))), treap(*((xr#10->right)))), unchecked!(@_vcc_oset_in(xr#10, @_vcc_oset_union(treap_reach(*((xr#10->left))), treap_reach(*((xr#10->right))))))), unchecked!(@_vcc_intset_in(*((xr#10->key)), @_vcc_intset_union(treap_keys(*((xr#10->left))), treap_keys(*((xr#10->right))))))), unchecked!(@_vcc_intset_in(*((xr#10->prio)), @_vcc_intset_union(treap_prios(*((xr#10->left))), treap_prios(*((xr#10->right))))))), @_vcc_oset_disjoint(treap_reach(*((xr#10->left))), treap_reach(*((xr#10->right))))), @_vcc_intset_disjoint(treap_keys(*((xr#10->left))), treap_keys(*((xr#10->right))))), @_vcc_intset_disjoint(treap_prios(*((xr#10->left))), treap_prios(*((xr#10->right))))), ==>(@_vcc_ptr_neq_null(*((xr#10->left))), <(treap_max_key(*((xr#10->left))), *((xr#10->key))))), ==>(@_vcc_ptr_neq_null(*((xr#10->right))), <(*((xr#10->key)), treap_min_key(*((xr#10->right)))))), ==>(@_vcc_ptr_neq_null(*((xr#10->left))), <(treap_max_prio(*((xr#10->left))), *((xr#10->prio))))), ==>(@_vcc_ptr_neq_null(*((xr#10->right))), <(treap_max_prio(*((xr#10->right))), *((xr#10->prio))))))); 
                assume $non_null($phys_ptr_cast(xr#10, ^b_node)) ==> F#treap($s, $phys_ptr_cast(xr#10, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(xr#10, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr#10), ==(treap_reach(xr#10), @_vcc_oset_union(@_vcc_oset_singleton(xr#10), @_vcc_oset_union(treap_reach(*((xr#10->left))), treap_reach(*((xr#10->right))))))); 
                assume $non_null($phys_ptr_cast(xr#10, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(xr#10, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(xr#10, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr#10), ==(treap_keys(xr#10), @_vcc_intset_union(@_vcc_intset_singleton(*((xr#10->key))), @_vcc_intset_union(treap_keys(*((xr#10->left))), treap_keys(*((xr#10->right))))))); 
                assume $non_null($phys_ptr_cast(xr#10, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(xr#10, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr#10), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr#10->left))), @_vcc_ptr_neq_null(*((xr#10->right)))), ==(treap_max_key(xr#10), @\int_max(*((xr#10->key)), @\int_max(treap_max_key(*((xr#10->left))), treap_max_key(*((xr#10->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr#10->left))), @_vcc_ptr_eq_null(*((xr#10->right)))), ==(treap_max_key(xr#10), @\int_max(*((xr#10->key)), treap_max_key(*((xr#10->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr#10->left))), @_vcc_ptr_neq_null(*((xr#10->right)))), ==(treap_max_key(xr#10), @\int_max(*((xr#10->key)), treap_max_key(*((xr#10->right)))))))); 
                assume $non_null($phys_ptr_cast(xr#10, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr#10), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr#10->left))), @_vcc_ptr_neq_null(*((xr#10->right)))), ==(treap_max_prio(xr#10), @\int_max(*((xr#10->prio)), @\int_max(treap_max_prio(*((xr#10->left))), treap_max_prio(*((xr#10->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr#10->left))), @_vcc_ptr_eq_null(*((xr#10->right)))), ==(treap_max_prio(xr#10), @\int_max(*((xr#10->prio)), treap_max_prio(*((xr#10->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr#10->left))), @_vcc_ptr_neq_null(*((xr#10->right)))), ==(treap_max_prio(xr#10), @\int_max(*((xr#10->prio)), treap_max_prio(*((xr#10->right)))))))); 
                assume $non_null($phys_ptr_cast(xr#10, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr#10), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr#10->left))), @_vcc_ptr_neq_null(*((xr#10->right)))), ==(treap_min_key(xr#10), @\int_min(*((xr#10->key)), @\int_min(treap_min_key(*((xr#10->left))), treap_min_key(*((xr#10->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr#10->left))), @_vcc_ptr_eq_null(*((xr#10->right)))), ==(treap_min_key(xr#10), @\int_min(*((xr#10->key)), treap_min_key(*((xr#10->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr#10->left))), @_vcc_ptr_neq_null(*((xr#10->right)))), ==(treap_min_key(xr#10), @\int_min(*((xr#10->key)), treap_min_key(*((xr#10->right)))))))); 
                assume $non_null($phys_ptr_cast(xr#10, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr#10), ==(treap_prios(xr#10), @_vcc_intset_union(@_vcc_intset_singleton(*((xr#10->prio))), @_vcc_intset_union(treap_prios(*((xr#10->left))), treap_prios(*((xr#10->right))))))); 
                assume $non_null($phys_ptr_cast(xr#10, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(xr#10, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl#9), ==(treap(xl#9), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((xl#9->left))), treap(*((xl#9->right)))), unchecked!(@_vcc_oset_in(xl#9, @_vcc_oset_union(treap_reach(*((xl#9->left))), treap_reach(*((xl#9->right))))))), unchecked!(@_vcc_intset_in(*((xl#9->key)), @_vcc_intset_union(treap_keys(*((xl#9->left))), treap_keys(*((xl#9->right))))))), unchecked!(@_vcc_intset_in(*((xl#9->prio)), @_vcc_intset_union(treap_prios(*((xl#9->left))), treap_prios(*((xl#9->right))))))), @_vcc_oset_disjoint(treap_reach(*((xl#9->left))), treap_reach(*((xl#9->right))))), @_vcc_intset_disjoint(treap_keys(*((xl#9->left))), treap_keys(*((xl#9->right))))), @_vcc_intset_disjoint(treap_prios(*((xl#9->left))), treap_prios(*((xl#9->right))))), ==>(@_vcc_ptr_neq_null(*((xl#9->left))), <(treap_max_key(*((xl#9->left))), *((xl#9->key))))), ==>(@_vcc_ptr_neq_null(*((xl#9->right))), <(*((xl#9->key)), treap_min_key(*((xl#9->right)))))), ==>(@_vcc_ptr_neq_null(*((xl#9->left))), <(treap_max_prio(*((xl#9->left))), *((xl#9->prio))))), ==>(@_vcc_ptr_neq_null(*((xl#9->right))), <(treap_max_prio(*((xl#9->right))), *((xl#9->prio))))))); 
                assume $non_null($phys_ptr_cast(xl#9, ^b_node)) ==> F#treap($s, $phys_ptr_cast(xl#9, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(xl#9, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl#9), ==(treap_reach(xl#9), @_vcc_oset_union(@_vcc_oset_singleton(xl#9), @_vcc_oset_union(treap_reach(*((xl#9->left))), treap_reach(*((xl#9->right))))))); 
                assume $non_null($phys_ptr_cast(xl#9, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(xl#9, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(xl#9, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl#9), ==(treap_keys(xl#9), @_vcc_intset_union(@_vcc_intset_singleton(*((xl#9->key))), @_vcc_intset_union(treap_keys(*((xl#9->left))), treap_keys(*((xl#9->right))))))); 
                assume $non_null($phys_ptr_cast(xl#9, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(xl#9, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl#9), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl#9->left))), @_vcc_ptr_neq_null(*((xl#9->right)))), ==(treap_max_key(xl#9), @\int_max(*((xl#9->key)), @\int_max(treap_max_key(*((xl#9->left))), treap_max_key(*((xl#9->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl#9->left))), @_vcc_ptr_eq_null(*((xl#9->right)))), ==(treap_max_key(xl#9), @\int_max(*((xl#9->key)), treap_max_key(*((xl#9->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl#9->left))), @_vcc_ptr_neq_null(*((xl#9->right)))), ==(treap_max_key(xl#9), @\int_max(*((xl#9->key)), treap_max_key(*((xl#9->right)))))))); 
                assume $non_null($phys_ptr_cast(xl#9, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl#9), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl#9->left))), @_vcc_ptr_neq_null(*((xl#9->right)))), ==(treap_max_prio(xl#9), @\int_max(*((xl#9->prio)), @\int_max(treap_max_prio(*((xl#9->left))), treap_max_prio(*((xl#9->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl#9->left))), @_vcc_ptr_eq_null(*((xl#9->right)))), ==(treap_max_prio(xl#9), @\int_max(*((xl#9->prio)), treap_max_prio(*((xl#9->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl#9->left))), @_vcc_ptr_neq_null(*((xl#9->right)))), ==(treap_max_prio(xl#9), @\int_max(*((xl#9->prio)), treap_max_prio(*((xl#9->right)))))))); 
                assume $non_null($phys_ptr_cast(xl#9, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl#9), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl#9->left))), @_vcc_ptr_neq_null(*((xl#9->right)))), ==(treap_min_key(xl#9), @\int_min(*((xl#9->key)), @\int_min(treap_min_key(*((xl#9->left))), treap_min_key(*((xl#9->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl#9->left))), @_vcc_ptr_eq_null(*((xl#9->right)))), ==(treap_min_key(xl#9), @\int_min(*((xl#9->key)), treap_min_key(*((xl#9->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl#9->left))), @_vcc_ptr_neq_null(*((xl#9->right)))), ==(treap_min_key(xl#9), @\int_min(*((xl#9->key)), treap_min_key(*((xl#9->right)))))))); 
                assume $non_null($phys_ptr_cast(xl#9, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl#9), ==(treap_prios(xl#9), @_vcc_intset_union(@_vcc_intset_singleton(*((xl#9->prio))), @_vcc_intset_union(treap_prios(*((xl#9->left))), treap_prios(*((xl#9->right))))))); 
                assume $non_null($phys_ptr_cast(xl#9, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(xl#9, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), ==(treap(tmp#8), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((tmp#8->left))), treap(*((tmp#8->right)))), unchecked!(@_vcc_oset_in(tmp#8, @_vcc_oset_union(treap_reach(*((tmp#8->left))), treap_reach(*((tmp#8->right))))))), unchecked!(@_vcc_intset_in(*((tmp#8->key)), @_vcc_intset_union(treap_keys(*((tmp#8->left))), treap_keys(*((tmp#8->right))))))), unchecked!(@_vcc_intset_in(*((tmp#8->prio)), @_vcc_intset_union(treap_prios(*((tmp#8->left))), treap_prios(*((tmp#8->right))))))), @_vcc_oset_disjoint(treap_reach(*((tmp#8->left))), treap_reach(*((tmp#8->right))))), @_vcc_intset_disjoint(treap_keys(*((tmp#8->left))), treap_keys(*((tmp#8->right))))), @_vcc_intset_disjoint(treap_prios(*((tmp#8->left))), treap_prios(*((tmp#8->right))))), ==>(@_vcc_ptr_neq_null(*((tmp#8->left))), <(treap_max_key(*((tmp#8->left))), *((tmp#8->key))))), ==>(@_vcc_ptr_neq_null(*((tmp#8->right))), <(*((tmp#8->key)), treap_min_key(*((tmp#8->right)))))), ==>(@_vcc_ptr_neq_null(*((tmp#8->left))), <(treap_max_prio(*((tmp#8->left))), *((tmp#8->prio))))), ==>(@_vcc_ptr_neq_null(*((tmp#8->right))), <(treap_max_prio(*((tmp#8->right))), *((tmp#8->prio))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> F#treap($s, $phys_ptr_cast(tmp#8, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(tmp#8, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), ==(treap_reach(tmp#8), @_vcc_oset_union(@_vcc_oset_singleton(tmp#8), @_vcc_oset_union(treap_reach(*((tmp#8->left))), treap_reach(*((tmp#8->right))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(tmp#8, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(tmp#8, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), ==(treap_keys(tmp#8), @_vcc_intset_union(@_vcc_intset_singleton(*((tmp#8->key))), @_vcc_intset_union(treap_keys(*((tmp#8->left))), treap_keys(*((tmp#8->right))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(tmp#8, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_max_key(tmp#8), @\int_max(*((tmp#8->key)), @\int_max(treap_max_key(*((tmp#8->left))), treap_max_key(*((tmp#8->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_eq_null(*((tmp#8->right)))), ==(treap_max_key(tmp#8), @\int_max(*((tmp#8->key)), treap_max_key(*((tmp#8->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_max_key(tmp#8), @\int_max(*((tmp#8->key)), treap_max_key(*((tmp#8->right)))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_max_prio(tmp#8), @\int_max(*((tmp#8->prio)), @\int_max(treap_max_prio(*((tmp#8->left))), treap_max_prio(*((tmp#8->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_eq_null(*((tmp#8->right)))), ==(treap_max_prio(tmp#8), @\int_max(*((tmp#8->prio)), treap_max_prio(*((tmp#8->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_max_prio(tmp#8), @\int_max(*((tmp#8->prio)), treap_max_prio(*((tmp#8->right)))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_min_key(tmp#8), @\int_min(*((tmp#8->key)), @\int_min(treap_min_key(*((tmp#8->left))), treap_min_key(*((tmp#8->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_eq_null(*((tmp#8->right)))), ==(treap_min_key(tmp#8), @\int_min(*((tmp#8->key)), treap_min_key(*((tmp#8->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_min_key(tmp#8), @\int_min(*((tmp#8->key)), treap_min_key(*((tmp#8->right)))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), ==(treap_prios(tmp#8), @_vcc_intset_union(@_vcc_intset_singleton(*((tmp#8->prio))), @_vcc_intset_union(treap_prios(*((tmp#8->left))), treap_prios(*((tmp#8->right))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(tmp#8, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), ==(treap(x), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x->left))), treap(*((x->right)))), unchecked!(@_vcc_oset_in(x, @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->key)), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->prio)), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))), @_vcc_oset_disjoint(treap_reach(*((x->left))), treap_reach(*((x->right))))), @_vcc_intset_disjoint(treap_keys(*((x->left))), treap_keys(*((x->right))))), @_vcc_intset_disjoint(treap_prios(*((x->left))), treap_prios(*((x->right))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_key(*((x->left))), *((x->key))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(*((x->key)), treap_min_key(*((x->right)))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_prio(*((x->left))), *((x->prio))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(treap_max_prio(*((x->right))), *((x->prio))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap($s, $phys_ptr_cast(P#x, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(P#x, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_reach(x), @_vcc_oset_union(@_vcc_oset_singleton(x), @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(P#x, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(P#x, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_keys(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->key))), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), @\int_max(treap_max_key(*((x->left))), treap_max_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->right)))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), @\int_max(treap_max_prio(*((x->left))), treap_max_prio(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->right)))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), @\int_min(treap_min_key(*((x->left))), treap_min_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->right)))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_prios(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->prio))), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // struct b_node* rl; 
                // struct b_node* tmp2#17; 
                // tmp2#17 := tmp#8; 
                tmp2#17 := $phys_ptr_cast(tmp#8, ^b_node);
                // struct b_node* stmtexpr0#33; 
                // stmtexpr0#33 := tmp2#17; 
                stmtexpr0#33 := $phys_ptr_cast(tmp2#17, ^b_node);
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), ==(treap(tmp#8), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((tmp#8->left))), treap(*((tmp#8->right)))), unchecked!(@_vcc_oset_in(tmp#8, @_vcc_oset_union(treap_reach(*((tmp#8->left))), treap_reach(*((tmp#8->right))))))), unchecked!(@_vcc_intset_in(*((tmp#8->key)), @_vcc_intset_union(treap_keys(*((tmp#8->left))), treap_keys(*((tmp#8->right))))))), unchecked!(@_vcc_intset_in(*((tmp#8->prio)), @_vcc_intset_union(treap_prios(*((tmp#8->left))), treap_prios(*((tmp#8->right))))))), @_vcc_oset_disjoint(treap_reach(*((tmp#8->left))), treap_reach(*((tmp#8->right))))), @_vcc_intset_disjoint(treap_keys(*((tmp#8->left))), treap_keys(*((tmp#8->right))))), @_vcc_intset_disjoint(treap_prios(*((tmp#8->left))), treap_prios(*((tmp#8->right))))), ==>(@_vcc_ptr_neq_null(*((tmp#8->left))), <(treap_max_key(*((tmp#8->left))), *((tmp#8->key))))), ==>(@_vcc_ptr_neq_null(*((tmp#8->right))), <(*((tmp#8->key)), treap_min_key(*((tmp#8->right)))))), ==>(@_vcc_ptr_neq_null(*((tmp#8->left))), <(treap_max_prio(*((tmp#8->left))), *((tmp#8->prio))))), ==>(@_vcc_ptr_neq_null(*((tmp#8->right))), <(treap_max_prio(*((tmp#8->right))), *((tmp#8->prio))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> F#treap($s, $phys_ptr_cast(tmp#8, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(tmp#8, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), ==(treap_reach(tmp#8), @_vcc_oset_union(@_vcc_oset_singleton(tmp#8), @_vcc_oset_union(treap_reach(*((tmp#8->left))), treap_reach(*((tmp#8->right))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(tmp#8, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(tmp#8, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), ==(treap_keys(tmp#8), @_vcc_intset_union(@_vcc_intset_singleton(*((tmp#8->key))), @_vcc_intset_union(treap_keys(*((tmp#8->left))), treap_keys(*((tmp#8->right))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(tmp#8, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_max_key(tmp#8), @\int_max(*((tmp#8->key)), @\int_max(treap_max_key(*((tmp#8->left))), treap_max_key(*((tmp#8->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_eq_null(*((tmp#8->right)))), ==(treap_max_key(tmp#8), @\int_max(*((tmp#8->key)), treap_max_key(*((tmp#8->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_max_key(tmp#8), @\int_max(*((tmp#8->key)), treap_max_key(*((tmp#8->right)))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_max_prio(tmp#8), @\int_max(*((tmp#8->prio)), @\int_max(treap_max_prio(*((tmp#8->left))), treap_max_prio(*((tmp#8->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_eq_null(*((tmp#8->right)))), ==(treap_max_prio(tmp#8), @\int_max(*((tmp#8->prio)), treap_max_prio(*((tmp#8->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_max_prio(tmp#8), @\int_max(*((tmp#8->prio)), treap_max_prio(*((tmp#8->right)))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_min_key(tmp#8), @\int_min(*((tmp#8->key)), @\int_min(treap_min_key(*((tmp#8->left))), treap_min_key(*((tmp#8->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_eq_null(*((tmp#8->right)))), ==(treap_min_key(tmp#8), @\int_min(*((tmp#8->key)), treap_min_key(*((tmp#8->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_min_key(tmp#8), @\int_min(*((tmp#8->key)), treap_min_key(*((tmp#8->right)))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), ==(treap_prios(tmp#8), @_vcc_intset_union(@_vcc_intset_singleton(*((tmp#8->prio))), @_vcc_intset_union(treap_prios(*((tmp#8->left))), treap_prios(*((tmp#8->right))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(tmp#8, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
                // assert @reads_check_normal((tmp#8->left)); 
                assert $thread_local($s, $phys_ptr_cast(tmp#8, ^b_node));
                // rl := *((tmp#8->left)); 
                L#rl := $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node);
                // assume ==>(@_vcc_ptr_neq_null(rl), ==(treap(rl), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((rl->left))), treap(*((rl->right)))), unchecked!(@_vcc_oset_in(rl, @_vcc_oset_union(treap_reach(*((rl->left))), treap_reach(*((rl->right))))))), unchecked!(@_vcc_intset_in(*((rl->key)), @_vcc_intset_union(treap_keys(*((rl->left))), treap_keys(*((rl->right))))))), unchecked!(@_vcc_intset_in(*((rl->prio)), @_vcc_intset_union(treap_prios(*((rl->left))), treap_prios(*((rl->right))))))), @_vcc_oset_disjoint(treap_reach(*((rl->left))), treap_reach(*((rl->right))))), @_vcc_intset_disjoint(treap_keys(*((rl->left))), treap_keys(*((rl->right))))), @_vcc_intset_disjoint(treap_prios(*((rl->left))), treap_prios(*((rl->right))))), ==>(@_vcc_ptr_neq_null(*((rl->left))), <(treap_max_key(*((rl->left))), *((rl->key))))), ==>(@_vcc_ptr_neq_null(*((rl->right))), <(*((rl->key)), treap_min_key(*((rl->right)))))), ==>(@_vcc_ptr_neq_null(*((rl->left))), <(treap_max_prio(*((rl->left))), *((rl->prio))))), ==>(@_vcc_ptr_neq_null(*((rl->right))), <(treap_max_prio(*((rl->right))), *((rl->prio))))))); 
                assume $non_null($phys_ptr_cast(L#rl, ^b_node)) ==> F#treap($s, $phys_ptr_cast(L#rl, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(L#rl, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(L#rl, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(L#rl, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(L#rl, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#rl, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#rl, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#rl, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(rl), ==(treap_reach(rl), @_vcc_oset_union(@_vcc_oset_singleton(rl), @_vcc_oset_union(treap_reach(*((rl->left))), treap_reach(*((rl->right))))))); 
                assume $non_null($phys_ptr_cast(L#rl, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(L#rl, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(L#rl, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(rl), ==(treap_keys(rl), @_vcc_intset_union(@_vcc_intset_singleton(*((rl->key))), @_vcc_intset_union(treap_keys(*((rl->left))), treap_keys(*((rl->right))))))); 
                assume $non_null($phys_ptr_cast(L#rl, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(L#rl, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(L#rl, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(rl), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((rl->left))), @_vcc_ptr_neq_null(*((rl->right)))), ==(treap_max_key(rl), @\int_max(*((rl->key)), @\int_max(treap_max_key(*((rl->left))), treap_max_key(*((rl->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((rl->left))), @_vcc_ptr_eq_null(*((rl->right)))), ==(treap_max_key(rl), @\int_max(*((rl->key)), treap_max_key(*((rl->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((rl->left))), @_vcc_ptr_neq_null(*((rl->right)))), ==(treap_max_key(rl), @\int_max(*((rl->key)), treap_max_key(*((rl->right)))))))); 
                assume $non_null($phys_ptr_cast(L#rl, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#rl, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#rl, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#rl, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#rl, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#rl, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#rl, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(rl), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((rl->left))), @_vcc_ptr_neq_null(*((rl->right)))), ==(treap_max_prio(rl), @\int_max(*((rl->prio)), @\int_max(treap_max_prio(*((rl->left))), treap_max_prio(*((rl->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((rl->left))), @_vcc_ptr_eq_null(*((rl->right)))), ==(treap_max_prio(rl), @\int_max(*((rl->prio)), treap_max_prio(*((rl->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((rl->left))), @_vcc_ptr_neq_null(*((rl->right)))), ==(treap_max_prio(rl), @\int_max(*((rl->prio)), treap_max_prio(*((rl->right)))))))); 
                assume $non_null($phys_ptr_cast(L#rl, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#rl, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#rl, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#rl, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#rl, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#rl, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#rl, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(rl), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((rl->left))), @_vcc_ptr_neq_null(*((rl->right)))), ==(treap_min_key(rl), @\int_min(*((rl->key)), @\int_min(treap_min_key(*((rl->left))), treap_min_key(*((rl->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((rl->left))), @_vcc_ptr_eq_null(*((rl->right)))), ==(treap_min_key(rl), @\int_min(*((rl->key)), treap_min_key(*((rl->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((rl->left))), @_vcc_ptr_neq_null(*((rl->right)))), ==(treap_min_key(rl), @\int_min(*((rl->key)), treap_min_key(*((rl->right)))))))); 
                assume $non_null($phys_ptr_cast(L#rl, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#rl, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#rl, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#rl, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#rl, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#rl, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#rl, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(rl), ==(treap_prios(rl), @_vcc_intset_union(@_vcc_intset_singleton(*((rl->prio))), @_vcc_intset_union(treap_prios(*((rl->left))), treap_prios(*((rl->right))))))); 
                assume $non_null($phys_ptr_cast(L#rl, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(L#rl, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(L#rl, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), ==(treap(tmp#8), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((tmp#8->left))), treap(*((tmp#8->right)))), unchecked!(@_vcc_oset_in(tmp#8, @_vcc_oset_union(treap_reach(*((tmp#8->left))), treap_reach(*((tmp#8->right))))))), unchecked!(@_vcc_intset_in(*((tmp#8->key)), @_vcc_intset_union(treap_keys(*((tmp#8->left))), treap_keys(*((tmp#8->right))))))), unchecked!(@_vcc_intset_in(*((tmp#8->prio)), @_vcc_intset_union(treap_prios(*((tmp#8->left))), treap_prios(*((tmp#8->right))))))), @_vcc_oset_disjoint(treap_reach(*((tmp#8->left))), treap_reach(*((tmp#8->right))))), @_vcc_intset_disjoint(treap_keys(*((tmp#8->left))), treap_keys(*((tmp#8->right))))), @_vcc_intset_disjoint(treap_prios(*((tmp#8->left))), treap_prios(*((tmp#8->right))))), ==>(@_vcc_ptr_neq_null(*((tmp#8->left))), <(treap_max_key(*((tmp#8->left))), *((tmp#8->key))))), ==>(@_vcc_ptr_neq_null(*((tmp#8->right))), <(*((tmp#8->key)), treap_min_key(*((tmp#8->right)))))), ==>(@_vcc_ptr_neq_null(*((tmp#8->left))), <(treap_max_prio(*((tmp#8->left))), *((tmp#8->prio))))), ==>(@_vcc_ptr_neq_null(*((tmp#8->right))), <(treap_max_prio(*((tmp#8->right))), *((tmp#8->prio))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> F#treap($s, $phys_ptr_cast(tmp#8, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(tmp#8, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), ==(treap_reach(tmp#8), @_vcc_oset_union(@_vcc_oset_singleton(tmp#8), @_vcc_oset_union(treap_reach(*((tmp#8->left))), treap_reach(*((tmp#8->right))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(tmp#8, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(tmp#8, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), ==(treap_keys(tmp#8), @_vcc_intset_union(@_vcc_intset_singleton(*((tmp#8->key))), @_vcc_intset_union(treap_keys(*((tmp#8->left))), treap_keys(*((tmp#8->right))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(tmp#8, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_max_key(tmp#8), @\int_max(*((tmp#8->key)), @\int_max(treap_max_key(*((tmp#8->left))), treap_max_key(*((tmp#8->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_eq_null(*((tmp#8->right)))), ==(treap_max_key(tmp#8), @\int_max(*((tmp#8->key)), treap_max_key(*((tmp#8->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_max_key(tmp#8), @\int_max(*((tmp#8->key)), treap_max_key(*((tmp#8->right)))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_max_prio(tmp#8), @\int_max(*((tmp#8->prio)), @\int_max(treap_max_prio(*((tmp#8->left))), treap_max_prio(*((tmp#8->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_eq_null(*((tmp#8->right)))), ==(treap_max_prio(tmp#8), @\int_max(*((tmp#8->prio)), treap_max_prio(*((tmp#8->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_max_prio(tmp#8), @\int_max(*((tmp#8->prio)), treap_max_prio(*((tmp#8->right)))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_min_key(tmp#8), @\int_min(*((tmp#8->key)), @\int_min(treap_min_key(*((tmp#8->left))), treap_min_key(*((tmp#8->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_eq_null(*((tmp#8->right)))), ==(treap_min_key(tmp#8), @\int_min(*((tmp#8->key)), treap_min_key(*((tmp#8->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_min_key(tmp#8), @\int_min(*((tmp#8->key)), treap_min_key(*((tmp#8->right)))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), ==(treap_prios(tmp#8), @_vcc_intset_union(@_vcc_intset_singleton(*((tmp#8->prio))), @_vcc_intset_union(treap_prios(*((tmp#8->left))), treap_prios(*((tmp#8->right))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(tmp#8, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
                // _math \state _dryad_S2#18; 
                // _dryad_S2#18 := @_vcc_current_state(@state); 
                _dryad_S2#18 := $current_state($s);
                // _math \state stmtexpr1#34; 
                // stmtexpr1#34 := _dryad_S2#18; 
                stmtexpr1#34 := _dryad_S2#18;
                // assert @prim_writes_check((x->right)); 
                assert $writable_prim($s, #wrTime$3^5.3, $dot($phys_ptr_cast(P#x, ^b_node), b_node.right));
                // *(x->right) := rl; 
                call $write_int(b_node.right, $phys_ptr_cast(P#x, ^b_node), $ptr_to_int($phys_ptr_cast(L#rl, ^b_node)));
                assume $full_stop_ext(#tok$3^80.9, $s);
                // _math \state _dryad_S3#19; 
                // _dryad_S3#19 := @_vcc_current_state(@state); 
                _dryad_S3#19 := $current_state($s);
                // _math \state stmtexpr2#35; 
                // stmtexpr2#35 := _dryad_S3#19; 
                stmtexpr2#35 := _dryad_S3#19;
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(*((x->left)))))), ==(old(_dryad_S2#18, treap(*((x->left)))), old(_dryad_S3#19, treap(*((x->left)))))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $rd_phys_ptr(_dryad_S2#18, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node))) ==> F#treap(_dryad_S2#18, $rd_phys_ptr(_dryad_S2#18, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) == F#treap(_dryad_S3#19, $rd_phys_ptr(_dryad_S3#19, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(*((x->left)))))), ==(old(_dryad_S2#18, treap_reach(*((x->left)))), old(_dryad_S3#19, treap_reach(*((x->left)))))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $rd_phys_ptr(_dryad_S2#18, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node))) ==> F#treap_reach(_dryad_S2#18, $rd_phys_ptr(_dryad_S2#18, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) == F#treap_reach(_dryad_S3#19, $rd_phys_ptr(_dryad_S3#19, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(*((x->left)))))), ==(old(_dryad_S2#18, treap_keys(*((x->left)))), old(_dryad_S3#19, treap_keys(*((x->left)))))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $rd_phys_ptr(_dryad_S2#18, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node))) ==> F#treap_keys(_dryad_S2#18, $rd_phys_ptr(_dryad_S2#18, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) == F#treap_keys(_dryad_S3#19, $rd_phys_ptr(_dryad_S3#19, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(*((x->left)))))), ==(old(_dryad_S2#18, treap_max_key(*((x->left)))), old(_dryad_S3#19, treap_max_key(*((x->left)))))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $rd_phys_ptr(_dryad_S2#18, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node))) ==> F#treap_max_key(_dryad_S2#18, $rd_phys_ptr(_dryad_S2#18, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) == F#treap_max_key(_dryad_S3#19, $rd_phys_ptr(_dryad_S3#19, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(*((x->left)))))), ==(old(_dryad_S2#18, treap_max_prio(*((x->left)))), old(_dryad_S3#19, treap_max_prio(*((x->left)))))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $rd_phys_ptr(_dryad_S2#18, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node))) ==> F#treap_max_prio(_dryad_S2#18, $rd_phys_ptr(_dryad_S2#18, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) == F#treap_max_prio(_dryad_S3#19, $rd_phys_ptr(_dryad_S3#19, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(*((x->left)))))), ==(old(_dryad_S2#18, treap_min_key(*((x->left)))), old(_dryad_S3#19, treap_min_key(*((x->left)))))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $rd_phys_ptr(_dryad_S2#18, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node))) ==> F#treap_min_key(_dryad_S2#18, $rd_phys_ptr(_dryad_S2#18, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) == F#treap_min_key(_dryad_S3#19, $rd_phys_ptr(_dryad_S3#19, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(*((x->left)))))), ==(old(_dryad_S2#18, treap_prios(*((x->left)))), old(_dryad_S3#19, treap_prios(*((x->left)))))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $rd_phys_ptr(_dryad_S2#18, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node))) ==> F#treap_prios(_dryad_S2#18, $rd_phys_ptr(_dryad_S2#18, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) == F#treap_prios(_dryad_S3#19, $rd_phys_ptr(_dryad_S3#19, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(tmp2#17)))), ==(old(_dryad_S2#18, treap(tmp2#17)), old(_dryad_S3#19, treap(tmp2#17)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $phys_ptr_cast(tmp2#17, ^b_node))) ==> F#treap(_dryad_S2#18, $phys_ptr_cast(tmp2#17, ^b_node)) == F#treap(_dryad_S3#19, $phys_ptr_cast(tmp2#17, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(tmp2#17)))), ==(old(_dryad_S2#18, treap_reach(tmp2#17)), old(_dryad_S3#19, treap_reach(tmp2#17)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $phys_ptr_cast(tmp2#17, ^b_node))) ==> F#treap_reach(_dryad_S2#18, $phys_ptr_cast(tmp2#17, ^b_node)) == F#treap_reach(_dryad_S3#19, $phys_ptr_cast(tmp2#17, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(tmp2#17)))), ==(old(_dryad_S2#18, treap_keys(tmp2#17)), old(_dryad_S3#19, treap_keys(tmp2#17)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $phys_ptr_cast(tmp2#17, ^b_node))) ==> F#treap_keys(_dryad_S2#18, $phys_ptr_cast(tmp2#17, ^b_node)) == F#treap_keys(_dryad_S3#19, $phys_ptr_cast(tmp2#17, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(tmp2#17)))), ==(old(_dryad_S2#18, treap_max_key(tmp2#17)), old(_dryad_S3#19, treap_max_key(tmp2#17)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $phys_ptr_cast(tmp2#17, ^b_node))) ==> F#treap_max_key(_dryad_S2#18, $phys_ptr_cast(tmp2#17, ^b_node)) == F#treap_max_key(_dryad_S3#19, $phys_ptr_cast(tmp2#17, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(tmp2#17)))), ==(old(_dryad_S2#18, treap_max_prio(tmp2#17)), old(_dryad_S3#19, treap_max_prio(tmp2#17)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $phys_ptr_cast(tmp2#17, ^b_node))) ==> F#treap_max_prio(_dryad_S2#18, $phys_ptr_cast(tmp2#17, ^b_node)) == F#treap_max_prio(_dryad_S3#19, $phys_ptr_cast(tmp2#17, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(tmp2#17)))), ==(old(_dryad_S2#18, treap_min_key(tmp2#17)), old(_dryad_S3#19, treap_min_key(tmp2#17)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $phys_ptr_cast(tmp2#17, ^b_node))) ==> F#treap_min_key(_dryad_S2#18, $phys_ptr_cast(tmp2#17, ^b_node)) == F#treap_min_key(_dryad_S3#19, $phys_ptr_cast(tmp2#17, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(tmp2#17)))), ==(old(_dryad_S2#18, treap_prios(tmp2#17)), old(_dryad_S3#19, treap_prios(tmp2#17)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $phys_ptr_cast(tmp2#17, ^b_node))) ==> F#treap_prios(_dryad_S2#18, $phys_ptr_cast(tmp2#17, ^b_node)) == F#treap_prios(_dryad_S3#19, $phys_ptr_cast(tmp2#17, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(rl)))), ==(old(_dryad_S2#18, treap(rl)), old(_dryad_S3#19, treap(rl)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $phys_ptr_cast(L#rl, ^b_node))) ==> F#treap(_dryad_S2#18, $phys_ptr_cast(L#rl, ^b_node)) == F#treap(_dryad_S3#19, $phys_ptr_cast(L#rl, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(rl)))), ==(old(_dryad_S2#18, treap_reach(rl)), old(_dryad_S3#19, treap_reach(rl)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $phys_ptr_cast(L#rl, ^b_node))) ==> F#treap_reach(_dryad_S2#18, $phys_ptr_cast(L#rl, ^b_node)) == F#treap_reach(_dryad_S3#19, $phys_ptr_cast(L#rl, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(rl)))), ==(old(_dryad_S2#18, treap_keys(rl)), old(_dryad_S3#19, treap_keys(rl)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $phys_ptr_cast(L#rl, ^b_node))) ==> F#treap_keys(_dryad_S2#18, $phys_ptr_cast(L#rl, ^b_node)) == F#treap_keys(_dryad_S3#19, $phys_ptr_cast(L#rl, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(rl)))), ==(old(_dryad_S2#18, treap_max_key(rl)), old(_dryad_S3#19, treap_max_key(rl)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $phys_ptr_cast(L#rl, ^b_node))) ==> F#treap_max_key(_dryad_S2#18, $phys_ptr_cast(L#rl, ^b_node)) == F#treap_max_key(_dryad_S3#19, $phys_ptr_cast(L#rl, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(rl)))), ==(old(_dryad_S2#18, treap_max_prio(rl)), old(_dryad_S3#19, treap_max_prio(rl)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $phys_ptr_cast(L#rl, ^b_node))) ==> F#treap_max_prio(_dryad_S2#18, $phys_ptr_cast(L#rl, ^b_node)) == F#treap_max_prio(_dryad_S3#19, $phys_ptr_cast(L#rl, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(rl)))), ==(old(_dryad_S2#18, treap_min_key(rl)), old(_dryad_S3#19, treap_min_key(rl)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $phys_ptr_cast(L#rl, ^b_node))) ==> F#treap_min_key(_dryad_S2#18, $phys_ptr_cast(L#rl, ^b_node)) == F#treap_min_key(_dryad_S3#19, $phys_ptr_cast(L#rl, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(rl)))), ==(old(_dryad_S2#18, treap_prios(rl)), old(_dryad_S3#19, treap_prios(rl)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $phys_ptr_cast(L#rl, ^b_node))) ==> F#treap_prios(_dryad_S2#18, $phys_ptr_cast(L#rl, ^b_node)) == F#treap_prios(_dryad_S3#19, $phys_ptr_cast(L#rl, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(x1#12)))), ==(old(_dryad_S2#18, treap(x1#12)), old(_dryad_S3#19, treap(x1#12)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $phys_ptr_cast(x1#12, ^b_node))) ==> F#treap(_dryad_S2#18, $phys_ptr_cast(x1#12, ^b_node)) == F#treap(_dryad_S3#19, $phys_ptr_cast(x1#12, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(x1#12)))), ==(old(_dryad_S2#18, treap_reach(x1#12)), old(_dryad_S3#19, treap_reach(x1#12)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $phys_ptr_cast(x1#12, ^b_node))) ==> F#treap_reach(_dryad_S2#18, $phys_ptr_cast(x1#12, ^b_node)) == F#treap_reach(_dryad_S3#19, $phys_ptr_cast(x1#12, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(x1#12)))), ==(old(_dryad_S2#18, treap_keys(x1#12)), old(_dryad_S3#19, treap_keys(x1#12)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $phys_ptr_cast(x1#12, ^b_node))) ==> F#treap_keys(_dryad_S2#18, $phys_ptr_cast(x1#12, ^b_node)) == F#treap_keys(_dryad_S3#19, $phys_ptr_cast(x1#12, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(x1#12)))), ==(old(_dryad_S2#18, treap_max_key(x1#12)), old(_dryad_S3#19, treap_max_key(x1#12)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $phys_ptr_cast(x1#12, ^b_node))) ==> F#treap_max_key(_dryad_S2#18, $phys_ptr_cast(x1#12, ^b_node)) == F#treap_max_key(_dryad_S3#19, $phys_ptr_cast(x1#12, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(x1#12)))), ==(old(_dryad_S2#18, treap_max_prio(x1#12)), old(_dryad_S3#19, treap_max_prio(x1#12)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $phys_ptr_cast(x1#12, ^b_node))) ==> F#treap_max_prio(_dryad_S2#18, $phys_ptr_cast(x1#12, ^b_node)) == F#treap_max_prio(_dryad_S3#19, $phys_ptr_cast(x1#12, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(x1#12)))), ==(old(_dryad_S2#18, treap_min_key(x1#12)), old(_dryad_S3#19, treap_min_key(x1#12)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $phys_ptr_cast(x1#12, ^b_node))) ==> F#treap_min_key(_dryad_S2#18, $phys_ptr_cast(x1#12, ^b_node)) == F#treap_min_key(_dryad_S3#19, $phys_ptr_cast(x1#12, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(x1#12)))), ==(old(_dryad_S2#18, treap_prios(x1#12)), old(_dryad_S3#19, treap_prios(x1#12)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $phys_ptr_cast(x1#12, ^b_node))) ==> F#treap_prios(_dryad_S2#18, $phys_ptr_cast(x1#12, ^b_node)) == F#treap_prios(_dryad_S3#19, $phys_ptr_cast(x1#12, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(x0#11)))), ==(old(_dryad_S2#18, treap(x0#11)), old(_dryad_S3#19, treap(x0#11)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $phys_ptr_cast(x0#11, ^b_node))) ==> F#treap(_dryad_S2#18, $phys_ptr_cast(x0#11, ^b_node)) == F#treap(_dryad_S3#19, $phys_ptr_cast(x0#11, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(x0#11)))), ==(old(_dryad_S2#18, treap_reach(x0#11)), old(_dryad_S3#19, treap_reach(x0#11)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $phys_ptr_cast(x0#11, ^b_node))) ==> F#treap_reach(_dryad_S2#18, $phys_ptr_cast(x0#11, ^b_node)) == F#treap_reach(_dryad_S3#19, $phys_ptr_cast(x0#11, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(x0#11)))), ==(old(_dryad_S2#18, treap_keys(x0#11)), old(_dryad_S3#19, treap_keys(x0#11)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $phys_ptr_cast(x0#11, ^b_node))) ==> F#treap_keys(_dryad_S2#18, $phys_ptr_cast(x0#11, ^b_node)) == F#treap_keys(_dryad_S3#19, $phys_ptr_cast(x0#11, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(x0#11)))), ==(old(_dryad_S2#18, treap_max_key(x0#11)), old(_dryad_S3#19, treap_max_key(x0#11)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $phys_ptr_cast(x0#11, ^b_node))) ==> F#treap_max_key(_dryad_S2#18, $phys_ptr_cast(x0#11, ^b_node)) == F#treap_max_key(_dryad_S3#19, $phys_ptr_cast(x0#11, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(x0#11)))), ==(old(_dryad_S2#18, treap_max_prio(x0#11)), old(_dryad_S3#19, treap_max_prio(x0#11)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $phys_ptr_cast(x0#11, ^b_node))) ==> F#treap_max_prio(_dryad_S2#18, $phys_ptr_cast(x0#11, ^b_node)) == F#treap_max_prio(_dryad_S3#19, $phys_ptr_cast(x0#11, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(x0#11)))), ==(old(_dryad_S2#18, treap_min_key(x0#11)), old(_dryad_S3#19, treap_min_key(x0#11)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $phys_ptr_cast(x0#11, ^b_node))) ==> F#treap_min_key(_dryad_S2#18, $phys_ptr_cast(x0#11, ^b_node)) == F#treap_min_key(_dryad_S3#19, $phys_ptr_cast(x0#11, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(x0#11)))), ==(old(_dryad_S2#18, treap_prios(x0#11)), old(_dryad_S3#19, treap_prios(x0#11)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $phys_ptr_cast(x0#11, ^b_node))) ==> F#treap_prios(_dryad_S2#18, $phys_ptr_cast(x0#11, ^b_node)) == F#treap_prios(_dryad_S3#19, $phys_ptr_cast(x0#11, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(xr#10)))), ==(old(_dryad_S2#18, treap(xr#10)), old(_dryad_S3#19, treap(xr#10)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $phys_ptr_cast(xr#10, ^b_node))) ==> F#treap(_dryad_S2#18, $phys_ptr_cast(xr#10, ^b_node)) == F#treap(_dryad_S3#19, $phys_ptr_cast(xr#10, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(xr#10)))), ==(old(_dryad_S2#18, treap_reach(xr#10)), old(_dryad_S3#19, treap_reach(xr#10)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $phys_ptr_cast(xr#10, ^b_node))) ==> F#treap_reach(_dryad_S2#18, $phys_ptr_cast(xr#10, ^b_node)) == F#treap_reach(_dryad_S3#19, $phys_ptr_cast(xr#10, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(xr#10)))), ==(old(_dryad_S2#18, treap_keys(xr#10)), old(_dryad_S3#19, treap_keys(xr#10)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $phys_ptr_cast(xr#10, ^b_node))) ==> F#treap_keys(_dryad_S2#18, $phys_ptr_cast(xr#10, ^b_node)) == F#treap_keys(_dryad_S3#19, $phys_ptr_cast(xr#10, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(xr#10)))), ==(old(_dryad_S2#18, treap_max_key(xr#10)), old(_dryad_S3#19, treap_max_key(xr#10)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $phys_ptr_cast(xr#10, ^b_node))) ==> F#treap_max_key(_dryad_S2#18, $phys_ptr_cast(xr#10, ^b_node)) == F#treap_max_key(_dryad_S3#19, $phys_ptr_cast(xr#10, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(xr#10)))), ==(old(_dryad_S2#18, treap_max_prio(xr#10)), old(_dryad_S3#19, treap_max_prio(xr#10)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $phys_ptr_cast(xr#10, ^b_node))) ==> F#treap_max_prio(_dryad_S2#18, $phys_ptr_cast(xr#10, ^b_node)) == F#treap_max_prio(_dryad_S3#19, $phys_ptr_cast(xr#10, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(xr#10)))), ==(old(_dryad_S2#18, treap_min_key(xr#10)), old(_dryad_S3#19, treap_min_key(xr#10)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $phys_ptr_cast(xr#10, ^b_node))) ==> F#treap_min_key(_dryad_S2#18, $phys_ptr_cast(xr#10, ^b_node)) == F#treap_min_key(_dryad_S3#19, $phys_ptr_cast(xr#10, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(xr#10)))), ==(old(_dryad_S2#18, treap_prios(xr#10)), old(_dryad_S3#19, treap_prios(xr#10)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $phys_ptr_cast(xr#10, ^b_node))) ==> F#treap_prios(_dryad_S2#18, $phys_ptr_cast(xr#10, ^b_node)) == F#treap_prios(_dryad_S3#19, $phys_ptr_cast(xr#10, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(xl#9)))), ==(old(_dryad_S2#18, treap(xl#9)), old(_dryad_S3#19, treap(xl#9)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $phys_ptr_cast(xl#9, ^b_node))) ==> F#treap(_dryad_S2#18, $phys_ptr_cast(xl#9, ^b_node)) == F#treap(_dryad_S3#19, $phys_ptr_cast(xl#9, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(xl#9)))), ==(old(_dryad_S2#18, treap_reach(xl#9)), old(_dryad_S3#19, treap_reach(xl#9)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $phys_ptr_cast(xl#9, ^b_node))) ==> F#treap_reach(_dryad_S2#18, $phys_ptr_cast(xl#9, ^b_node)) == F#treap_reach(_dryad_S3#19, $phys_ptr_cast(xl#9, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(xl#9)))), ==(old(_dryad_S2#18, treap_keys(xl#9)), old(_dryad_S3#19, treap_keys(xl#9)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $phys_ptr_cast(xl#9, ^b_node))) ==> F#treap_keys(_dryad_S2#18, $phys_ptr_cast(xl#9, ^b_node)) == F#treap_keys(_dryad_S3#19, $phys_ptr_cast(xl#9, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(xl#9)))), ==(old(_dryad_S2#18, treap_max_key(xl#9)), old(_dryad_S3#19, treap_max_key(xl#9)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $phys_ptr_cast(xl#9, ^b_node))) ==> F#treap_max_key(_dryad_S2#18, $phys_ptr_cast(xl#9, ^b_node)) == F#treap_max_key(_dryad_S3#19, $phys_ptr_cast(xl#9, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(xl#9)))), ==(old(_dryad_S2#18, treap_max_prio(xl#9)), old(_dryad_S3#19, treap_max_prio(xl#9)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $phys_ptr_cast(xl#9, ^b_node))) ==> F#treap_max_prio(_dryad_S2#18, $phys_ptr_cast(xl#9, ^b_node)) == F#treap_max_prio(_dryad_S3#19, $phys_ptr_cast(xl#9, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(xl#9)))), ==(old(_dryad_S2#18, treap_min_key(xl#9)), old(_dryad_S3#19, treap_min_key(xl#9)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $phys_ptr_cast(xl#9, ^b_node))) ==> F#treap_min_key(_dryad_S2#18, $phys_ptr_cast(xl#9, ^b_node)) == F#treap_min_key(_dryad_S3#19, $phys_ptr_cast(xl#9, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(xl#9)))), ==(old(_dryad_S2#18, treap_prios(xl#9)), old(_dryad_S3#19, treap_prios(xl#9)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $phys_ptr_cast(xl#9, ^b_node))) ==> F#treap_prios(_dryad_S2#18, $phys_ptr_cast(xl#9, ^b_node)) == F#treap_prios(_dryad_S3#19, $phys_ptr_cast(xl#9, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(tmp#8)))), ==(old(_dryad_S2#18, treap(tmp#8)), old(_dryad_S3#19, treap(tmp#8)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $phys_ptr_cast(tmp#8, ^b_node))) ==> F#treap(_dryad_S2#18, $phys_ptr_cast(tmp#8, ^b_node)) == F#treap(_dryad_S3#19, $phys_ptr_cast(tmp#8, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(tmp#8)))), ==(old(_dryad_S2#18, treap_reach(tmp#8)), old(_dryad_S3#19, treap_reach(tmp#8)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $phys_ptr_cast(tmp#8, ^b_node))) ==> F#treap_reach(_dryad_S2#18, $phys_ptr_cast(tmp#8, ^b_node)) == F#treap_reach(_dryad_S3#19, $phys_ptr_cast(tmp#8, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(tmp#8)))), ==(old(_dryad_S2#18, treap_keys(tmp#8)), old(_dryad_S3#19, treap_keys(tmp#8)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $phys_ptr_cast(tmp#8, ^b_node))) ==> F#treap_keys(_dryad_S2#18, $phys_ptr_cast(tmp#8, ^b_node)) == F#treap_keys(_dryad_S3#19, $phys_ptr_cast(tmp#8, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(tmp#8)))), ==(old(_dryad_S2#18, treap_max_key(tmp#8)), old(_dryad_S3#19, treap_max_key(tmp#8)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $phys_ptr_cast(tmp#8, ^b_node))) ==> F#treap_max_key(_dryad_S2#18, $phys_ptr_cast(tmp#8, ^b_node)) == F#treap_max_key(_dryad_S3#19, $phys_ptr_cast(tmp#8, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(tmp#8)))), ==(old(_dryad_S2#18, treap_max_prio(tmp#8)), old(_dryad_S3#19, treap_max_prio(tmp#8)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $phys_ptr_cast(tmp#8, ^b_node))) ==> F#treap_max_prio(_dryad_S2#18, $phys_ptr_cast(tmp#8, ^b_node)) == F#treap_max_prio(_dryad_S3#19, $phys_ptr_cast(tmp#8, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(tmp#8)))), ==(old(_dryad_S2#18, treap_min_key(tmp#8)), old(_dryad_S3#19, treap_min_key(tmp#8)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $phys_ptr_cast(tmp#8, ^b_node))) ==> F#treap_min_key(_dryad_S2#18, $phys_ptr_cast(tmp#8, ^b_node)) == F#treap_min_key(_dryad_S3#19, $phys_ptr_cast(tmp#8, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(x, old(_dryad_S2#18, treap_reach(tmp#8)))), ==(old(_dryad_S2#18, treap_prios(tmp#8)), old(_dryad_S3#19, treap_prios(tmp#8)))); 
                assume !$oset_in($phys_ptr_cast(P#x, ^b_node), F#treap_reach(_dryad_S2#18, $phys_ptr_cast(tmp#8, ^b_node))) ==> F#treap_prios(_dryad_S2#18, $phys_ptr_cast(tmp#8, ^b_node)) == F#treap_prios(_dryad_S3#19, $phys_ptr_cast(tmp#8, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(x, tmp2#17)), @_vcc_ptr_eq_pure(*((tmp2#17->left)), old(_dryad_S2#18, *((tmp2#17->left))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(tmp2#17, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#18, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(x, tmp2#17)), @_vcc_ptr_eq_pure(*((tmp2#17->right)), old(_dryad_S2#18, *((tmp2#17->right))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(tmp2#17, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#18, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(x, tmp2#17)), ==(*((tmp2#17->key)), old(_dryad_S2#18, *((tmp2#17->key))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(tmp2#17, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(tmp2#17, ^b_node)) == $rd_inv(_dryad_S2#18, b_node.key, $phys_ptr_cast(tmp2#17, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(x, tmp2#17)), ==(*((tmp2#17->prio)), old(_dryad_S2#18, *((tmp2#17->prio))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(tmp2#17, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(tmp2#17, ^b_node)) == $rd_inv(_dryad_S2#18, b_node.prio, $phys_ptr_cast(tmp2#17, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(x, rl)), @_vcc_ptr_eq_pure(*((rl->left)), old(_dryad_S2#18, *((rl->left))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(L#rl, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#18, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(x, rl)), @_vcc_ptr_eq_pure(*((rl->right)), old(_dryad_S2#18, *((rl->right))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(L#rl, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#18, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(x, rl)), ==(*((rl->key)), old(_dryad_S2#18, *((rl->key))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(L#rl, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#rl, ^b_node)) == $rd_inv(_dryad_S2#18, b_node.key, $phys_ptr_cast(L#rl, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(x, rl)), ==(*((rl->prio)), old(_dryad_S2#18, *((rl->prio))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(L#rl, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(L#rl, ^b_node)) == $rd_inv(_dryad_S2#18, b_node.prio, $phys_ptr_cast(L#rl, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(x, x1#12)), @_vcc_ptr_eq_pure(*((x1#12->left)), old(_dryad_S2#18, *((x1#12->left))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(x1#12, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#18, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(x, x1#12)), @_vcc_ptr_eq_pure(*((x1#12->right)), old(_dryad_S2#18, *((x1#12->right))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(x1#12, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#18, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(x, x1#12)), ==(*((x1#12->key)), old(_dryad_S2#18, *((x1#12->key))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(x1#12, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)) == $rd_inv(_dryad_S2#18, b_node.key, $phys_ptr_cast(x1#12, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(x, x1#12)), ==(*((x1#12->prio)), old(_dryad_S2#18, *((x1#12->prio))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(x1#12, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(x1#12, ^b_node)) == $rd_inv(_dryad_S2#18, b_node.prio, $phys_ptr_cast(x1#12, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(x, x0#11)), @_vcc_ptr_eq_pure(*((x0#11->left)), old(_dryad_S2#18, *((x0#11->left))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(x0#11, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#18, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(x, x0#11)), @_vcc_ptr_eq_pure(*((x0#11->right)), old(_dryad_S2#18, *((x0#11->right))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(x0#11, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#18, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(x, x0#11)), ==(*((x0#11->key)), old(_dryad_S2#18, *((x0#11->key))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(x0#11, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)) == $rd_inv(_dryad_S2#18, b_node.key, $phys_ptr_cast(x0#11, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(x, x0#11)), ==(*((x0#11->prio)), old(_dryad_S2#18, *((x0#11->prio))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(x0#11, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(x0#11, ^b_node)) == $rd_inv(_dryad_S2#18, b_node.prio, $phys_ptr_cast(x0#11, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(x, xr#10)), @_vcc_ptr_eq_pure(*((xr#10->left)), old(_dryad_S2#18, *((xr#10->left))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(xr#10, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#18, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(x, xr#10)), @_vcc_ptr_eq_pure(*((xr#10->right)), old(_dryad_S2#18, *((xr#10->right))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(xr#10, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#18, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(x, xr#10)), ==(*((xr#10->key)), old(_dryad_S2#18, *((xr#10->key))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(xr#10, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)) == $rd_inv(_dryad_S2#18, b_node.key, $phys_ptr_cast(xr#10, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(x, xr#10)), ==(*((xr#10->prio)), old(_dryad_S2#18, *((xr#10->prio))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(xr#10, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node)) == $rd_inv(_dryad_S2#18, b_node.prio, $phys_ptr_cast(xr#10, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(x, xl#9)), @_vcc_ptr_eq_pure(*((xl#9->left)), old(_dryad_S2#18, *((xl#9->left))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(xl#9, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#18, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(x, xl#9)), @_vcc_ptr_eq_pure(*((xl#9->right)), old(_dryad_S2#18, *((xl#9->right))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(xl#9, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#18, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(x, xl#9)), ==(*((xl#9->key)), old(_dryad_S2#18, *((xl#9->key))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(xl#9, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)) == $rd_inv(_dryad_S2#18, b_node.key, $phys_ptr_cast(xl#9, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(x, xl#9)), ==(*((xl#9->prio)), old(_dryad_S2#18, *((xl#9->prio))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(xl#9, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node)) == $rd_inv(_dryad_S2#18, b_node.prio, $phys_ptr_cast(xl#9, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(x, tmp#8)), @_vcc_ptr_eq_pure(*((tmp#8->left)), old(_dryad_S2#18, *((tmp#8->left))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(tmp#8, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#18, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(x, tmp#8)), @_vcc_ptr_eq_pure(*((tmp#8->right)), old(_dryad_S2#18, *((tmp#8->right))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(tmp#8, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S2#18, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(x, tmp#8)), ==(*((tmp#8->key)), old(_dryad_S2#18, *((tmp#8->key))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(tmp#8, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)) == $rd_inv(_dryad_S2#18, b_node.key, $phys_ptr_cast(tmp#8, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(x, tmp#8)), ==(*((tmp#8->prio)), old(_dryad_S2#18, *((tmp#8->prio))))); 
                assume !($phys_ptr_cast(P#x, ^b_node) == $phys_ptr_cast(tmp#8, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node)) == $rd_inv(_dryad_S2#18, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node));
                // assume ==>(@_vcc_ptr_neq_null(tmp2#17), ==(treap(tmp2#17), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((tmp2#17->left))), treap(*((tmp2#17->right)))), unchecked!(@_vcc_oset_in(tmp2#17, @_vcc_oset_union(treap_reach(*((tmp2#17->left))), treap_reach(*((tmp2#17->right))))))), unchecked!(@_vcc_intset_in(*((tmp2#17->key)), @_vcc_intset_union(treap_keys(*((tmp2#17->left))), treap_keys(*((tmp2#17->right))))))), unchecked!(@_vcc_intset_in(*((tmp2#17->prio)), @_vcc_intset_union(treap_prios(*((tmp2#17->left))), treap_prios(*((tmp2#17->right))))))), @_vcc_oset_disjoint(treap_reach(*((tmp2#17->left))), treap_reach(*((tmp2#17->right))))), @_vcc_intset_disjoint(treap_keys(*((tmp2#17->left))), treap_keys(*((tmp2#17->right))))), @_vcc_intset_disjoint(treap_prios(*((tmp2#17->left))), treap_prios(*((tmp2#17->right))))), ==>(@_vcc_ptr_neq_null(*((tmp2#17->left))), <(treap_max_key(*((tmp2#17->left))), *((tmp2#17->key))))), ==>(@_vcc_ptr_neq_null(*((tmp2#17->right))), <(*((tmp2#17->key)), treap_min_key(*((tmp2#17->right)))))), ==>(@_vcc_ptr_neq_null(*((tmp2#17->left))), <(treap_max_prio(*((tmp2#17->left))), *((tmp2#17->prio))))), ==>(@_vcc_ptr_neq_null(*((tmp2#17->right))), <(treap_max_prio(*((tmp2#17->right))), *((tmp2#17->prio))))))); 
                assume $non_null($phys_ptr_cast(tmp2#17, ^b_node)) ==> F#treap($s, $phys_ptr_cast(tmp2#17, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(tmp2#17, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(tmp2#17, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp2#17, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(tmp2#17, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(tmp2#17, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(tmp2#17, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(tmp2#17, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp2#17), ==(treap_reach(tmp2#17), @_vcc_oset_union(@_vcc_oset_singleton(tmp2#17), @_vcc_oset_union(treap_reach(*((tmp2#17->left))), treap_reach(*((tmp2#17->right))))))); 
                assume $non_null($phys_ptr_cast(tmp2#17, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(tmp2#17, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(tmp2#17, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp2#17), ==(treap_keys(tmp2#17), @_vcc_intset_union(@_vcc_intset_singleton(*((tmp2#17->key))), @_vcc_intset_union(treap_keys(*((tmp2#17->left))), treap_keys(*((tmp2#17->right))))))); 
                assume $non_null($phys_ptr_cast(tmp2#17, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(tmp2#17, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(tmp2#17, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp2#17), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp2#17->left))), @_vcc_ptr_neq_null(*((tmp2#17->right)))), ==(treap_max_key(tmp2#17), @\int_max(*((tmp2#17->key)), @\int_max(treap_max_key(*((tmp2#17->left))), treap_max_key(*((tmp2#17->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp2#17->left))), @_vcc_ptr_eq_null(*((tmp2#17->right)))), ==(treap_max_key(tmp2#17), @\int_max(*((tmp2#17->key)), treap_max_key(*((tmp2#17->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp2#17->left))), @_vcc_ptr_neq_null(*((tmp2#17->right)))), ==(treap_max_key(tmp2#17), @\int_max(*((tmp2#17->key)), treap_max_key(*((tmp2#17->right)))))))); 
                assume $non_null($phys_ptr_cast(tmp2#17, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(tmp2#17, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(tmp2#17, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(tmp2#17, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(tmp2#17, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(tmp2#17, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(tmp2#17, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp2#17), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp2#17->left))), @_vcc_ptr_neq_null(*((tmp2#17->right)))), ==(treap_max_prio(tmp2#17), @\int_max(*((tmp2#17->prio)), @\int_max(treap_max_prio(*((tmp2#17->left))), treap_max_prio(*((tmp2#17->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp2#17->left))), @_vcc_ptr_eq_null(*((tmp2#17->right)))), ==(treap_max_prio(tmp2#17), @\int_max(*((tmp2#17->prio)), treap_max_prio(*((tmp2#17->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp2#17->left))), @_vcc_ptr_neq_null(*((tmp2#17->right)))), ==(treap_max_prio(tmp2#17), @\int_max(*((tmp2#17->prio)), treap_max_prio(*((tmp2#17->right)))))))); 
                assume $non_null($phys_ptr_cast(tmp2#17, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(tmp2#17, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp2#17, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(tmp2#17, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp2#17, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(tmp2#17, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp2#17, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp2#17), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp2#17->left))), @_vcc_ptr_neq_null(*((tmp2#17->right)))), ==(treap_min_key(tmp2#17), @\int_min(*((tmp2#17->key)), @\int_min(treap_min_key(*((tmp2#17->left))), treap_min_key(*((tmp2#17->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp2#17->left))), @_vcc_ptr_eq_null(*((tmp2#17->right)))), ==(treap_min_key(tmp2#17), @\int_min(*((tmp2#17->key)), treap_min_key(*((tmp2#17->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp2#17->left))), @_vcc_ptr_neq_null(*((tmp2#17->right)))), ==(treap_min_key(tmp2#17), @\int_min(*((tmp2#17->key)), treap_min_key(*((tmp2#17->right)))))))); 
                assume $non_null($phys_ptr_cast(tmp2#17, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(tmp2#17, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(tmp2#17, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(tmp2#17, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(tmp2#17, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(tmp2#17, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(tmp2#17, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp2#17), ==(treap_prios(tmp2#17), @_vcc_intset_union(@_vcc_intset_singleton(*((tmp2#17->prio))), @_vcc_intset_union(treap_prios(*((tmp2#17->left))), treap_prios(*((tmp2#17->right))))))); 
                assume $non_null($phys_ptr_cast(tmp2#17, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(tmp2#17, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp2#17, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(rl), ==(treap(rl), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((rl->left))), treap(*((rl->right)))), unchecked!(@_vcc_oset_in(rl, @_vcc_oset_union(treap_reach(*((rl->left))), treap_reach(*((rl->right))))))), unchecked!(@_vcc_intset_in(*((rl->key)), @_vcc_intset_union(treap_keys(*((rl->left))), treap_keys(*((rl->right))))))), unchecked!(@_vcc_intset_in(*((rl->prio)), @_vcc_intset_union(treap_prios(*((rl->left))), treap_prios(*((rl->right))))))), @_vcc_oset_disjoint(treap_reach(*((rl->left))), treap_reach(*((rl->right))))), @_vcc_intset_disjoint(treap_keys(*((rl->left))), treap_keys(*((rl->right))))), @_vcc_intset_disjoint(treap_prios(*((rl->left))), treap_prios(*((rl->right))))), ==>(@_vcc_ptr_neq_null(*((rl->left))), <(treap_max_key(*((rl->left))), *((rl->key))))), ==>(@_vcc_ptr_neq_null(*((rl->right))), <(*((rl->key)), treap_min_key(*((rl->right)))))), ==>(@_vcc_ptr_neq_null(*((rl->left))), <(treap_max_prio(*((rl->left))), *((rl->prio))))), ==>(@_vcc_ptr_neq_null(*((rl->right))), <(treap_max_prio(*((rl->right))), *((rl->prio))))))); 
                assume $non_null($phys_ptr_cast(L#rl, ^b_node)) ==> F#treap($s, $phys_ptr_cast(L#rl, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(L#rl, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(L#rl, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(L#rl, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(L#rl, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#rl, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#rl, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#rl, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(rl), ==(treap_reach(rl), @_vcc_oset_union(@_vcc_oset_singleton(rl), @_vcc_oset_union(treap_reach(*((rl->left))), treap_reach(*((rl->right))))))); 
                assume $non_null($phys_ptr_cast(L#rl, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(L#rl, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(L#rl, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(rl), ==(treap_keys(rl), @_vcc_intset_union(@_vcc_intset_singleton(*((rl->key))), @_vcc_intset_union(treap_keys(*((rl->left))), treap_keys(*((rl->right))))))); 
                assume $non_null($phys_ptr_cast(L#rl, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(L#rl, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(L#rl, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(rl), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((rl->left))), @_vcc_ptr_neq_null(*((rl->right)))), ==(treap_max_key(rl), @\int_max(*((rl->key)), @\int_max(treap_max_key(*((rl->left))), treap_max_key(*((rl->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((rl->left))), @_vcc_ptr_eq_null(*((rl->right)))), ==(treap_max_key(rl), @\int_max(*((rl->key)), treap_max_key(*((rl->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((rl->left))), @_vcc_ptr_neq_null(*((rl->right)))), ==(treap_max_key(rl), @\int_max(*((rl->key)), treap_max_key(*((rl->right)))))))); 
                assume $non_null($phys_ptr_cast(L#rl, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#rl, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#rl, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#rl, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#rl, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#rl, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#rl, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(rl), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((rl->left))), @_vcc_ptr_neq_null(*((rl->right)))), ==(treap_max_prio(rl), @\int_max(*((rl->prio)), @\int_max(treap_max_prio(*((rl->left))), treap_max_prio(*((rl->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((rl->left))), @_vcc_ptr_eq_null(*((rl->right)))), ==(treap_max_prio(rl), @\int_max(*((rl->prio)), treap_max_prio(*((rl->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((rl->left))), @_vcc_ptr_neq_null(*((rl->right)))), ==(treap_max_prio(rl), @\int_max(*((rl->prio)), treap_max_prio(*((rl->right)))))))); 
                assume $non_null($phys_ptr_cast(L#rl, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#rl, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#rl, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#rl, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#rl, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#rl, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#rl, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(rl), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((rl->left))), @_vcc_ptr_neq_null(*((rl->right)))), ==(treap_min_key(rl), @\int_min(*((rl->key)), @\int_min(treap_min_key(*((rl->left))), treap_min_key(*((rl->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((rl->left))), @_vcc_ptr_eq_null(*((rl->right)))), ==(treap_min_key(rl), @\int_min(*((rl->key)), treap_min_key(*((rl->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((rl->left))), @_vcc_ptr_neq_null(*((rl->right)))), ==(treap_min_key(rl), @\int_min(*((rl->key)), treap_min_key(*((rl->right)))))))); 
                assume $non_null($phys_ptr_cast(L#rl, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#rl, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#rl, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#rl, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#rl, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#rl, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#rl, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(rl), ==(treap_prios(rl), @_vcc_intset_union(@_vcc_intset_singleton(*((rl->prio))), @_vcc_intset_union(treap_prios(*((rl->left))), treap_prios(*((rl->right))))))); 
                assume $non_null($phys_ptr_cast(L#rl, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(L#rl, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(L#rl, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1#12), ==(treap(x1#12), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x1#12->left))), treap(*((x1#12->right)))), unchecked!(@_vcc_oset_in(x1#12, @_vcc_oset_union(treap_reach(*((x1#12->left))), treap_reach(*((x1#12->right))))))), unchecked!(@_vcc_intset_in(*((x1#12->key)), @_vcc_intset_union(treap_keys(*((x1#12->left))), treap_keys(*((x1#12->right))))))), unchecked!(@_vcc_intset_in(*((x1#12->prio)), @_vcc_intset_union(treap_prios(*((x1#12->left))), treap_prios(*((x1#12->right))))))), @_vcc_oset_disjoint(treap_reach(*((x1#12->left))), treap_reach(*((x1#12->right))))), @_vcc_intset_disjoint(treap_keys(*((x1#12->left))), treap_keys(*((x1#12->right))))), @_vcc_intset_disjoint(treap_prios(*((x1#12->left))), treap_prios(*((x1#12->right))))), ==>(@_vcc_ptr_neq_null(*((x1#12->left))), <(treap_max_key(*((x1#12->left))), *((x1#12->key))))), ==>(@_vcc_ptr_neq_null(*((x1#12->right))), <(*((x1#12->key)), treap_min_key(*((x1#12->right)))))), ==>(@_vcc_ptr_neq_null(*((x1#12->left))), <(treap_max_prio(*((x1#12->left))), *((x1#12->prio))))), ==>(@_vcc_ptr_neq_null(*((x1#12->right))), <(treap_max_prio(*((x1#12->right))), *((x1#12->prio))))))); 
                assume $non_null($phys_ptr_cast(x1#12, ^b_node)) ==> F#treap($s, $phys_ptr_cast(x1#12, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(x1#12, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(x1#12, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(x1#12, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(x1#12, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1#12), ==(treap_reach(x1#12), @_vcc_oset_union(@_vcc_oset_singleton(x1#12), @_vcc_oset_union(treap_reach(*((x1#12->left))), treap_reach(*((x1#12->right))))))); 
                assume $non_null($phys_ptr_cast(x1#12, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(x1#12, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(x1#12, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1#12), ==(treap_keys(x1#12), @_vcc_intset_union(@_vcc_intset_singleton(*((x1#12->key))), @_vcc_intset_union(treap_keys(*((x1#12->left))), treap_keys(*((x1#12->right))))))); 
                assume $non_null($phys_ptr_cast(x1#12, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(x1#12, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1#12), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x1#12->left))), @_vcc_ptr_neq_null(*((x1#12->right)))), ==(treap_max_key(x1#12), @\int_max(*((x1#12->key)), @\int_max(treap_max_key(*((x1#12->left))), treap_max_key(*((x1#12->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x1#12->left))), @_vcc_ptr_eq_null(*((x1#12->right)))), ==(treap_max_key(x1#12), @\int_max(*((x1#12->key)), treap_max_key(*((x1#12->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x1#12->left))), @_vcc_ptr_neq_null(*((x1#12->right)))), ==(treap_max_key(x1#12), @\int_max(*((x1#12->key)), treap_max_key(*((x1#12->right)))))))); 
                assume $non_null($phys_ptr_cast(x1#12, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1#12), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x1#12->left))), @_vcc_ptr_neq_null(*((x1#12->right)))), ==(treap_max_prio(x1#12), @\int_max(*((x1#12->prio)), @\int_max(treap_max_prio(*((x1#12->left))), treap_max_prio(*((x1#12->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x1#12->left))), @_vcc_ptr_eq_null(*((x1#12->right)))), ==(treap_max_prio(x1#12), @\int_max(*((x1#12->prio)), treap_max_prio(*((x1#12->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x1#12->left))), @_vcc_ptr_neq_null(*((x1#12->right)))), ==(treap_max_prio(x1#12), @\int_max(*((x1#12->prio)), treap_max_prio(*((x1#12->right)))))))); 
                assume $non_null($phys_ptr_cast(x1#12, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(x1#12, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(x1#12, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(x1#12, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1#12), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x1#12->left))), @_vcc_ptr_neq_null(*((x1#12->right)))), ==(treap_min_key(x1#12), @\int_min(*((x1#12->key)), @\int_min(treap_min_key(*((x1#12->left))), treap_min_key(*((x1#12->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x1#12->left))), @_vcc_ptr_eq_null(*((x1#12->right)))), ==(treap_min_key(x1#12), @\int_min(*((x1#12->key)), treap_min_key(*((x1#12->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x1#12->left))), @_vcc_ptr_neq_null(*((x1#12->right)))), ==(treap_min_key(x1#12), @\int_min(*((x1#12->key)), treap_min_key(*((x1#12->right)))))))); 
                assume $non_null($phys_ptr_cast(x1#12, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1#12), ==(treap_prios(x1#12), @_vcc_intset_union(@_vcc_intset_singleton(*((x1#12->prio))), @_vcc_intset_union(treap_prios(*((x1#12->left))), treap_prios(*((x1#12->right))))))); 
                assume $non_null($phys_ptr_cast(x1#12, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(x1#12, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(x1#12, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0#11), ==(treap(x0#11), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x0#11->left))), treap(*((x0#11->right)))), unchecked!(@_vcc_oset_in(x0#11, @_vcc_oset_union(treap_reach(*((x0#11->left))), treap_reach(*((x0#11->right))))))), unchecked!(@_vcc_intset_in(*((x0#11->key)), @_vcc_intset_union(treap_keys(*((x0#11->left))), treap_keys(*((x0#11->right))))))), unchecked!(@_vcc_intset_in(*((x0#11->prio)), @_vcc_intset_union(treap_prios(*((x0#11->left))), treap_prios(*((x0#11->right))))))), @_vcc_oset_disjoint(treap_reach(*((x0#11->left))), treap_reach(*((x0#11->right))))), @_vcc_intset_disjoint(treap_keys(*((x0#11->left))), treap_keys(*((x0#11->right))))), @_vcc_intset_disjoint(treap_prios(*((x0#11->left))), treap_prios(*((x0#11->right))))), ==>(@_vcc_ptr_neq_null(*((x0#11->left))), <(treap_max_key(*((x0#11->left))), *((x0#11->key))))), ==>(@_vcc_ptr_neq_null(*((x0#11->right))), <(*((x0#11->key)), treap_min_key(*((x0#11->right)))))), ==>(@_vcc_ptr_neq_null(*((x0#11->left))), <(treap_max_prio(*((x0#11->left))), *((x0#11->prio))))), ==>(@_vcc_ptr_neq_null(*((x0#11->right))), <(treap_max_prio(*((x0#11->right))), *((x0#11->prio))))))); 
                assume $non_null($phys_ptr_cast(x0#11, ^b_node)) ==> F#treap($s, $phys_ptr_cast(x0#11, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(x0#11, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(x0#11, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(x0#11, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(x0#11, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0#11), ==(treap_reach(x0#11), @_vcc_oset_union(@_vcc_oset_singleton(x0#11), @_vcc_oset_union(treap_reach(*((x0#11->left))), treap_reach(*((x0#11->right))))))); 
                assume $non_null($phys_ptr_cast(x0#11, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(x0#11, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(x0#11, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0#11), ==(treap_keys(x0#11), @_vcc_intset_union(@_vcc_intset_singleton(*((x0#11->key))), @_vcc_intset_union(treap_keys(*((x0#11->left))), treap_keys(*((x0#11->right))))))); 
                assume $non_null($phys_ptr_cast(x0#11, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(x0#11, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0#11), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x0#11->left))), @_vcc_ptr_neq_null(*((x0#11->right)))), ==(treap_max_key(x0#11), @\int_max(*((x0#11->key)), @\int_max(treap_max_key(*((x0#11->left))), treap_max_key(*((x0#11->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x0#11->left))), @_vcc_ptr_eq_null(*((x0#11->right)))), ==(treap_max_key(x0#11), @\int_max(*((x0#11->key)), treap_max_key(*((x0#11->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x0#11->left))), @_vcc_ptr_neq_null(*((x0#11->right)))), ==(treap_max_key(x0#11), @\int_max(*((x0#11->key)), treap_max_key(*((x0#11->right)))))))); 
                assume $non_null($phys_ptr_cast(x0#11, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0#11), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x0#11->left))), @_vcc_ptr_neq_null(*((x0#11->right)))), ==(treap_max_prio(x0#11), @\int_max(*((x0#11->prio)), @\int_max(treap_max_prio(*((x0#11->left))), treap_max_prio(*((x0#11->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x0#11->left))), @_vcc_ptr_eq_null(*((x0#11->right)))), ==(treap_max_prio(x0#11), @\int_max(*((x0#11->prio)), treap_max_prio(*((x0#11->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x0#11->left))), @_vcc_ptr_neq_null(*((x0#11->right)))), ==(treap_max_prio(x0#11), @\int_max(*((x0#11->prio)), treap_max_prio(*((x0#11->right)))))))); 
                assume $non_null($phys_ptr_cast(x0#11, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(x0#11, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(x0#11, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(x0#11, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0#11), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x0#11->left))), @_vcc_ptr_neq_null(*((x0#11->right)))), ==(treap_min_key(x0#11), @\int_min(*((x0#11->key)), @\int_min(treap_min_key(*((x0#11->left))), treap_min_key(*((x0#11->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x0#11->left))), @_vcc_ptr_eq_null(*((x0#11->right)))), ==(treap_min_key(x0#11), @\int_min(*((x0#11->key)), treap_min_key(*((x0#11->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x0#11->left))), @_vcc_ptr_neq_null(*((x0#11->right)))), ==(treap_min_key(x0#11), @\int_min(*((x0#11->key)), treap_min_key(*((x0#11->right)))))))); 
                assume $non_null($phys_ptr_cast(x0#11, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0#11), ==(treap_prios(x0#11), @_vcc_intset_union(@_vcc_intset_singleton(*((x0#11->prio))), @_vcc_intset_union(treap_prios(*((x0#11->left))), treap_prios(*((x0#11->right))))))); 
                assume $non_null($phys_ptr_cast(x0#11, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(x0#11, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(x0#11, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr#10), ==(treap(xr#10), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((xr#10->left))), treap(*((xr#10->right)))), unchecked!(@_vcc_oset_in(xr#10, @_vcc_oset_union(treap_reach(*((xr#10->left))), treap_reach(*((xr#10->right))))))), unchecked!(@_vcc_intset_in(*((xr#10->key)), @_vcc_intset_union(treap_keys(*((xr#10->left))), treap_keys(*((xr#10->right))))))), unchecked!(@_vcc_intset_in(*((xr#10->prio)), @_vcc_intset_union(treap_prios(*((xr#10->left))), treap_prios(*((xr#10->right))))))), @_vcc_oset_disjoint(treap_reach(*((xr#10->left))), treap_reach(*((xr#10->right))))), @_vcc_intset_disjoint(treap_keys(*((xr#10->left))), treap_keys(*((xr#10->right))))), @_vcc_intset_disjoint(treap_prios(*((xr#10->left))), treap_prios(*((xr#10->right))))), ==>(@_vcc_ptr_neq_null(*((xr#10->left))), <(treap_max_key(*((xr#10->left))), *((xr#10->key))))), ==>(@_vcc_ptr_neq_null(*((xr#10->right))), <(*((xr#10->key)), treap_min_key(*((xr#10->right)))))), ==>(@_vcc_ptr_neq_null(*((xr#10->left))), <(treap_max_prio(*((xr#10->left))), *((xr#10->prio))))), ==>(@_vcc_ptr_neq_null(*((xr#10->right))), <(treap_max_prio(*((xr#10->right))), *((xr#10->prio))))))); 
                assume $non_null($phys_ptr_cast(xr#10, ^b_node)) ==> F#treap($s, $phys_ptr_cast(xr#10, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(xr#10, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr#10), ==(treap_reach(xr#10), @_vcc_oset_union(@_vcc_oset_singleton(xr#10), @_vcc_oset_union(treap_reach(*((xr#10->left))), treap_reach(*((xr#10->right))))))); 
                assume $non_null($phys_ptr_cast(xr#10, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(xr#10, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(xr#10, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr#10), ==(treap_keys(xr#10), @_vcc_intset_union(@_vcc_intset_singleton(*((xr#10->key))), @_vcc_intset_union(treap_keys(*((xr#10->left))), treap_keys(*((xr#10->right))))))); 
                assume $non_null($phys_ptr_cast(xr#10, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(xr#10, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr#10), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr#10->left))), @_vcc_ptr_neq_null(*((xr#10->right)))), ==(treap_max_key(xr#10), @\int_max(*((xr#10->key)), @\int_max(treap_max_key(*((xr#10->left))), treap_max_key(*((xr#10->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr#10->left))), @_vcc_ptr_eq_null(*((xr#10->right)))), ==(treap_max_key(xr#10), @\int_max(*((xr#10->key)), treap_max_key(*((xr#10->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr#10->left))), @_vcc_ptr_neq_null(*((xr#10->right)))), ==(treap_max_key(xr#10), @\int_max(*((xr#10->key)), treap_max_key(*((xr#10->right)))))))); 
                assume $non_null($phys_ptr_cast(xr#10, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr#10), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr#10->left))), @_vcc_ptr_neq_null(*((xr#10->right)))), ==(treap_max_prio(xr#10), @\int_max(*((xr#10->prio)), @\int_max(treap_max_prio(*((xr#10->left))), treap_max_prio(*((xr#10->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr#10->left))), @_vcc_ptr_eq_null(*((xr#10->right)))), ==(treap_max_prio(xr#10), @\int_max(*((xr#10->prio)), treap_max_prio(*((xr#10->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr#10->left))), @_vcc_ptr_neq_null(*((xr#10->right)))), ==(treap_max_prio(xr#10), @\int_max(*((xr#10->prio)), treap_max_prio(*((xr#10->right)))))))); 
                assume $non_null($phys_ptr_cast(xr#10, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr#10), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr#10->left))), @_vcc_ptr_neq_null(*((xr#10->right)))), ==(treap_min_key(xr#10), @\int_min(*((xr#10->key)), @\int_min(treap_min_key(*((xr#10->left))), treap_min_key(*((xr#10->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr#10->left))), @_vcc_ptr_eq_null(*((xr#10->right)))), ==(treap_min_key(xr#10), @\int_min(*((xr#10->key)), treap_min_key(*((xr#10->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr#10->left))), @_vcc_ptr_neq_null(*((xr#10->right)))), ==(treap_min_key(xr#10), @\int_min(*((xr#10->key)), treap_min_key(*((xr#10->right)))))))); 
                assume $non_null($phys_ptr_cast(xr#10, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr#10), ==(treap_prios(xr#10), @_vcc_intset_union(@_vcc_intset_singleton(*((xr#10->prio))), @_vcc_intset_union(treap_prios(*((xr#10->left))), treap_prios(*((xr#10->right))))))); 
                assume $non_null($phys_ptr_cast(xr#10, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(xr#10, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl#9), ==(treap(xl#9), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((xl#9->left))), treap(*((xl#9->right)))), unchecked!(@_vcc_oset_in(xl#9, @_vcc_oset_union(treap_reach(*((xl#9->left))), treap_reach(*((xl#9->right))))))), unchecked!(@_vcc_intset_in(*((xl#9->key)), @_vcc_intset_union(treap_keys(*((xl#9->left))), treap_keys(*((xl#9->right))))))), unchecked!(@_vcc_intset_in(*((xl#9->prio)), @_vcc_intset_union(treap_prios(*((xl#9->left))), treap_prios(*((xl#9->right))))))), @_vcc_oset_disjoint(treap_reach(*((xl#9->left))), treap_reach(*((xl#9->right))))), @_vcc_intset_disjoint(treap_keys(*((xl#9->left))), treap_keys(*((xl#9->right))))), @_vcc_intset_disjoint(treap_prios(*((xl#9->left))), treap_prios(*((xl#9->right))))), ==>(@_vcc_ptr_neq_null(*((xl#9->left))), <(treap_max_key(*((xl#9->left))), *((xl#9->key))))), ==>(@_vcc_ptr_neq_null(*((xl#9->right))), <(*((xl#9->key)), treap_min_key(*((xl#9->right)))))), ==>(@_vcc_ptr_neq_null(*((xl#9->left))), <(treap_max_prio(*((xl#9->left))), *((xl#9->prio))))), ==>(@_vcc_ptr_neq_null(*((xl#9->right))), <(treap_max_prio(*((xl#9->right))), *((xl#9->prio))))))); 
                assume $non_null($phys_ptr_cast(xl#9, ^b_node)) ==> F#treap($s, $phys_ptr_cast(xl#9, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(xl#9, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl#9), ==(treap_reach(xl#9), @_vcc_oset_union(@_vcc_oset_singleton(xl#9), @_vcc_oset_union(treap_reach(*((xl#9->left))), treap_reach(*((xl#9->right))))))); 
                assume $non_null($phys_ptr_cast(xl#9, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(xl#9, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(xl#9, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl#9), ==(treap_keys(xl#9), @_vcc_intset_union(@_vcc_intset_singleton(*((xl#9->key))), @_vcc_intset_union(treap_keys(*((xl#9->left))), treap_keys(*((xl#9->right))))))); 
                assume $non_null($phys_ptr_cast(xl#9, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(xl#9, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl#9), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl#9->left))), @_vcc_ptr_neq_null(*((xl#9->right)))), ==(treap_max_key(xl#9), @\int_max(*((xl#9->key)), @\int_max(treap_max_key(*((xl#9->left))), treap_max_key(*((xl#9->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl#9->left))), @_vcc_ptr_eq_null(*((xl#9->right)))), ==(treap_max_key(xl#9), @\int_max(*((xl#9->key)), treap_max_key(*((xl#9->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl#9->left))), @_vcc_ptr_neq_null(*((xl#9->right)))), ==(treap_max_key(xl#9), @\int_max(*((xl#9->key)), treap_max_key(*((xl#9->right)))))))); 
                assume $non_null($phys_ptr_cast(xl#9, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl#9), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl#9->left))), @_vcc_ptr_neq_null(*((xl#9->right)))), ==(treap_max_prio(xl#9), @\int_max(*((xl#9->prio)), @\int_max(treap_max_prio(*((xl#9->left))), treap_max_prio(*((xl#9->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl#9->left))), @_vcc_ptr_eq_null(*((xl#9->right)))), ==(treap_max_prio(xl#9), @\int_max(*((xl#9->prio)), treap_max_prio(*((xl#9->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl#9->left))), @_vcc_ptr_neq_null(*((xl#9->right)))), ==(treap_max_prio(xl#9), @\int_max(*((xl#9->prio)), treap_max_prio(*((xl#9->right)))))))); 
                assume $non_null($phys_ptr_cast(xl#9, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl#9), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl#9->left))), @_vcc_ptr_neq_null(*((xl#9->right)))), ==(treap_min_key(xl#9), @\int_min(*((xl#9->key)), @\int_min(treap_min_key(*((xl#9->left))), treap_min_key(*((xl#9->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl#9->left))), @_vcc_ptr_eq_null(*((xl#9->right)))), ==(treap_min_key(xl#9), @\int_min(*((xl#9->key)), treap_min_key(*((xl#9->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl#9->left))), @_vcc_ptr_neq_null(*((xl#9->right)))), ==(treap_min_key(xl#9), @\int_min(*((xl#9->key)), treap_min_key(*((xl#9->right)))))))); 
                assume $non_null($phys_ptr_cast(xl#9, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl#9), ==(treap_prios(xl#9), @_vcc_intset_union(@_vcc_intset_singleton(*((xl#9->prio))), @_vcc_intset_union(treap_prios(*((xl#9->left))), treap_prios(*((xl#9->right))))))); 
                assume $non_null($phys_ptr_cast(xl#9, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(xl#9, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), ==(treap(tmp#8), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((tmp#8->left))), treap(*((tmp#8->right)))), unchecked!(@_vcc_oset_in(tmp#8, @_vcc_oset_union(treap_reach(*((tmp#8->left))), treap_reach(*((tmp#8->right))))))), unchecked!(@_vcc_intset_in(*((tmp#8->key)), @_vcc_intset_union(treap_keys(*((tmp#8->left))), treap_keys(*((tmp#8->right))))))), unchecked!(@_vcc_intset_in(*((tmp#8->prio)), @_vcc_intset_union(treap_prios(*((tmp#8->left))), treap_prios(*((tmp#8->right))))))), @_vcc_oset_disjoint(treap_reach(*((tmp#8->left))), treap_reach(*((tmp#8->right))))), @_vcc_intset_disjoint(treap_keys(*((tmp#8->left))), treap_keys(*((tmp#8->right))))), @_vcc_intset_disjoint(treap_prios(*((tmp#8->left))), treap_prios(*((tmp#8->right))))), ==>(@_vcc_ptr_neq_null(*((tmp#8->left))), <(treap_max_key(*((tmp#8->left))), *((tmp#8->key))))), ==>(@_vcc_ptr_neq_null(*((tmp#8->right))), <(*((tmp#8->key)), treap_min_key(*((tmp#8->right)))))), ==>(@_vcc_ptr_neq_null(*((tmp#8->left))), <(treap_max_prio(*((tmp#8->left))), *((tmp#8->prio))))), ==>(@_vcc_ptr_neq_null(*((tmp#8->right))), <(treap_max_prio(*((tmp#8->right))), *((tmp#8->prio))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> F#treap($s, $phys_ptr_cast(tmp#8, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(tmp#8, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), ==(treap_reach(tmp#8), @_vcc_oset_union(@_vcc_oset_singleton(tmp#8), @_vcc_oset_union(treap_reach(*((tmp#8->left))), treap_reach(*((tmp#8->right))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(tmp#8, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(tmp#8, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), ==(treap_keys(tmp#8), @_vcc_intset_union(@_vcc_intset_singleton(*((tmp#8->key))), @_vcc_intset_union(treap_keys(*((tmp#8->left))), treap_keys(*((tmp#8->right))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(tmp#8, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_max_key(tmp#8), @\int_max(*((tmp#8->key)), @\int_max(treap_max_key(*((tmp#8->left))), treap_max_key(*((tmp#8->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_eq_null(*((tmp#8->right)))), ==(treap_max_key(tmp#8), @\int_max(*((tmp#8->key)), treap_max_key(*((tmp#8->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_max_key(tmp#8), @\int_max(*((tmp#8->key)), treap_max_key(*((tmp#8->right)))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_max_prio(tmp#8), @\int_max(*((tmp#8->prio)), @\int_max(treap_max_prio(*((tmp#8->left))), treap_max_prio(*((tmp#8->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_eq_null(*((tmp#8->right)))), ==(treap_max_prio(tmp#8), @\int_max(*((tmp#8->prio)), treap_max_prio(*((tmp#8->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_max_prio(tmp#8), @\int_max(*((tmp#8->prio)), treap_max_prio(*((tmp#8->right)))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_min_key(tmp#8), @\int_min(*((tmp#8->key)), @\int_min(treap_min_key(*((tmp#8->left))), treap_min_key(*((tmp#8->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_eq_null(*((tmp#8->right)))), ==(treap_min_key(tmp#8), @\int_min(*((tmp#8->key)), treap_min_key(*((tmp#8->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_min_key(tmp#8), @\int_min(*((tmp#8->key)), treap_min_key(*((tmp#8->right)))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), ==(treap_prios(tmp#8), @_vcc_intset_union(@_vcc_intset_singleton(*((tmp#8->prio))), @_vcc_intset_union(treap_prios(*((tmp#8->left))), treap_prios(*((tmp#8->right))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(tmp#8, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), ==(treap(x), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x->left))), treap(*((x->right)))), unchecked!(@_vcc_oset_in(x, @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->key)), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->prio)), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))), @_vcc_oset_disjoint(treap_reach(*((x->left))), treap_reach(*((x->right))))), @_vcc_intset_disjoint(treap_keys(*((x->left))), treap_keys(*((x->right))))), @_vcc_intset_disjoint(treap_prios(*((x->left))), treap_prios(*((x->right))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_key(*((x->left))), *((x->key))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(*((x->key)), treap_min_key(*((x->right)))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_prio(*((x->left))), *((x->prio))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(treap_max_prio(*((x->right))), *((x->prio))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap($s, $phys_ptr_cast(P#x, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(P#x, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_reach(x), @_vcc_oset_union(@_vcc_oset_singleton(x), @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(P#x, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(P#x, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_keys(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->key))), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), @\int_max(treap_max_key(*((x->left))), treap_max_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->right)))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), @\int_max(treap_max_prio(*((x->left))), treap_max_prio(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->right)))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), @\int_min(treap_min_key(*((x->left))), treap_min_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->right)))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_prios(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->prio))), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(rl), ==(treap(rl), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((rl->left))), treap(*((rl->right)))), unchecked!(@_vcc_oset_in(rl, @_vcc_oset_union(treap_reach(*((rl->left))), treap_reach(*((rl->right))))))), unchecked!(@_vcc_intset_in(*((rl->key)), @_vcc_intset_union(treap_keys(*((rl->left))), treap_keys(*((rl->right))))))), unchecked!(@_vcc_intset_in(*((rl->prio)), @_vcc_intset_union(treap_prios(*((rl->left))), treap_prios(*((rl->right))))))), @_vcc_oset_disjoint(treap_reach(*((rl->left))), treap_reach(*((rl->right))))), @_vcc_intset_disjoint(treap_keys(*((rl->left))), treap_keys(*((rl->right))))), @_vcc_intset_disjoint(treap_prios(*((rl->left))), treap_prios(*((rl->right))))), ==>(@_vcc_ptr_neq_null(*((rl->left))), <(treap_max_key(*((rl->left))), *((rl->key))))), ==>(@_vcc_ptr_neq_null(*((rl->right))), <(*((rl->key)), treap_min_key(*((rl->right)))))), ==>(@_vcc_ptr_neq_null(*((rl->left))), <(treap_max_prio(*((rl->left))), *((rl->prio))))), ==>(@_vcc_ptr_neq_null(*((rl->right))), <(treap_max_prio(*((rl->right))), *((rl->prio))))))); 
                assume $non_null($phys_ptr_cast(L#rl, ^b_node)) ==> F#treap($s, $phys_ptr_cast(L#rl, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(L#rl, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(L#rl, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(L#rl, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(L#rl, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#rl, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#rl, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#rl, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(rl), ==(treap_reach(rl), @_vcc_oset_union(@_vcc_oset_singleton(rl), @_vcc_oset_union(treap_reach(*((rl->left))), treap_reach(*((rl->right))))))); 
                assume $non_null($phys_ptr_cast(L#rl, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(L#rl, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(L#rl, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(rl), ==(treap_keys(rl), @_vcc_intset_union(@_vcc_intset_singleton(*((rl->key))), @_vcc_intset_union(treap_keys(*((rl->left))), treap_keys(*((rl->right))))))); 
                assume $non_null($phys_ptr_cast(L#rl, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(L#rl, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(L#rl, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(rl), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((rl->left))), @_vcc_ptr_neq_null(*((rl->right)))), ==(treap_max_key(rl), @\int_max(*((rl->key)), @\int_max(treap_max_key(*((rl->left))), treap_max_key(*((rl->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((rl->left))), @_vcc_ptr_eq_null(*((rl->right)))), ==(treap_max_key(rl), @\int_max(*((rl->key)), treap_max_key(*((rl->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((rl->left))), @_vcc_ptr_neq_null(*((rl->right)))), ==(treap_max_key(rl), @\int_max(*((rl->key)), treap_max_key(*((rl->right)))))))); 
                assume $non_null($phys_ptr_cast(L#rl, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#rl, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#rl, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#rl, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#rl, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#rl, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#rl, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(rl), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((rl->left))), @_vcc_ptr_neq_null(*((rl->right)))), ==(treap_max_prio(rl), @\int_max(*((rl->prio)), @\int_max(treap_max_prio(*((rl->left))), treap_max_prio(*((rl->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((rl->left))), @_vcc_ptr_eq_null(*((rl->right)))), ==(treap_max_prio(rl), @\int_max(*((rl->prio)), treap_max_prio(*((rl->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((rl->left))), @_vcc_ptr_neq_null(*((rl->right)))), ==(treap_max_prio(rl), @\int_max(*((rl->prio)), treap_max_prio(*((rl->right)))))))); 
                assume $non_null($phys_ptr_cast(L#rl, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#rl, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#rl, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#rl, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#rl, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#rl, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#rl, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(rl), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((rl->left))), @_vcc_ptr_neq_null(*((rl->right)))), ==(treap_min_key(rl), @\int_min(*((rl->key)), @\int_min(treap_min_key(*((rl->left))), treap_min_key(*((rl->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((rl->left))), @_vcc_ptr_eq_null(*((rl->right)))), ==(treap_min_key(rl), @\int_min(*((rl->key)), treap_min_key(*((rl->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((rl->left))), @_vcc_ptr_neq_null(*((rl->right)))), ==(treap_min_key(rl), @\int_min(*((rl->key)), treap_min_key(*((rl->right)))))))); 
                assume $non_null($phys_ptr_cast(L#rl, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#rl, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#rl, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#rl, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#rl, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#rl, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#rl, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(rl), ==(treap_prios(rl), @_vcc_intset_union(@_vcc_intset_singleton(*((rl->prio))), @_vcc_intset_union(treap_prios(*((rl->left))), treap_prios(*((rl->right))))))); 
                assume $non_null($phys_ptr_cast(L#rl, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(L#rl, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(L#rl, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))));
                // _math \state _dryad_S4#20; 
                // _dryad_S4#20 := @_vcc_current_state(@state); 
                _dryad_S4#20 := $current_state($s);
                // _math \state stmtexpr3#36; 
                // stmtexpr3#36 := _dryad_S4#20; 
                stmtexpr3#36 := _dryad_S4#20;
                // assert @prim_writes_check((tmp#8->left)); 
                assert $writable_prim($s, #wrTime$3^5.3, $dot($phys_ptr_cast(tmp#8, ^b_node), b_node.left));
                // *(tmp#8->left) := x; 
                call $write_int(b_node.left, $phys_ptr_cast(tmp#8, ^b_node), $ptr_to_int($phys_ptr_cast(P#x, ^b_node)));
                assume $full_stop_ext(#tok$3^82.9, $s);
                // _math \state _dryad_S5#21; 
                // _dryad_S5#21 := @_vcc_current_state(@state); 
                _dryad_S5#21 := $current_state($s);
                // _math \state stmtexpr4#37; 
                // stmtexpr4#37 := _dryad_S5#21; 
                stmtexpr4#37 := _dryad_S5#21;
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(*((tmp#8->right)))))), ==(old(_dryad_S4#20, treap(*((tmp#8->right)))), old(_dryad_S5#21, treap(*((tmp#8->right)))))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $rd_phys_ptr(_dryad_S4#20, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))) ==> F#treap(_dryad_S4#20, $rd_phys_ptr(_dryad_S4#20, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) == F#treap(_dryad_S5#21, $rd_phys_ptr(_dryad_S5#21, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(*((tmp#8->right)))))), ==(old(_dryad_S4#20, treap_reach(*((tmp#8->right)))), old(_dryad_S5#21, treap_reach(*((tmp#8->right)))))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $rd_phys_ptr(_dryad_S4#20, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))) ==> F#treap_reach(_dryad_S4#20, $rd_phys_ptr(_dryad_S4#20, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) == F#treap_reach(_dryad_S5#21, $rd_phys_ptr(_dryad_S5#21, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(*((tmp#8->right)))))), ==(old(_dryad_S4#20, treap_keys(*((tmp#8->right)))), old(_dryad_S5#21, treap_keys(*((tmp#8->right)))))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $rd_phys_ptr(_dryad_S4#20, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))) ==> F#treap_keys(_dryad_S4#20, $rd_phys_ptr(_dryad_S4#20, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) == F#treap_keys(_dryad_S5#21, $rd_phys_ptr(_dryad_S5#21, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(*((tmp#8->right)))))), ==(old(_dryad_S4#20, treap_max_key(*((tmp#8->right)))), old(_dryad_S5#21, treap_max_key(*((tmp#8->right)))))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $rd_phys_ptr(_dryad_S4#20, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))) ==> F#treap_max_key(_dryad_S4#20, $rd_phys_ptr(_dryad_S4#20, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) == F#treap_max_key(_dryad_S5#21, $rd_phys_ptr(_dryad_S5#21, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(*((tmp#8->right)))))), ==(old(_dryad_S4#20, treap_max_prio(*((tmp#8->right)))), old(_dryad_S5#21, treap_max_prio(*((tmp#8->right)))))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $rd_phys_ptr(_dryad_S4#20, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))) ==> F#treap_max_prio(_dryad_S4#20, $rd_phys_ptr(_dryad_S4#20, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) == F#treap_max_prio(_dryad_S5#21, $rd_phys_ptr(_dryad_S5#21, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(*((tmp#8->right)))))), ==(old(_dryad_S4#20, treap_min_key(*((tmp#8->right)))), old(_dryad_S5#21, treap_min_key(*((tmp#8->right)))))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $rd_phys_ptr(_dryad_S4#20, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))) ==> F#treap_min_key(_dryad_S4#20, $rd_phys_ptr(_dryad_S4#20, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) == F#treap_min_key(_dryad_S5#21, $rd_phys_ptr(_dryad_S5#21, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(*((tmp#8->right)))))), ==(old(_dryad_S4#20, treap_prios(*((tmp#8->right)))), old(_dryad_S5#21, treap_prios(*((tmp#8->right)))))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $rd_phys_ptr(_dryad_S4#20, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))) ==> F#treap_prios(_dryad_S4#20, $rd_phys_ptr(_dryad_S4#20, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) == F#treap_prios(_dryad_S5#21, $rd_phys_ptr(_dryad_S5#21, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(tmp2#17)))), ==(old(_dryad_S4#20, treap(tmp2#17)), old(_dryad_S5#21, treap(tmp2#17)))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $phys_ptr_cast(tmp2#17, ^b_node))) ==> F#treap(_dryad_S4#20, $phys_ptr_cast(tmp2#17, ^b_node)) == F#treap(_dryad_S5#21, $phys_ptr_cast(tmp2#17, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(tmp2#17)))), ==(old(_dryad_S4#20, treap_reach(tmp2#17)), old(_dryad_S5#21, treap_reach(tmp2#17)))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $phys_ptr_cast(tmp2#17, ^b_node))) ==> F#treap_reach(_dryad_S4#20, $phys_ptr_cast(tmp2#17, ^b_node)) == F#treap_reach(_dryad_S5#21, $phys_ptr_cast(tmp2#17, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(tmp2#17)))), ==(old(_dryad_S4#20, treap_keys(tmp2#17)), old(_dryad_S5#21, treap_keys(tmp2#17)))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $phys_ptr_cast(tmp2#17, ^b_node))) ==> F#treap_keys(_dryad_S4#20, $phys_ptr_cast(tmp2#17, ^b_node)) == F#treap_keys(_dryad_S5#21, $phys_ptr_cast(tmp2#17, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(tmp2#17)))), ==(old(_dryad_S4#20, treap_max_key(tmp2#17)), old(_dryad_S5#21, treap_max_key(tmp2#17)))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $phys_ptr_cast(tmp2#17, ^b_node))) ==> F#treap_max_key(_dryad_S4#20, $phys_ptr_cast(tmp2#17, ^b_node)) == F#treap_max_key(_dryad_S5#21, $phys_ptr_cast(tmp2#17, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(tmp2#17)))), ==(old(_dryad_S4#20, treap_max_prio(tmp2#17)), old(_dryad_S5#21, treap_max_prio(tmp2#17)))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $phys_ptr_cast(tmp2#17, ^b_node))) ==> F#treap_max_prio(_dryad_S4#20, $phys_ptr_cast(tmp2#17, ^b_node)) == F#treap_max_prio(_dryad_S5#21, $phys_ptr_cast(tmp2#17, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(tmp2#17)))), ==(old(_dryad_S4#20, treap_min_key(tmp2#17)), old(_dryad_S5#21, treap_min_key(tmp2#17)))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $phys_ptr_cast(tmp2#17, ^b_node))) ==> F#treap_min_key(_dryad_S4#20, $phys_ptr_cast(tmp2#17, ^b_node)) == F#treap_min_key(_dryad_S5#21, $phys_ptr_cast(tmp2#17, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(tmp2#17)))), ==(old(_dryad_S4#20, treap_prios(tmp2#17)), old(_dryad_S5#21, treap_prios(tmp2#17)))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $phys_ptr_cast(tmp2#17, ^b_node))) ==> F#treap_prios(_dryad_S4#20, $phys_ptr_cast(tmp2#17, ^b_node)) == F#treap_prios(_dryad_S5#21, $phys_ptr_cast(tmp2#17, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(rl)))), ==(old(_dryad_S4#20, treap(rl)), old(_dryad_S5#21, treap(rl)))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $phys_ptr_cast(L#rl, ^b_node))) ==> F#treap(_dryad_S4#20, $phys_ptr_cast(L#rl, ^b_node)) == F#treap(_dryad_S5#21, $phys_ptr_cast(L#rl, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(rl)))), ==(old(_dryad_S4#20, treap_reach(rl)), old(_dryad_S5#21, treap_reach(rl)))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $phys_ptr_cast(L#rl, ^b_node))) ==> F#treap_reach(_dryad_S4#20, $phys_ptr_cast(L#rl, ^b_node)) == F#treap_reach(_dryad_S5#21, $phys_ptr_cast(L#rl, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(rl)))), ==(old(_dryad_S4#20, treap_keys(rl)), old(_dryad_S5#21, treap_keys(rl)))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $phys_ptr_cast(L#rl, ^b_node))) ==> F#treap_keys(_dryad_S4#20, $phys_ptr_cast(L#rl, ^b_node)) == F#treap_keys(_dryad_S5#21, $phys_ptr_cast(L#rl, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(rl)))), ==(old(_dryad_S4#20, treap_max_key(rl)), old(_dryad_S5#21, treap_max_key(rl)))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $phys_ptr_cast(L#rl, ^b_node))) ==> F#treap_max_key(_dryad_S4#20, $phys_ptr_cast(L#rl, ^b_node)) == F#treap_max_key(_dryad_S5#21, $phys_ptr_cast(L#rl, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(rl)))), ==(old(_dryad_S4#20, treap_max_prio(rl)), old(_dryad_S5#21, treap_max_prio(rl)))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $phys_ptr_cast(L#rl, ^b_node))) ==> F#treap_max_prio(_dryad_S4#20, $phys_ptr_cast(L#rl, ^b_node)) == F#treap_max_prio(_dryad_S5#21, $phys_ptr_cast(L#rl, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(rl)))), ==(old(_dryad_S4#20, treap_min_key(rl)), old(_dryad_S5#21, treap_min_key(rl)))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $phys_ptr_cast(L#rl, ^b_node))) ==> F#treap_min_key(_dryad_S4#20, $phys_ptr_cast(L#rl, ^b_node)) == F#treap_min_key(_dryad_S5#21, $phys_ptr_cast(L#rl, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(rl)))), ==(old(_dryad_S4#20, treap_prios(rl)), old(_dryad_S5#21, treap_prios(rl)))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $phys_ptr_cast(L#rl, ^b_node))) ==> F#treap_prios(_dryad_S4#20, $phys_ptr_cast(L#rl, ^b_node)) == F#treap_prios(_dryad_S5#21, $phys_ptr_cast(L#rl, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(x1#12)))), ==(old(_dryad_S4#20, treap(x1#12)), old(_dryad_S5#21, treap(x1#12)))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $phys_ptr_cast(x1#12, ^b_node))) ==> F#treap(_dryad_S4#20, $phys_ptr_cast(x1#12, ^b_node)) == F#treap(_dryad_S5#21, $phys_ptr_cast(x1#12, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(x1#12)))), ==(old(_dryad_S4#20, treap_reach(x1#12)), old(_dryad_S5#21, treap_reach(x1#12)))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $phys_ptr_cast(x1#12, ^b_node))) ==> F#treap_reach(_dryad_S4#20, $phys_ptr_cast(x1#12, ^b_node)) == F#treap_reach(_dryad_S5#21, $phys_ptr_cast(x1#12, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(x1#12)))), ==(old(_dryad_S4#20, treap_keys(x1#12)), old(_dryad_S5#21, treap_keys(x1#12)))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $phys_ptr_cast(x1#12, ^b_node))) ==> F#treap_keys(_dryad_S4#20, $phys_ptr_cast(x1#12, ^b_node)) == F#treap_keys(_dryad_S5#21, $phys_ptr_cast(x1#12, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(x1#12)))), ==(old(_dryad_S4#20, treap_max_key(x1#12)), old(_dryad_S5#21, treap_max_key(x1#12)))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $phys_ptr_cast(x1#12, ^b_node))) ==> F#treap_max_key(_dryad_S4#20, $phys_ptr_cast(x1#12, ^b_node)) == F#treap_max_key(_dryad_S5#21, $phys_ptr_cast(x1#12, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(x1#12)))), ==(old(_dryad_S4#20, treap_max_prio(x1#12)), old(_dryad_S5#21, treap_max_prio(x1#12)))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $phys_ptr_cast(x1#12, ^b_node))) ==> F#treap_max_prio(_dryad_S4#20, $phys_ptr_cast(x1#12, ^b_node)) == F#treap_max_prio(_dryad_S5#21, $phys_ptr_cast(x1#12, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(x1#12)))), ==(old(_dryad_S4#20, treap_min_key(x1#12)), old(_dryad_S5#21, treap_min_key(x1#12)))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $phys_ptr_cast(x1#12, ^b_node))) ==> F#treap_min_key(_dryad_S4#20, $phys_ptr_cast(x1#12, ^b_node)) == F#treap_min_key(_dryad_S5#21, $phys_ptr_cast(x1#12, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(x1#12)))), ==(old(_dryad_S4#20, treap_prios(x1#12)), old(_dryad_S5#21, treap_prios(x1#12)))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $phys_ptr_cast(x1#12, ^b_node))) ==> F#treap_prios(_dryad_S4#20, $phys_ptr_cast(x1#12, ^b_node)) == F#treap_prios(_dryad_S5#21, $phys_ptr_cast(x1#12, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(x0#11)))), ==(old(_dryad_S4#20, treap(x0#11)), old(_dryad_S5#21, treap(x0#11)))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $phys_ptr_cast(x0#11, ^b_node))) ==> F#treap(_dryad_S4#20, $phys_ptr_cast(x0#11, ^b_node)) == F#treap(_dryad_S5#21, $phys_ptr_cast(x0#11, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(x0#11)))), ==(old(_dryad_S4#20, treap_reach(x0#11)), old(_dryad_S5#21, treap_reach(x0#11)))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $phys_ptr_cast(x0#11, ^b_node))) ==> F#treap_reach(_dryad_S4#20, $phys_ptr_cast(x0#11, ^b_node)) == F#treap_reach(_dryad_S5#21, $phys_ptr_cast(x0#11, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(x0#11)))), ==(old(_dryad_S4#20, treap_keys(x0#11)), old(_dryad_S5#21, treap_keys(x0#11)))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $phys_ptr_cast(x0#11, ^b_node))) ==> F#treap_keys(_dryad_S4#20, $phys_ptr_cast(x0#11, ^b_node)) == F#treap_keys(_dryad_S5#21, $phys_ptr_cast(x0#11, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(x0#11)))), ==(old(_dryad_S4#20, treap_max_key(x0#11)), old(_dryad_S5#21, treap_max_key(x0#11)))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $phys_ptr_cast(x0#11, ^b_node))) ==> F#treap_max_key(_dryad_S4#20, $phys_ptr_cast(x0#11, ^b_node)) == F#treap_max_key(_dryad_S5#21, $phys_ptr_cast(x0#11, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(x0#11)))), ==(old(_dryad_S4#20, treap_max_prio(x0#11)), old(_dryad_S5#21, treap_max_prio(x0#11)))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $phys_ptr_cast(x0#11, ^b_node))) ==> F#treap_max_prio(_dryad_S4#20, $phys_ptr_cast(x0#11, ^b_node)) == F#treap_max_prio(_dryad_S5#21, $phys_ptr_cast(x0#11, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(x0#11)))), ==(old(_dryad_S4#20, treap_min_key(x0#11)), old(_dryad_S5#21, treap_min_key(x0#11)))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $phys_ptr_cast(x0#11, ^b_node))) ==> F#treap_min_key(_dryad_S4#20, $phys_ptr_cast(x0#11, ^b_node)) == F#treap_min_key(_dryad_S5#21, $phys_ptr_cast(x0#11, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(x0#11)))), ==(old(_dryad_S4#20, treap_prios(x0#11)), old(_dryad_S5#21, treap_prios(x0#11)))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $phys_ptr_cast(x0#11, ^b_node))) ==> F#treap_prios(_dryad_S4#20, $phys_ptr_cast(x0#11, ^b_node)) == F#treap_prios(_dryad_S5#21, $phys_ptr_cast(x0#11, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(xr#10)))), ==(old(_dryad_S4#20, treap(xr#10)), old(_dryad_S5#21, treap(xr#10)))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $phys_ptr_cast(xr#10, ^b_node))) ==> F#treap(_dryad_S4#20, $phys_ptr_cast(xr#10, ^b_node)) == F#treap(_dryad_S5#21, $phys_ptr_cast(xr#10, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(xr#10)))), ==(old(_dryad_S4#20, treap_reach(xr#10)), old(_dryad_S5#21, treap_reach(xr#10)))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $phys_ptr_cast(xr#10, ^b_node))) ==> F#treap_reach(_dryad_S4#20, $phys_ptr_cast(xr#10, ^b_node)) == F#treap_reach(_dryad_S5#21, $phys_ptr_cast(xr#10, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(xr#10)))), ==(old(_dryad_S4#20, treap_keys(xr#10)), old(_dryad_S5#21, treap_keys(xr#10)))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $phys_ptr_cast(xr#10, ^b_node))) ==> F#treap_keys(_dryad_S4#20, $phys_ptr_cast(xr#10, ^b_node)) == F#treap_keys(_dryad_S5#21, $phys_ptr_cast(xr#10, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(xr#10)))), ==(old(_dryad_S4#20, treap_max_key(xr#10)), old(_dryad_S5#21, treap_max_key(xr#10)))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $phys_ptr_cast(xr#10, ^b_node))) ==> F#treap_max_key(_dryad_S4#20, $phys_ptr_cast(xr#10, ^b_node)) == F#treap_max_key(_dryad_S5#21, $phys_ptr_cast(xr#10, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(xr#10)))), ==(old(_dryad_S4#20, treap_max_prio(xr#10)), old(_dryad_S5#21, treap_max_prio(xr#10)))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $phys_ptr_cast(xr#10, ^b_node))) ==> F#treap_max_prio(_dryad_S4#20, $phys_ptr_cast(xr#10, ^b_node)) == F#treap_max_prio(_dryad_S5#21, $phys_ptr_cast(xr#10, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(xr#10)))), ==(old(_dryad_S4#20, treap_min_key(xr#10)), old(_dryad_S5#21, treap_min_key(xr#10)))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $phys_ptr_cast(xr#10, ^b_node))) ==> F#treap_min_key(_dryad_S4#20, $phys_ptr_cast(xr#10, ^b_node)) == F#treap_min_key(_dryad_S5#21, $phys_ptr_cast(xr#10, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(xr#10)))), ==(old(_dryad_S4#20, treap_prios(xr#10)), old(_dryad_S5#21, treap_prios(xr#10)))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $phys_ptr_cast(xr#10, ^b_node))) ==> F#treap_prios(_dryad_S4#20, $phys_ptr_cast(xr#10, ^b_node)) == F#treap_prios(_dryad_S5#21, $phys_ptr_cast(xr#10, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(xl#9)))), ==(old(_dryad_S4#20, treap(xl#9)), old(_dryad_S5#21, treap(xl#9)))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $phys_ptr_cast(xl#9, ^b_node))) ==> F#treap(_dryad_S4#20, $phys_ptr_cast(xl#9, ^b_node)) == F#treap(_dryad_S5#21, $phys_ptr_cast(xl#9, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(xl#9)))), ==(old(_dryad_S4#20, treap_reach(xl#9)), old(_dryad_S5#21, treap_reach(xl#9)))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $phys_ptr_cast(xl#9, ^b_node))) ==> F#treap_reach(_dryad_S4#20, $phys_ptr_cast(xl#9, ^b_node)) == F#treap_reach(_dryad_S5#21, $phys_ptr_cast(xl#9, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(xl#9)))), ==(old(_dryad_S4#20, treap_keys(xl#9)), old(_dryad_S5#21, treap_keys(xl#9)))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $phys_ptr_cast(xl#9, ^b_node))) ==> F#treap_keys(_dryad_S4#20, $phys_ptr_cast(xl#9, ^b_node)) == F#treap_keys(_dryad_S5#21, $phys_ptr_cast(xl#9, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(xl#9)))), ==(old(_dryad_S4#20, treap_max_key(xl#9)), old(_dryad_S5#21, treap_max_key(xl#9)))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $phys_ptr_cast(xl#9, ^b_node))) ==> F#treap_max_key(_dryad_S4#20, $phys_ptr_cast(xl#9, ^b_node)) == F#treap_max_key(_dryad_S5#21, $phys_ptr_cast(xl#9, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(xl#9)))), ==(old(_dryad_S4#20, treap_max_prio(xl#9)), old(_dryad_S5#21, treap_max_prio(xl#9)))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $phys_ptr_cast(xl#9, ^b_node))) ==> F#treap_max_prio(_dryad_S4#20, $phys_ptr_cast(xl#9, ^b_node)) == F#treap_max_prio(_dryad_S5#21, $phys_ptr_cast(xl#9, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(xl#9)))), ==(old(_dryad_S4#20, treap_min_key(xl#9)), old(_dryad_S5#21, treap_min_key(xl#9)))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $phys_ptr_cast(xl#9, ^b_node))) ==> F#treap_min_key(_dryad_S4#20, $phys_ptr_cast(xl#9, ^b_node)) == F#treap_min_key(_dryad_S5#21, $phys_ptr_cast(xl#9, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(xl#9)))), ==(old(_dryad_S4#20, treap_prios(xl#9)), old(_dryad_S5#21, treap_prios(xl#9)))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $phys_ptr_cast(xl#9, ^b_node))) ==> F#treap_prios(_dryad_S4#20, $phys_ptr_cast(xl#9, ^b_node)) == F#treap_prios(_dryad_S5#21, $phys_ptr_cast(xl#9, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(x)))), ==(old(_dryad_S4#20, treap(x)), old(_dryad_S5#21, treap(x)))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap(_dryad_S4#20, $phys_ptr_cast(P#x, ^b_node)) == F#treap(_dryad_S5#21, $phys_ptr_cast(P#x, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(x)))), ==(old(_dryad_S4#20, treap_reach(x)), old(_dryad_S5#21, treap_reach(x)))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_reach(_dryad_S4#20, $phys_ptr_cast(P#x, ^b_node)) == F#treap_reach(_dryad_S5#21, $phys_ptr_cast(P#x, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(x)))), ==(old(_dryad_S4#20, treap_keys(x)), old(_dryad_S5#21, treap_keys(x)))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_keys(_dryad_S4#20, $phys_ptr_cast(P#x, ^b_node)) == F#treap_keys(_dryad_S5#21, $phys_ptr_cast(P#x, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(x)))), ==(old(_dryad_S4#20, treap_max_key(x)), old(_dryad_S5#21, treap_max_key(x)))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_max_key(_dryad_S4#20, $phys_ptr_cast(P#x, ^b_node)) == F#treap_max_key(_dryad_S5#21, $phys_ptr_cast(P#x, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(x)))), ==(old(_dryad_S4#20, treap_max_prio(x)), old(_dryad_S5#21, treap_max_prio(x)))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_max_prio(_dryad_S4#20, $phys_ptr_cast(P#x, ^b_node)) == F#treap_max_prio(_dryad_S5#21, $phys_ptr_cast(P#x, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(x)))), ==(old(_dryad_S4#20, treap_min_key(x)), old(_dryad_S5#21, treap_min_key(x)))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_min_key(_dryad_S4#20, $phys_ptr_cast(P#x, ^b_node)) == F#treap_min_key(_dryad_S5#21, $phys_ptr_cast(P#x, ^b_node));
                // assume ==>(unchecked!(@_vcc_oset_in(tmp#8, old(_dryad_S4#20, treap_reach(x)))), ==(old(_dryad_S4#20, treap_prios(x)), old(_dryad_S5#21, treap_prios(x)))); 
                assume !$oset_in($phys_ptr_cast(tmp#8, ^b_node), F#treap_reach(_dryad_S4#20, $phys_ptr_cast(P#x, ^b_node))) ==> F#treap_prios(_dryad_S4#20, $phys_ptr_cast(P#x, ^b_node)) == F#treap_prios(_dryad_S5#21, $phys_ptr_cast(P#x, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp#8, tmp2#17)), @_vcc_ptr_eq_pure(*((tmp2#17->left)), old(_dryad_S4#20, *((tmp2#17->left))))); 
                assume !($phys_ptr_cast(tmp#8, ^b_node) == $phys_ptr_cast(tmp2#17, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S4#20, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp#8, tmp2#17)), @_vcc_ptr_eq_pure(*((tmp2#17->right)), old(_dryad_S4#20, *((tmp2#17->right))))); 
                assume !($phys_ptr_cast(tmp#8, ^b_node) == $phys_ptr_cast(tmp2#17, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S4#20, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp#8, tmp2#17)), ==(*((tmp2#17->key)), old(_dryad_S4#20, *((tmp2#17->key))))); 
                assume !($phys_ptr_cast(tmp#8, ^b_node) == $phys_ptr_cast(tmp2#17, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(tmp2#17, ^b_node)) == $rd_inv(_dryad_S4#20, b_node.key, $phys_ptr_cast(tmp2#17, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp#8, tmp2#17)), ==(*((tmp2#17->prio)), old(_dryad_S4#20, *((tmp2#17->prio))))); 
                assume !($phys_ptr_cast(tmp#8, ^b_node) == $phys_ptr_cast(tmp2#17, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(tmp2#17, ^b_node)) == $rd_inv(_dryad_S4#20, b_node.prio, $phys_ptr_cast(tmp2#17, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp#8, rl)), @_vcc_ptr_eq_pure(*((rl->left)), old(_dryad_S4#20, *((rl->left))))); 
                assume !($phys_ptr_cast(tmp#8, ^b_node) == $phys_ptr_cast(L#rl, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S4#20, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp#8, rl)), @_vcc_ptr_eq_pure(*((rl->right)), old(_dryad_S4#20, *((rl->right))))); 
                assume !($phys_ptr_cast(tmp#8, ^b_node) == $phys_ptr_cast(L#rl, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S4#20, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp#8, rl)), ==(*((rl->key)), old(_dryad_S4#20, *((rl->key))))); 
                assume !($phys_ptr_cast(tmp#8, ^b_node) == $phys_ptr_cast(L#rl, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#rl, ^b_node)) == $rd_inv(_dryad_S4#20, b_node.key, $phys_ptr_cast(L#rl, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp#8, rl)), ==(*((rl->prio)), old(_dryad_S4#20, *((rl->prio))))); 
                assume !($phys_ptr_cast(tmp#8, ^b_node) == $phys_ptr_cast(L#rl, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(L#rl, ^b_node)) == $rd_inv(_dryad_S4#20, b_node.prio, $phys_ptr_cast(L#rl, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp#8, x1#12)), @_vcc_ptr_eq_pure(*((x1#12->left)), old(_dryad_S4#20, *((x1#12->left))))); 
                assume !($phys_ptr_cast(tmp#8, ^b_node) == $phys_ptr_cast(x1#12, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S4#20, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp#8, x1#12)), @_vcc_ptr_eq_pure(*((x1#12->right)), old(_dryad_S4#20, *((x1#12->right))))); 
                assume !($phys_ptr_cast(tmp#8, ^b_node) == $phys_ptr_cast(x1#12, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S4#20, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp#8, x1#12)), ==(*((x1#12->key)), old(_dryad_S4#20, *((x1#12->key))))); 
                assume !($phys_ptr_cast(tmp#8, ^b_node) == $phys_ptr_cast(x1#12, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)) == $rd_inv(_dryad_S4#20, b_node.key, $phys_ptr_cast(x1#12, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp#8, x1#12)), ==(*((x1#12->prio)), old(_dryad_S4#20, *((x1#12->prio))))); 
                assume !($phys_ptr_cast(tmp#8, ^b_node) == $phys_ptr_cast(x1#12, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(x1#12, ^b_node)) == $rd_inv(_dryad_S4#20, b_node.prio, $phys_ptr_cast(x1#12, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp#8, x0#11)), @_vcc_ptr_eq_pure(*((x0#11->left)), old(_dryad_S4#20, *((x0#11->left))))); 
                assume !($phys_ptr_cast(tmp#8, ^b_node) == $phys_ptr_cast(x0#11, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S4#20, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp#8, x0#11)), @_vcc_ptr_eq_pure(*((x0#11->right)), old(_dryad_S4#20, *((x0#11->right))))); 
                assume !($phys_ptr_cast(tmp#8, ^b_node) == $phys_ptr_cast(x0#11, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S4#20, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp#8, x0#11)), ==(*((x0#11->key)), old(_dryad_S4#20, *((x0#11->key))))); 
                assume !($phys_ptr_cast(tmp#8, ^b_node) == $phys_ptr_cast(x0#11, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)) == $rd_inv(_dryad_S4#20, b_node.key, $phys_ptr_cast(x0#11, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp#8, x0#11)), ==(*((x0#11->prio)), old(_dryad_S4#20, *((x0#11->prio))))); 
                assume !($phys_ptr_cast(tmp#8, ^b_node) == $phys_ptr_cast(x0#11, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(x0#11, ^b_node)) == $rd_inv(_dryad_S4#20, b_node.prio, $phys_ptr_cast(x0#11, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp#8, xr#10)), @_vcc_ptr_eq_pure(*((xr#10->left)), old(_dryad_S4#20, *((xr#10->left))))); 
                assume !($phys_ptr_cast(tmp#8, ^b_node) == $phys_ptr_cast(xr#10, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S4#20, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp#8, xr#10)), @_vcc_ptr_eq_pure(*((xr#10->right)), old(_dryad_S4#20, *((xr#10->right))))); 
                assume !($phys_ptr_cast(tmp#8, ^b_node) == $phys_ptr_cast(xr#10, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S4#20, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp#8, xr#10)), ==(*((xr#10->key)), old(_dryad_S4#20, *((xr#10->key))))); 
                assume !($phys_ptr_cast(tmp#8, ^b_node) == $phys_ptr_cast(xr#10, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)) == $rd_inv(_dryad_S4#20, b_node.key, $phys_ptr_cast(xr#10, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp#8, xr#10)), ==(*((xr#10->prio)), old(_dryad_S4#20, *((xr#10->prio))))); 
                assume !($phys_ptr_cast(tmp#8, ^b_node) == $phys_ptr_cast(xr#10, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node)) == $rd_inv(_dryad_S4#20, b_node.prio, $phys_ptr_cast(xr#10, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp#8, xl#9)), @_vcc_ptr_eq_pure(*((xl#9->left)), old(_dryad_S4#20, *((xl#9->left))))); 
                assume !($phys_ptr_cast(tmp#8, ^b_node) == $phys_ptr_cast(xl#9, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S4#20, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp#8, xl#9)), @_vcc_ptr_eq_pure(*((xl#9->right)), old(_dryad_S4#20, *((xl#9->right))))); 
                assume !($phys_ptr_cast(tmp#8, ^b_node) == $phys_ptr_cast(xl#9, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S4#20, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp#8, xl#9)), ==(*((xl#9->key)), old(_dryad_S4#20, *((xl#9->key))))); 
                assume !($phys_ptr_cast(tmp#8, ^b_node) == $phys_ptr_cast(xl#9, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)) == $rd_inv(_dryad_S4#20, b_node.key, $phys_ptr_cast(xl#9, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp#8, xl#9)), ==(*((xl#9->prio)), old(_dryad_S4#20, *((xl#9->prio))))); 
                assume !($phys_ptr_cast(tmp#8, ^b_node) == $phys_ptr_cast(xl#9, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node)) == $rd_inv(_dryad_S4#20, b_node.prio, $phys_ptr_cast(xl#9, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp#8, x)), @_vcc_ptr_eq_pure(*((x->left)), old(_dryad_S4#20, *((x->left))))); 
                assume !($phys_ptr_cast(tmp#8, ^b_node) == $phys_ptr_cast(P#x, ^b_node)) ==> $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S4#20, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp#8, x)), @_vcc_ptr_eq_pure(*((x->right)), old(_dryad_S4#20, *((x->right))))); 
                assume !($phys_ptr_cast(tmp#8, ^b_node) == $phys_ptr_cast(P#x, ^b_node)) ==> $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node) == $rd_phys_ptr(_dryad_S4#20, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node);
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp#8, x)), ==(*((x->key)), old(_dryad_S4#20, *((x->key))))); 
                assume !($phys_ptr_cast(tmp#8, ^b_node) == $phys_ptr_cast(P#x, ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) == $rd_inv(_dryad_S4#20, b_node.key, $phys_ptr_cast(P#x, ^b_node));
                // assume ==>(!(@_vcc_ptr_eq_pure(tmp#8, x)), ==(*((x->prio)), old(_dryad_S4#20, *((x->prio))))); 
                assume !($phys_ptr_cast(tmp#8, ^b_node) == $phys_ptr_cast(P#x, ^b_node)) ==> $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)) == $rd_inv(_dryad_S4#20, b_node.prio, $phys_ptr_cast(P#x, ^b_node));
                // assume ==>(@_vcc_ptr_neq_null(tmp2#17), ==(treap(tmp2#17), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((tmp2#17->left))), treap(*((tmp2#17->right)))), unchecked!(@_vcc_oset_in(tmp2#17, @_vcc_oset_union(treap_reach(*((tmp2#17->left))), treap_reach(*((tmp2#17->right))))))), unchecked!(@_vcc_intset_in(*((tmp2#17->key)), @_vcc_intset_union(treap_keys(*((tmp2#17->left))), treap_keys(*((tmp2#17->right))))))), unchecked!(@_vcc_intset_in(*((tmp2#17->prio)), @_vcc_intset_union(treap_prios(*((tmp2#17->left))), treap_prios(*((tmp2#17->right))))))), @_vcc_oset_disjoint(treap_reach(*((tmp2#17->left))), treap_reach(*((tmp2#17->right))))), @_vcc_intset_disjoint(treap_keys(*((tmp2#17->left))), treap_keys(*((tmp2#17->right))))), @_vcc_intset_disjoint(treap_prios(*((tmp2#17->left))), treap_prios(*((tmp2#17->right))))), ==>(@_vcc_ptr_neq_null(*((tmp2#17->left))), <(treap_max_key(*((tmp2#17->left))), *((tmp2#17->key))))), ==>(@_vcc_ptr_neq_null(*((tmp2#17->right))), <(*((tmp2#17->key)), treap_min_key(*((tmp2#17->right)))))), ==>(@_vcc_ptr_neq_null(*((tmp2#17->left))), <(treap_max_prio(*((tmp2#17->left))), *((tmp2#17->prio))))), ==>(@_vcc_ptr_neq_null(*((tmp2#17->right))), <(treap_max_prio(*((tmp2#17->right))), *((tmp2#17->prio))))))); 
                assume $non_null($phys_ptr_cast(tmp2#17, ^b_node)) ==> F#treap($s, $phys_ptr_cast(tmp2#17, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(tmp2#17, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(tmp2#17, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp2#17, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(tmp2#17, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(tmp2#17, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(tmp2#17, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(tmp2#17, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp2#17), ==(treap_reach(tmp2#17), @_vcc_oset_union(@_vcc_oset_singleton(tmp2#17), @_vcc_oset_union(treap_reach(*((tmp2#17->left))), treap_reach(*((tmp2#17->right))))))); 
                assume $non_null($phys_ptr_cast(tmp2#17, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(tmp2#17, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(tmp2#17, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp2#17), ==(treap_keys(tmp2#17), @_vcc_intset_union(@_vcc_intset_singleton(*((tmp2#17->key))), @_vcc_intset_union(treap_keys(*((tmp2#17->left))), treap_keys(*((tmp2#17->right))))))); 
                assume $non_null($phys_ptr_cast(tmp2#17, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(tmp2#17, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(tmp2#17, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp2#17), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp2#17->left))), @_vcc_ptr_neq_null(*((tmp2#17->right)))), ==(treap_max_key(tmp2#17), @\int_max(*((tmp2#17->key)), @\int_max(treap_max_key(*((tmp2#17->left))), treap_max_key(*((tmp2#17->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp2#17->left))), @_vcc_ptr_eq_null(*((tmp2#17->right)))), ==(treap_max_key(tmp2#17), @\int_max(*((tmp2#17->key)), treap_max_key(*((tmp2#17->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp2#17->left))), @_vcc_ptr_neq_null(*((tmp2#17->right)))), ==(treap_max_key(tmp2#17), @\int_max(*((tmp2#17->key)), treap_max_key(*((tmp2#17->right)))))))); 
                assume $non_null($phys_ptr_cast(tmp2#17, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(tmp2#17, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(tmp2#17, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(tmp2#17, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(tmp2#17, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(tmp2#17, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(tmp2#17, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp2#17), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp2#17->left))), @_vcc_ptr_neq_null(*((tmp2#17->right)))), ==(treap_max_prio(tmp2#17), @\int_max(*((tmp2#17->prio)), @\int_max(treap_max_prio(*((tmp2#17->left))), treap_max_prio(*((tmp2#17->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp2#17->left))), @_vcc_ptr_eq_null(*((tmp2#17->right)))), ==(treap_max_prio(tmp2#17), @\int_max(*((tmp2#17->prio)), treap_max_prio(*((tmp2#17->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp2#17->left))), @_vcc_ptr_neq_null(*((tmp2#17->right)))), ==(treap_max_prio(tmp2#17), @\int_max(*((tmp2#17->prio)), treap_max_prio(*((tmp2#17->right)))))))); 
                assume $non_null($phys_ptr_cast(tmp2#17, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(tmp2#17, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp2#17, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(tmp2#17, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp2#17, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(tmp2#17, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp2#17, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp2#17), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp2#17->left))), @_vcc_ptr_neq_null(*((tmp2#17->right)))), ==(treap_min_key(tmp2#17), @\int_min(*((tmp2#17->key)), @\int_min(treap_min_key(*((tmp2#17->left))), treap_min_key(*((tmp2#17->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp2#17->left))), @_vcc_ptr_eq_null(*((tmp2#17->right)))), ==(treap_min_key(tmp2#17), @\int_min(*((tmp2#17->key)), treap_min_key(*((tmp2#17->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp2#17->left))), @_vcc_ptr_neq_null(*((tmp2#17->right)))), ==(treap_min_key(tmp2#17), @\int_min(*((tmp2#17->key)), treap_min_key(*((tmp2#17->right)))))))); 
                assume $non_null($phys_ptr_cast(tmp2#17, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(tmp2#17, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(tmp2#17, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(tmp2#17, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(tmp2#17, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(tmp2#17, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(tmp2#17, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp2#17), ==(treap_prios(tmp2#17), @_vcc_intset_union(@_vcc_intset_singleton(*((tmp2#17->prio))), @_vcc_intset_union(treap_prios(*((tmp2#17->left))), treap_prios(*((tmp2#17->right))))))); 
                assume $non_null($phys_ptr_cast(tmp2#17, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(tmp2#17, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp2#17, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp2#17, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(rl), ==(treap(rl), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((rl->left))), treap(*((rl->right)))), unchecked!(@_vcc_oset_in(rl, @_vcc_oset_union(treap_reach(*((rl->left))), treap_reach(*((rl->right))))))), unchecked!(@_vcc_intset_in(*((rl->key)), @_vcc_intset_union(treap_keys(*((rl->left))), treap_keys(*((rl->right))))))), unchecked!(@_vcc_intset_in(*((rl->prio)), @_vcc_intset_union(treap_prios(*((rl->left))), treap_prios(*((rl->right))))))), @_vcc_oset_disjoint(treap_reach(*((rl->left))), treap_reach(*((rl->right))))), @_vcc_intset_disjoint(treap_keys(*((rl->left))), treap_keys(*((rl->right))))), @_vcc_intset_disjoint(treap_prios(*((rl->left))), treap_prios(*((rl->right))))), ==>(@_vcc_ptr_neq_null(*((rl->left))), <(treap_max_key(*((rl->left))), *((rl->key))))), ==>(@_vcc_ptr_neq_null(*((rl->right))), <(*((rl->key)), treap_min_key(*((rl->right)))))), ==>(@_vcc_ptr_neq_null(*((rl->left))), <(treap_max_prio(*((rl->left))), *((rl->prio))))), ==>(@_vcc_ptr_neq_null(*((rl->right))), <(treap_max_prio(*((rl->right))), *((rl->prio))))))); 
                assume $non_null($phys_ptr_cast(L#rl, ^b_node)) ==> F#treap($s, $phys_ptr_cast(L#rl, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(L#rl, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(L#rl, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(L#rl, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(L#rl, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(L#rl, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#rl, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(L#rl, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(rl), ==(treap_reach(rl), @_vcc_oset_union(@_vcc_oset_singleton(rl), @_vcc_oset_union(treap_reach(*((rl->left))), treap_reach(*((rl->right))))))); 
                assume $non_null($phys_ptr_cast(L#rl, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(L#rl, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(L#rl, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(rl), ==(treap_keys(rl), @_vcc_intset_union(@_vcc_intset_singleton(*((rl->key))), @_vcc_intset_union(treap_keys(*((rl->left))), treap_keys(*((rl->right))))))); 
                assume $non_null($phys_ptr_cast(L#rl, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(L#rl, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(L#rl, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(rl), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((rl->left))), @_vcc_ptr_neq_null(*((rl->right)))), ==(treap_max_key(rl), @\int_max(*((rl->key)), @\int_max(treap_max_key(*((rl->left))), treap_max_key(*((rl->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((rl->left))), @_vcc_ptr_eq_null(*((rl->right)))), ==(treap_max_key(rl), @\int_max(*((rl->key)), treap_max_key(*((rl->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((rl->left))), @_vcc_ptr_neq_null(*((rl->right)))), ==(treap_max_key(rl), @\int_max(*((rl->key)), treap_max_key(*((rl->right)))))))); 
                assume $non_null($phys_ptr_cast(L#rl, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#rl, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#rl, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#rl, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#rl, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(L#rl, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(L#rl, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(rl), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((rl->left))), @_vcc_ptr_neq_null(*((rl->right)))), ==(treap_max_prio(rl), @\int_max(*((rl->prio)), @\int_max(treap_max_prio(*((rl->left))), treap_max_prio(*((rl->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((rl->left))), @_vcc_ptr_eq_null(*((rl->right)))), ==(treap_max_prio(rl), @\int_max(*((rl->prio)), treap_max_prio(*((rl->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((rl->left))), @_vcc_ptr_neq_null(*((rl->right)))), ==(treap_max_prio(rl), @\int_max(*((rl->prio)), treap_max_prio(*((rl->right)))))))); 
                assume $non_null($phys_ptr_cast(L#rl, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#rl, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#rl, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#rl, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#rl, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(L#rl, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(L#rl, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(rl), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((rl->left))), @_vcc_ptr_neq_null(*((rl->right)))), ==(treap_min_key(rl), @\int_min(*((rl->key)), @\int_min(treap_min_key(*((rl->left))), treap_min_key(*((rl->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((rl->left))), @_vcc_ptr_eq_null(*((rl->right)))), ==(treap_min_key(rl), @\int_min(*((rl->key)), treap_min_key(*((rl->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((rl->left))), @_vcc_ptr_neq_null(*((rl->right)))), ==(treap_min_key(rl), @\int_min(*((rl->key)), treap_min_key(*((rl->right)))))))); 
                assume $non_null($phys_ptr_cast(L#rl, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#rl, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#rl, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#rl, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#rl, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(L#rl, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(L#rl, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(rl), ==(treap_prios(rl), @_vcc_intset_union(@_vcc_intset_singleton(*((rl->prio))), @_vcc_intset_union(treap_prios(*((rl->left))), treap_prios(*((rl->right))))))); 
                assume $non_null($phys_ptr_cast(L#rl, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(L#rl, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(L#rl, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(L#rl, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(L#rl, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1#12), ==(treap(x1#12), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x1#12->left))), treap(*((x1#12->right)))), unchecked!(@_vcc_oset_in(x1#12, @_vcc_oset_union(treap_reach(*((x1#12->left))), treap_reach(*((x1#12->right))))))), unchecked!(@_vcc_intset_in(*((x1#12->key)), @_vcc_intset_union(treap_keys(*((x1#12->left))), treap_keys(*((x1#12->right))))))), unchecked!(@_vcc_intset_in(*((x1#12->prio)), @_vcc_intset_union(treap_prios(*((x1#12->left))), treap_prios(*((x1#12->right))))))), @_vcc_oset_disjoint(treap_reach(*((x1#12->left))), treap_reach(*((x1#12->right))))), @_vcc_intset_disjoint(treap_keys(*((x1#12->left))), treap_keys(*((x1#12->right))))), @_vcc_intset_disjoint(treap_prios(*((x1#12->left))), treap_prios(*((x1#12->right))))), ==>(@_vcc_ptr_neq_null(*((x1#12->left))), <(treap_max_key(*((x1#12->left))), *((x1#12->key))))), ==>(@_vcc_ptr_neq_null(*((x1#12->right))), <(*((x1#12->key)), treap_min_key(*((x1#12->right)))))), ==>(@_vcc_ptr_neq_null(*((x1#12->left))), <(treap_max_prio(*((x1#12->left))), *((x1#12->prio))))), ==>(@_vcc_ptr_neq_null(*((x1#12->right))), <(treap_max_prio(*((x1#12->right))), *((x1#12->prio))))))); 
                assume $non_null($phys_ptr_cast(x1#12, ^b_node)) ==> F#treap($s, $phys_ptr_cast(x1#12, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(x1#12, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(x1#12, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(x1#12, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(x1#12, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1#12), ==(treap_reach(x1#12), @_vcc_oset_union(@_vcc_oset_singleton(x1#12), @_vcc_oset_union(treap_reach(*((x1#12->left))), treap_reach(*((x1#12->right))))))); 
                assume $non_null($phys_ptr_cast(x1#12, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(x1#12, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(x1#12, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1#12), ==(treap_keys(x1#12), @_vcc_intset_union(@_vcc_intset_singleton(*((x1#12->key))), @_vcc_intset_union(treap_keys(*((x1#12->left))), treap_keys(*((x1#12->right))))))); 
                assume $non_null($phys_ptr_cast(x1#12, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(x1#12, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1#12), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x1#12->left))), @_vcc_ptr_neq_null(*((x1#12->right)))), ==(treap_max_key(x1#12), @\int_max(*((x1#12->key)), @\int_max(treap_max_key(*((x1#12->left))), treap_max_key(*((x1#12->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x1#12->left))), @_vcc_ptr_eq_null(*((x1#12->right)))), ==(treap_max_key(x1#12), @\int_max(*((x1#12->key)), treap_max_key(*((x1#12->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x1#12->left))), @_vcc_ptr_neq_null(*((x1#12->right)))), ==(treap_max_key(x1#12), @\int_max(*((x1#12->key)), treap_max_key(*((x1#12->right)))))))); 
                assume $non_null($phys_ptr_cast(x1#12, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1#12), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x1#12->left))), @_vcc_ptr_neq_null(*((x1#12->right)))), ==(treap_max_prio(x1#12), @\int_max(*((x1#12->prio)), @\int_max(treap_max_prio(*((x1#12->left))), treap_max_prio(*((x1#12->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x1#12->left))), @_vcc_ptr_eq_null(*((x1#12->right)))), ==(treap_max_prio(x1#12), @\int_max(*((x1#12->prio)), treap_max_prio(*((x1#12->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x1#12->left))), @_vcc_ptr_neq_null(*((x1#12->right)))), ==(treap_max_prio(x1#12), @\int_max(*((x1#12->prio)), treap_max_prio(*((x1#12->right)))))))); 
                assume $non_null($phys_ptr_cast(x1#12, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(x1#12, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(x1#12, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(x1#12, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1#12), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x1#12->left))), @_vcc_ptr_neq_null(*((x1#12->right)))), ==(treap_min_key(x1#12), @\int_min(*((x1#12->key)), @\int_min(treap_min_key(*((x1#12->left))), treap_min_key(*((x1#12->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x1#12->left))), @_vcc_ptr_eq_null(*((x1#12->right)))), ==(treap_min_key(x1#12), @\int_min(*((x1#12->key)), treap_min_key(*((x1#12->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x1#12->left))), @_vcc_ptr_neq_null(*((x1#12->right)))), ==(treap_min_key(x1#12), @\int_min(*((x1#12->key)), treap_min_key(*((x1#12->right)))))))); 
                assume $non_null($phys_ptr_cast(x1#12, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(x1#12, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(x1#12, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x1#12), ==(treap_prios(x1#12), @_vcc_intset_union(@_vcc_intset_singleton(*((x1#12->prio))), @_vcc_intset_union(treap_prios(*((x1#12->left))), treap_prios(*((x1#12->right))))))); 
                assume $non_null($phys_ptr_cast(x1#12, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(x1#12, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(x1#12, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x1#12, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x1#12, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0#11), ==(treap(x0#11), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x0#11->left))), treap(*((x0#11->right)))), unchecked!(@_vcc_oset_in(x0#11, @_vcc_oset_union(treap_reach(*((x0#11->left))), treap_reach(*((x0#11->right))))))), unchecked!(@_vcc_intset_in(*((x0#11->key)), @_vcc_intset_union(treap_keys(*((x0#11->left))), treap_keys(*((x0#11->right))))))), unchecked!(@_vcc_intset_in(*((x0#11->prio)), @_vcc_intset_union(treap_prios(*((x0#11->left))), treap_prios(*((x0#11->right))))))), @_vcc_oset_disjoint(treap_reach(*((x0#11->left))), treap_reach(*((x0#11->right))))), @_vcc_intset_disjoint(treap_keys(*((x0#11->left))), treap_keys(*((x0#11->right))))), @_vcc_intset_disjoint(treap_prios(*((x0#11->left))), treap_prios(*((x0#11->right))))), ==>(@_vcc_ptr_neq_null(*((x0#11->left))), <(treap_max_key(*((x0#11->left))), *((x0#11->key))))), ==>(@_vcc_ptr_neq_null(*((x0#11->right))), <(*((x0#11->key)), treap_min_key(*((x0#11->right)))))), ==>(@_vcc_ptr_neq_null(*((x0#11->left))), <(treap_max_prio(*((x0#11->left))), *((x0#11->prio))))), ==>(@_vcc_ptr_neq_null(*((x0#11->right))), <(treap_max_prio(*((x0#11->right))), *((x0#11->prio))))))); 
                assume $non_null($phys_ptr_cast(x0#11, ^b_node)) ==> F#treap($s, $phys_ptr_cast(x0#11, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(x0#11, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(x0#11, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(x0#11, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(x0#11, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0#11), ==(treap_reach(x0#11), @_vcc_oset_union(@_vcc_oset_singleton(x0#11), @_vcc_oset_union(treap_reach(*((x0#11->left))), treap_reach(*((x0#11->right))))))); 
                assume $non_null($phys_ptr_cast(x0#11, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(x0#11, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(x0#11, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0#11), ==(treap_keys(x0#11), @_vcc_intset_union(@_vcc_intset_singleton(*((x0#11->key))), @_vcc_intset_union(treap_keys(*((x0#11->left))), treap_keys(*((x0#11->right))))))); 
                assume $non_null($phys_ptr_cast(x0#11, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(x0#11, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0#11), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x0#11->left))), @_vcc_ptr_neq_null(*((x0#11->right)))), ==(treap_max_key(x0#11), @\int_max(*((x0#11->key)), @\int_max(treap_max_key(*((x0#11->left))), treap_max_key(*((x0#11->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x0#11->left))), @_vcc_ptr_eq_null(*((x0#11->right)))), ==(treap_max_key(x0#11), @\int_max(*((x0#11->key)), treap_max_key(*((x0#11->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x0#11->left))), @_vcc_ptr_neq_null(*((x0#11->right)))), ==(treap_max_key(x0#11), @\int_max(*((x0#11->key)), treap_max_key(*((x0#11->right)))))))); 
                assume $non_null($phys_ptr_cast(x0#11, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0#11), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x0#11->left))), @_vcc_ptr_neq_null(*((x0#11->right)))), ==(treap_max_prio(x0#11), @\int_max(*((x0#11->prio)), @\int_max(treap_max_prio(*((x0#11->left))), treap_max_prio(*((x0#11->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x0#11->left))), @_vcc_ptr_eq_null(*((x0#11->right)))), ==(treap_max_prio(x0#11), @\int_max(*((x0#11->prio)), treap_max_prio(*((x0#11->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x0#11->left))), @_vcc_ptr_neq_null(*((x0#11->right)))), ==(treap_max_prio(x0#11), @\int_max(*((x0#11->prio)), treap_max_prio(*((x0#11->right)))))))); 
                assume $non_null($phys_ptr_cast(x0#11, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(x0#11, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(x0#11, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(x0#11, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0#11), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x0#11->left))), @_vcc_ptr_neq_null(*((x0#11->right)))), ==(treap_min_key(x0#11), @\int_min(*((x0#11->key)), @\int_min(treap_min_key(*((x0#11->left))), treap_min_key(*((x0#11->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x0#11->left))), @_vcc_ptr_eq_null(*((x0#11->right)))), ==(treap_min_key(x0#11), @\int_min(*((x0#11->key)), treap_min_key(*((x0#11->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x0#11->left))), @_vcc_ptr_neq_null(*((x0#11->right)))), ==(treap_min_key(x0#11), @\int_min(*((x0#11->key)), treap_min_key(*((x0#11->right)))))))); 
                assume $non_null($phys_ptr_cast(x0#11, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(x0#11, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(x0#11, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x0#11), ==(treap_prios(x0#11), @_vcc_intset_union(@_vcc_intset_singleton(*((x0#11->prio))), @_vcc_intset_union(treap_prios(*((x0#11->left))), treap_prios(*((x0#11->right))))))); 
                assume $non_null($phys_ptr_cast(x0#11, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(x0#11, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(x0#11, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(x0#11, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(x0#11, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr#10), ==(treap(xr#10), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((xr#10->left))), treap(*((xr#10->right)))), unchecked!(@_vcc_oset_in(xr#10, @_vcc_oset_union(treap_reach(*((xr#10->left))), treap_reach(*((xr#10->right))))))), unchecked!(@_vcc_intset_in(*((xr#10->key)), @_vcc_intset_union(treap_keys(*((xr#10->left))), treap_keys(*((xr#10->right))))))), unchecked!(@_vcc_intset_in(*((xr#10->prio)), @_vcc_intset_union(treap_prios(*((xr#10->left))), treap_prios(*((xr#10->right))))))), @_vcc_oset_disjoint(treap_reach(*((xr#10->left))), treap_reach(*((xr#10->right))))), @_vcc_intset_disjoint(treap_keys(*((xr#10->left))), treap_keys(*((xr#10->right))))), @_vcc_intset_disjoint(treap_prios(*((xr#10->left))), treap_prios(*((xr#10->right))))), ==>(@_vcc_ptr_neq_null(*((xr#10->left))), <(treap_max_key(*((xr#10->left))), *((xr#10->key))))), ==>(@_vcc_ptr_neq_null(*((xr#10->right))), <(*((xr#10->key)), treap_min_key(*((xr#10->right)))))), ==>(@_vcc_ptr_neq_null(*((xr#10->left))), <(treap_max_prio(*((xr#10->left))), *((xr#10->prio))))), ==>(@_vcc_ptr_neq_null(*((xr#10->right))), <(treap_max_prio(*((xr#10->right))), *((xr#10->prio))))))); 
                assume $non_null($phys_ptr_cast(xr#10, ^b_node)) ==> F#treap($s, $phys_ptr_cast(xr#10, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(xr#10, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr#10), ==(treap_reach(xr#10), @_vcc_oset_union(@_vcc_oset_singleton(xr#10), @_vcc_oset_union(treap_reach(*((xr#10->left))), treap_reach(*((xr#10->right))))))); 
                assume $non_null($phys_ptr_cast(xr#10, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(xr#10, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(xr#10, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr#10), ==(treap_keys(xr#10), @_vcc_intset_union(@_vcc_intset_singleton(*((xr#10->key))), @_vcc_intset_union(treap_keys(*((xr#10->left))), treap_keys(*((xr#10->right))))))); 
                assume $non_null($phys_ptr_cast(xr#10, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(xr#10, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr#10), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr#10->left))), @_vcc_ptr_neq_null(*((xr#10->right)))), ==(treap_max_key(xr#10), @\int_max(*((xr#10->key)), @\int_max(treap_max_key(*((xr#10->left))), treap_max_key(*((xr#10->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr#10->left))), @_vcc_ptr_eq_null(*((xr#10->right)))), ==(treap_max_key(xr#10), @\int_max(*((xr#10->key)), treap_max_key(*((xr#10->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr#10->left))), @_vcc_ptr_neq_null(*((xr#10->right)))), ==(treap_max_key(xr#10), @\int_max(*((xr#10->key)), treap_max_key(*((xr#10->right)))))))); 
                assume $non_null($phys_ptr_cast(xr#10, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr#10), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr#10->left))), @_vcc_ptr_neq_null(*((xr#10->right)))), ==(treap_max_prio(xr#10), @\int_max(*((xr#10->prio)), @\int_max(treap_max_prio(*((xr#10->left))), treap_max_prio(*((xr#10->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr#10->left))), @_vcc_ptr_eq_null(*((xr#10->right)))), ==(treap_max_prio(xr#10), @\int_max(*((xr#10->prio)), treap_max_prio(*((xr#10->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr#10->left))), @_vcc_ptr_neq_null(*((xr#10->right)))), ==(treap_max_prio(xr#10), @\int_max(*((xr#10->prio)), treap_max_prio(*((xr#10->right)))))))); 
                assume $non_null($phys_ptr_cast(xr#10, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr#10), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xr#10->left))), @_vcc_ptr_neq_null(*((xr#10->right)))), ==(treap_min_key(xr#10), @\int_min(*((xr#10->key)), @\int_min(treap_min_key(*((xr#10->left))), treap_min_key(*((xr#10->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xr#10->left))), @_vcc_ptr_eq_null(*((xr#10->right)))), ==(treap_min_key(xr#10), @\int_min(*((xr#10->key)), treap_min_key(*((xr#10->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xr#10->left))), @_vcc_ptr_neq_null(*((xr#10->right)))), ==(treap_min_key(xr#10), @\int_min(*((xr#10->key)), treap_min_key(*((xr#10->right)))))))); 
                assume $non_null($phys_ptr_cast(xr#10, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xr#10, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xr#10, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xr#10), ==(treap_prios(xr#10), @_vcc_intset_union(@_vcc_intset_singleton(*((xr#10->prio))), @_vcc_intset_union(treap_prios(*((xr#10->left))), treap_prios(*((xr#10->right))))))); 
                assume $non_null($phys_ptr_cast(xr#10, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(xr#10, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(xr#10, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xr#10, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xr#10, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl#9), ==(treap(xl#9), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((xl#9->left))), treap(*((xl#9->right)))), unchecked!(@_vcc_oset_in(xl#9, @_vcc_oset_union(treap_reach(*((xl#9->left))), treap_reach(*((xl#9->right))))))), unchecked!(@_vcc_intset_in(*((xl#9->key)), @_vcc_intset_union(treap_keys(*((xl#9->left))), treap_keys(*((xl#9->right))))))), unchecked!(@_vcc_intset_in(*((xl#9->prio)), @_vcc_intset_union(treap_prios(*((xl#9->left))), treap_prios(*((xl#9->right))))))), @_vcc_oset_disjoint(treap_reach(*((xl#9->left))), treap_reach(*((xl#9->right))))), @_vcc_intset_disjoint(treap_keys(*((xl#9->left))), treap_keys(*((xl#9->right))))), @_vcc_intset_disjoint(treap_prios(*((xl#9->left))), treap_prios(*((xl#9->right))))), ==>(@_vcc_ptr_neq_null(*((xl#9->left))), <(treap_max_key(*((xl#9->left))), *((xl#9->key))))), ==>(@_vcc_ptr_neq_null(*((xl#9->right))), <(*((xl#9->key)), treap_min_key(*((xl#9->right)))))), ==>(@_vcc_ptr_neq_null(*((xl#9->left))), <(treap_max_prio(*((xl#9->left))), *((xl#9->prio))))), ==>(@_vcc_ptr_neq_null(*((xl#9->right))), <(treap_max_prio(*((xl#9->right))), *((xl#9->prio))))))); 
                assume $non_null($phys_ptr_cast(xl#9, ^b_node)) ==> F#treap($s, $phys_ptr_cast(xl#9, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(xl#9, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl#9), ==(treap_reach(xl#9), @_vcc_oset_union(@_vcc_oset_singleton(xl#9), @_vcc_oset_union(treap_reach(*((xl#9->left))), treap_reach(*((xl#9->right))))))); 
                assume $non_null($phys_ptr_cast(xl#9, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(xl#9, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(xl#9, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl#9), ==(treap_keys(xl#9), @_vcc_intset_union(@_vcc_intset_singleton(*((xl#9->key))), @_vcc_intset_union(treap_keys(*((xl#9->left))), treap_keys(*((xl#9->right))))))); 
                assume $non_null($phys_ptr_cast(xl#9, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(xl#9, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl#9), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl#9->left))), @_vcc_ptr_neq_null(*((xl#9->right)))), ==(treap_max_key(xl#9), @\int_max(*((xl#9->key)), @\int_max(treap_max_key(*((xl#9->left))), treap_max_key(*((xl#9->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl#9->left))), @_vcc_ptr_eq_null(*((xl#9->right)))), ==(treap_max_key(xl#9), @\int_max(*((xl#9->key)), treap_max_key(*((xl#9->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl#9->left))), @_vcc_ptr_neq_null(*((xl#9->right)))), ==(treap_max_key(xl#9), @\int_max(*((xl#9->key)), treap_max_key(*((xl#9->right)))))))); 
                assume $non_null($phys_ptr_cast(xl#9, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl#9), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl#9->left))), @_vcc_ptr_neq_null(*((xl#9->right)))), ==(treap_max_prio(xl#9), @\int_max(*((xl#9->prio)), @\int_max(treap_max_prio(*((xl#9->left))), treap_max_prio(*((xl#9->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl#9->left))), @_vcc_ptr_eq_null(*((xl#9->right)))), ==(treap_max_prio(xl#9), @\int_max(*((xl#9->prio)), treap_max_prio(*((xl#9->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl#9->left))), @_vcc_ptr_neq_null(*((xl#9->right)))), ==(treap_max_prio(xl#9), @\int_max(*((xl#9->prio)), treap_max_prio(*((xl#9->right)))))))); 
                assume $non_null($phys_ptr_cast(xl#9, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl#9), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((xl#9->left))), @_vcc_ptr_neq_null(*((xl#9->right)))), ==(treap_min_key(xl#9), @\int_min(*((xl#9->key)), @\int_min(treap_min_key(*((xl#9->left))), treap_min_key(*((xl#9->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((xl#9->left))), @_vcc_ptr_eq_null(*((xl#9->right)))), ==(treap_min_key(xl#9), @\int_min(*((xl#9->key)), treap_min_key(*((xl#9->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((xl#9->left))), @_vcc_ptr_neq_null(*((xl#9->right)))), ==(treap_min_key(xl#9), @\int_min(*((xl#9->key)), treap_min_key(*((xl#9->right)))))))); 
                assume $non_null($phys_ptr_cast(xl#9, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(xl#9, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(xl#9, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(xl#9), ==(treap_prios(xl#9), @_vcc_intset_union(@_vcc_intset_singleton(*((xl#9->prio))), @_vcc_intset_union(treap_prios(*((xl#9->left))), treap_prios(*((xl#9->right))))))); 
                assume $non_null($phys_ptr_cast(xl#9, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(xl#9, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(xl#9, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(xl#9, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(xl#9, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), ==(treap(x), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x->left))), treap(*((x->right)))), unchecked!(@_vcc_oset_in(x, @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->key)), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->prio)), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))), @_vcc_oset_disjoint(treap_reach(*((x->left))), treap_reach(*((x->right))))), @_vcc_intset_disjoint(treap_keys(*((x->left))), treap_keys(*((x->right))))), @_vcc_intset_disjoint(treap_prios(*((x->left))), treap_prios(*((x->right))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_key(*((x->left))), *((x->key))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(*((x->key)), treap_min_key(*((x->right)))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_prio(*((x->left))), *((x->prio))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(treap_max_prio(*((x->right))), *((x->prio))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap($s, $phys_ptr_cast(P#x, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(P#x, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_reach(x), @_vcc_oset_union(@_vcc_oset_singleton(x), @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(P#x, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(P#x, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_keys(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->key))), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), @\int_max(treap_max_key(*((x->left))), treap_max_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->right)))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), @\int_max(treap_max_prio(*((x->left))), treap_max_prio(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->right)))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), @\int_min(treap_min_key(*((x->left))), treap_min_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->right)))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_prios(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->prio))), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), ==(treap(tmp#8), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((tmp#8->left))), treap(*((tmp#8->right)))), unchecked!(@_vcc_oset_in(tmp#8, @_vcc_oset_union(treap_reach(*((tmp#8->left))), treap_reach(*((tmp#8->right))))))), unchecked!(@_vcc_intset_in(*((tmp#8->key)), @_vcc_intset_union(treap_keys(*((tmp#8->left))), treap_keys(*((tmp#8->right))))))), unchecked!(@_vcc_intset_in(*((tmp#8->prio)), @_vcc_intset_union(treap_prios(*((tmp#8->left))), treap_prios(*((tmp#8->right))))))), @_vcc_oset_disjoint(treap_reach(*((tmp#8->left))), treap_reach(*((tmp#8->right))))), @_vcc_intset_disjoint(treap_keys(*((tmp#8->left))), treap_keys(*((tmp#8->right))))), @_vcc_intset_disjoint(treap_prios(*((tmp#8->left))), treap_prios(*((tmp#8->right))))), ==>(@_vcc_ptr_neq_null(*((tmp#8->left))), <(treap_max_key(*((tmp#8->left))), *((tmp#8->key))))), ==>(@_vcc_ptr_neq_null(*((tmp#8->right))), <(*((tmp#8->key)), treap_min_key(*((tmp#8->right)))))), ==>(@_vcc_ptr_neq_null(*((tmp#8->left))), <(treap_max_prio(*((tmp#8->left))), *((tmp#8->prio))))), ==>(@_vcc_ptr_neq_null(*((tmp#8->right))), <(treap_max_prio(*((tmp#8->right))), *((tmp#8->prio))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> F#treap($s, $phys_ptr_cast(tmp#8, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(tmp#8, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), ==(treap_reach(tmp#8), @_vcc_oset_union(@_vcc_oset_singleton(tmp#8), @_vcc_oset_union(treap_reach(*((tmp#8->left))), treap_reach(*((tmp#8->right))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(tmp#8, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(tmp#8, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), ==(treap_keys(tmp#8), @_vcc_intset_union(@_vcc_intset_singleton(*((tmp#8->key))), @_vcc_intset_union(treap_keys(*((tmp#8->left))), treap_keys(*((tmp#8->right))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(tmp#8, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_max_key(tmp#8), @\int_max(*((tmp#8->key)), @\int_max(treap_max_key(*((tmp#8->left))), treap_max_key(*((tmp#8->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_eq_null(*((tmp#8->right)))), ==(treap_max_key(tmp#8), @\int_max(*((tmp#8->key)), treap_max_key(*((tmp#8->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_max_key(tmp#8), @\int_max(*((tmp#8->key)), treap_max_key(*((tmp#8->right)))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_max_prio(tmp#8), @\int_max(*((tmp#8->prio)), @\int_max(treap_max_prio(*((tmp#8->left))), treap_max_prio(*((tmp#8->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_eq_null(*((tmp#8->right)))), ==(treap_max_prio(tmp#8), @\int_max(*((tmp#8->prio)), treap_max_prio(*((tmp#8->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_max_prio(tmp#8), @\int_max(*((tmp#8->prio)), treap_max_prio(*((tmp#8->right)))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_min_key(tmp#8), @\int_min(*((tmp#8->key)), @\int_min(treap_min_key(*((tmp#8->left))), treap_min_key(*((tmp#8->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((tmp#8->left))), @_vcc_ptr_eq_null(*((tmp#8->right)))), ==(treap_min_key(tmp#8), @\int_min(*((tmp#8->key)), treap_min_key(*((tmp#8->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((tmp#8->left))), @_vcc_ptr_neq_null(*((tmp#8->right)))), ==(treap_min_key(tmp#8), @\int_min(*((tmp#8->key)), treap_min_key(*((tmp#8->right)))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(tmp#8, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(tmp#8, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(tmp#8), ==(treap_prios(tmp#8), @_vcc_intset_union(@_vcc_intset_singleton(*((tmp#8->prio))), @_vcc_intset_union(treap_prios(*((tmp#8->left))), treap_prios(*((tmp#8->right))))))); 
                assume $non_null($phys_ptr_cast(tmp#8, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(tmp#8, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(tmp#8, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(tmp#8, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(tmp#8, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), ==(treap(x), &&(&&(&&(&&(&&(&&(&&(&&(&&(&&(&&(treap(*((x->left))), treap(*((x->right)))), unchecked!(@_vcc_oset_in(x, @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->key)), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))), unchecked!(@_vcc_intset_in(*((x->prio)), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))), @_vcc_oset_disjoint(treap_reach(*((x->left))), treap_reach(*((x->right))))), @_vcc_intset_disjoint(treap_keys(*((x->left))), treap_keys(*((x->right))))), @_vcc_intset_disjoint(treap_prios(*((x->left))), treap_prios(*((x->right))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_key(*((x->left))), *((x->key))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(*((x->key)), treap_min_key(*((x->right)))))), ==>(@_vcc_ptr_neq_null(*((x->left))), <(treap_max_prio(*((x->left))), *((x->prio))))), ==>(@_vcc_ptr_neq_null(*((x->right))), <(treap_max_prio(*((x->right))), *((x->prio))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap($s, $phys_ptr_cast(P#x, ^b_node)) == (F#treap($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && F#treap($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && !$oset_in($phys_ptr_cast(P#x, ^b_node), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && !$intset_in($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && $oset_disjoint(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && $intset_disjoint(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> $rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)) < F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))) && ($non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) < $rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_reach(x), @_vcc_oset_union(@_vcc_oset_singleton(x), @_vcc_oset_union(treap_reach(*((x->left))), treap_reach(*((x->right))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_reach($s, $phys_ptr_cast(P#x, ^b_node)) == $oset_union($oset_singleton($phys_ptr_cast(P#x, ^b_node)), $oset_union(F#treap_reach($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_reach($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_keys(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->key))), @_vcc_intset_union(treap_keys(*((x->left))), treap_keys(*((x->right))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_keys($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_keys($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_keys($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), @\int_max(treap_max_key(*((x->left))), treap_max_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_key(x), @\int_max(*((x->key)), treap_max_key(*((x->right)))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), @\int_max(treap_max_prio(*((x->left))), treap_max_prio(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_max_prio(x), @\int_max(*((x->prio)), treap_max_prio(*((x->right)))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), $int_max(F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_max_prio($s, $phys_ptr_cast(P#x, ^b_node)) == $int_max($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node)), F#treap_max_prio($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), &&(&&(==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), @\int_min(treap_min_key(*((x->left))), treap_min_key(*((x->right))))))), ==>(&&(@_vcc_ptr_neq_null(*((x->left))), @_vcc_ptr_eq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->left))))))), ==>(&&(@_vcc_ptr_eq_null(*((x->left))), @_vcc_ptr_neq_null(*((x->right)))), ==(treap_min_key(x), @\int_min(*((x->key)), treap_min_key(*((x->right)))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), $int_min(F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))))) && ($non_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $is_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)))) && ($is_null($rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)) && $non_null($rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node)) ==> F#treap_min_key($s, $phys_ptr_cast(P#x, ^b_node)) == $int_min($rd_inv($s, b_node.key, $phys_ptr_cast(P#x, ^b_node)), F#treap_min_key($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // assume ==>(@_vcc_ptr_neq_null(x), ==(treap_prios(x), @_vcc_intset_union(@_vcc_intset_singleton(*((x->prio))), @_vcc_intset_union(treap_prios(*((x->left))), treap_prios(*((x->right))))))); 
                assume $non_null($phys_ptr_cast(P#x, ^b_node)) ==> F#treap_prios($s, $phys_ptr_cast(P#x, ^b_node)) == $intset_union($intset_singleton($rd_inv($s, b_node.prio, $phys_ptr_cast(P#x, ^b_node))), $intset_union(F#treap_prios($s, $rd_phys_ptr($s, b_node.left, $phys_ptr_cast(P#x, ^b_node), ^b_node)), F#treap_prios($s, $rd_phys_ptr($s, b_node.right, $phys_ptr_cast(P#x, ^b_node), ^b_node))));
                // return tmp#8; 
                $result := $phys_ptr_cast(tmp#8, ^b_node);
                assume true;
                assert $position_marker();
                goto #exit;
            }
        }
    }

  anon10:
    // skip

  #exit:
// INV:LOOPTAIL
}



axiom (forall Q#__vcc_state$2^230.9#tc3#1443: $state, Q#x$2^230.9#dt1#1333: $ptr, Q#i$2^230.9#tc1#1334: int :: {:weight 10} { $intset_in(Q#i$2^230.9#tc1#1334, F#treap_keys(Q#__vcc_state$2^230.9#tc3#1443, $phys_ptr_cast(Q#x$2^230.9#dt1#1333, ^b_node))) } $good_state(Q#__vcc_state$2^230.9#tc3#1443) && $in_range_i4(Q#i$2^230.9#tc1#1334) ==> Q#i$2^230.9#tc1#1334 < F#treap_min_key(Q#__vcc_state$2^230.9#tc3#1443, $phys_ptr_cast(Q#x$2^230.9#dt1#1333, ^b_node)) ==> !$intset_in(Q#i$2^230.9#tc1#1334, F#treap_keys(Q#__vcc_state$2^230.9#tc3#1443, $phys_ptr_cast(Q#x$2^230.9#dt1#1333, ^b_node))));

axiom (forall Q#__vcc_state$2^231.9#tc3#1444: $state, Q#x$2^231.9#dt1#1335: $ptr, Q#i$2^231.9#tc1#1336: int :: {:weight 10} { $intset_in(Q#i$2^231.9#tc1#1336, F#treap_keys(Q#__vcc_state$2^231.9#tc3#1444, $phys_ptr_cast(Q#x$2^231.9#dt1#1335, ^b_node))) } $good_state(Q#__vcc_state$2^231.9#tc3#1444) && $in_range_i4(Q#i$2^231.9#tc1#1336) ==> Q#i$2^231.9#tc1#1336 > F#treap_max_key(Q#__vcc_state$2^231.9#tc3#1444, $phys_ptr_cast(Q#x$2^231.9#dt1#1335, ^b_node)) ==> !$intset_in(Q#i$2^231.9#tc1#1336, F#treap_keys(Q#__vcc_state$2^231.9#tc3#1444, $phys_ptr_cast(Q#x$2^231.9#dt1#1335, ^b_node))));

axiom (forall Q#__vcc_state$2^232.9#tc3#1445: $state, Q#x$2^232.9#dt1#1337: $ptr, Q#i$2^232.9#tc1#1338: int :: {:weight 10} { $intset_in(Q#i$2^232.9#tc1#1338, F#treap_prios(Q#__vcc_state$2^232.9#tc3#1445, $phys_ptr_cast(Q#x$2^232.9#dt1#1337, ^b_node))) } $good_state(Q#__vcc_state$2^232.9#tc3#1445) && $in_range_i4(Q#i$2^232.9#tc1#1338) ==> Q#i$2^232.9#tc1#1338 > F#treap_max_prio(Q#__vcc_state$2^232.9#tc3#1445, $phys_ptr_cast(Q#x$2^232.9#dt1#1337, ^b_node)) ==> !$intset_in(Q#i$2^232.9#tc1#1338, F#treap_prios(Q#__vcc_state$2^232.9#tc3#1445, $phys_ptr_cast(Q#x$2^232.9#dt1#1337, ^b_node))));

axiom (forall Q#__vcc_state$2^233.9#tc3#1446: $state, Q#x$2^233.9#dt1#1339: $ptr :: {:weight 10} { F#treap(Q#__vcc_state$2^233.9#tc3#1446, $phys_ptr_cast(Q#x$2^233.9#dt1#1339, ^b_node)) } { F#treap_max_prio(Q#__vcc_state$2^233.9#tc3#1446, $phys_ptr_cast(Q#x$2^233.9#dt1#1339, ^b_node)) } { $rd_inv(Q#__vcc_state$2^233.9#tc3#1446, b_node.prio, $phys_ptr_cast(Q#x$2^233.9#dt1#1339, ^b_node)) } $good_state(Q#__vcc_state$2^233.9#tc3#1446) && true ==> F#treap(Q#__vcc_state$2^233.9#tc3#1446, $phys_ptr_cast(Q#x$2^233.9#dt1#1339, ^b_node)) ==> F#treap_max_prio(Q#__vcc_state$2^233.9#tc3#1446, $phys_ptr_cast(Q#x$2^233.9#dt1#1339, ^b_node)) == $rd_inv(Q#__vcc_state$2^233.9#tc3#1446, b_node.prio, $phys_ptr_cast(Q#x$2^233.9#dt1#1339, ^b_node)));

const unique l#public: $label;

axiom $type_code_is(3, ^$#state_t);

axiom $type_code_is(1, ^^i4);

const unique #tok$3^82.9: $token;

const unique #tok$3^80.9: $token;

const unique #tok$3^74.9: $token;

const unique #tok$3^69.21: $token;

const unique #tok$3^62.9: $token;

const unique #tok$3^60.9: $token;

const unique #tok$3^54.9: $token;

const unique #tok$3^48.21: $token;

const unique #tok$3^41.5: $token;

const unique #tok$3^40.5: $token;

const unique #tok$3^39.5: $token;

const unique #tok$3^38.5: $token;

const unique #tok$3^35.20: $token;

const unique #tok$4^0.0: $token;

const unique #file^?3Cno?20file?3E: $token;

axiom $file_name_is(4, #file^?3Cno?20file?3E);

const unique #tok$3^5.3: $token;

const unique #file^Z?3A?5CInvariantSynthesis?5CVCDryad?5Cvcc?5CHost?5Cbin?5CTests?5Ctreap?5Ctreap?2Dinsert?2Drec.c: $token;

axiom $file_name_is(3, #file^Z?3A?5CInvariantSynthesis?5CVCDryad?5Cvcc?5CHost?5Cbin?5CTests?5Ctreap?5Ctreap?2Dinsert?2Drec.c);

const unique #file^z?3A?5Cinvariantsynthesis?5Cvcdryad?5Cvcc?5Chost?5Cbin?5Ctests?5Ctreap?5Cdryad_treap.h: $token;

axiom $file_name_is(2, #file^z?3A?5Cinvariantsynthesis?5Cvcdryad?5Cvcc?5Chost?5Cbin?5Ctests?5Ctreap?5Cdryad_treap.h);

const unique #file^Z?3A?5CInvariantSynthesis?5CVCDryad?2Dbin?5CHeaders?5Cvccp.h: $token;

axiom $file_name_is(1, #file^Z?3A?5CInvariantSynthesis?5CVCDryad?2Dbin?5CHeaders?5Cvccp.h);

const unique #distTp1: $ctype;

axiom #distTp1 == $ptr_to(^b_node);
